<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker学习笔记</title>
    <link href="/2022/12/10/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/12/10/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker学习笔记"><a href="#Docker学习笔记" class="headerlink" title="Docker学习笔记"></a>Docker学习笔记</h1><h2 id="1-Docker入门"><a href="#1-Docker入门" class="headerlink" title="1. Docker入门"></a>1. Docker入门</h2><h3 id="1-1-Docker三要素"><a href="#1-1-Docker三要素" class="headerlink" title="1.1 Docker三要素"></a>1.1 Docker三要素</h3><ol><li><p>镜像：只读模板，可以用来创建Docker容器。一个镜像可以创建多个容器实例。</p><p>Docker镜像类似于Java的类，而Docker容器则类似于Java的对象</p></li><li><p>容器：Docker利用容器独立运行一个或一组应用，应用程序或服务运行在容器里面，容器类似于一个虚拟化的运行环境</p><p>容器可以被启动、开始、停止、删除。每个容器都是互相隔离、保证安全的平台</p></li><li><p>仓库：集中存放镜像文件的场所。DockerHub、阿里云仓库、网易云仓库等</p></li></ol><h3 id="1-2-Docker工作原理"><a href="#1-2-Docker工作原理" class="headerlink" title="1.2 Docker工作原理"></a>1.2 Docker工作原理</h3><p>Docker是一个Client-Server结构系统。Docker的守护进程运行在主机上。</p><p>用户通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器</p><p>基本流程如下：</p><ol><li>用户使用Docker Client与Docker Daemon建立通信，并发送请求给后者</li><li>Docker Daemon作为Docker架构中的主体部分，首先提供Docker Server的功能，使其可以接受Docker Client的请求</li><li>Docker Engine执行Docker内部的一系列工作，每一项工作都是以一个Job形式存在</li><li>Job运行过程中，如果需要容器镜像时，从Docker Registry中下载镜像，并通过镜像管理驱动Graph Driver将下载的镜像以Graph形式存储。</li><li>当需要为Docker创建网络环境时，通过网络管理驱动Network Driver创建并配置Docker容器网络环境。</li><li>当需要限制Docker容器运行资源或执行用户指令等操作时，通过Exec Driver完成。</li><li>LibContainer是一项独立的容器管理包，Network Driver以及Exec Driver都是通过LibContainer实现具体对容器进行的操作。</li></ol><h3 id="1-3-CentOS-7-安装-Docker"><a href="#1-3-CentOS-7-安装-Docker" class="headerlink" title="1.3 CentOS 7 安装 Docker"></a>1.3 CentOS 7 安装 Docker</h3><ol><li><p>确认当前虚拟机为CentOS 7 版本</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/</span>redhat-release<br></code></pre></td></tr></table></figure></li><li><p>卸载旧版Docker</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">sudo yum remove docker <span class="hljs-string">\</span><br>                  docker-client <span class="hljs-string">\</span><br>                  docker-client-latest <span class="hljs-string">\</span><br>                  docker-common <span class="hljs-string">\</span><br>                  docker-latest <span class="hljs-string">\</span><br>                  docker-latest-logrotate <span class="hljs-string">\</span><br>                  docker-logrotate <span class="hljs-string">\</span><br>                  docker-engine<br></code></pre></td></tr></table></figure></li><li><p>yum安装gcc相关</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum -y <span class="hljs-keyword">install</span> gcc<br>yum -y <span class="hljs-keyword">install</span> gcc-c++<br></code></pre></td></tr></table></figure></li><li><p>yum安装说需要的软件包</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> -y yum-utils<br></code></pre></td></tr></table></figure></li><li><p>yum设置镜像仓库</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">yum-config-manager \<br>    --add-repo \<br>    https:<span class="hljs-regexp">//</span>download.docker.com<span class="hljs-regexp">/linux/</span>centos/docker-ce.repo<br></code></pre></td></tr></table></figure></li><li><p>更新yum软件包索引</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yum makecache fast</span><br></code></pre></td></tr></table></figure></li><li><p>安装Docker CE</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">yum install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io<br></code></pre></td></tr></table></figure></li><li><p>启动Docker</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> docker<br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> hello-world<br></code></pre></td></tr></table></figure></li></ol><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221206014337467.png" alt="image-20221206014337467" style="zoom:50%;" /><ol start="10"><li><p>卸载命令</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">systemctl stop docker<br>yum remove docker-ce docker-ce-<span class="hljs-keyword">cli</span> containerd.io<br><span class="hljs-keyword">rm</span> -rf /<span class="hljs-keyword">var</span>/lib/docker<br><span class="hljs-keyword">rm</span> -rf /<span class="hljs-keyword">var</span>/lib/containerd<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-4-run命令运行流程"><a href="#1-4-run命令运行流程" class="headerlink" title="1.4 run命令运行流程"></a>1.4 run命令运行流程</h3><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221206015504717.png" alt="image-20221206015504717" style="zoom:50%;" /><h3 id="1-5-为什么Docker比VM虚拟机快？"><a href="#1-5-为什么Docker比VM虚拟机快？" class="headerlink" title="1.5 为什么Docker比VM虚拟机快？"></a>1.5 为什么Docker比VM虚拟机快？</h3><ol><li><p>docker有着比虚拟机更少的抽象层 </p><p>由于docker不需要Hypervisor(虚拟机)实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。 </p></li><li><p>docker利用的是宿主机的内核,而不需要加载操作系统OS内核 </p><p>当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个docker容器只需要几秒钟。</p></li></ol><h2 id="2-Docker常用命令"><a href="#2-Docker常用命令" class="headerlink" title="2. Docker常用命令"></a>2. Docker常用命令</h2><h3 id="2-1-启动类命令"><a href="#2-1-启动类命令" class="headerlink" title="2.1 启动类命令"></a>2.1 启动类命令</h3><ol><li><p>启动Docker</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> docker<br></code></pre></td></tr></table></figure></li><li><p>停止Docker</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">systemctl stop docker<br></code></pre></td></tr></table></figure></li><li><p>重启Docker</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl restart docker</span><br></code></pre></td></tr></table></figure></li><li><p>查看Docker状态</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl status docker</span><br></code></pre></td></tr></table></figure></li><li><p>开机启动</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure></li><li><p>查看Docker概要信息</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> <span class="hljs-literal">info</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-镜像命令"><a href="#2-2-镜像命令" class="headerlink" title="2.2 镜像命令"></a>2.2 镜像命令</h3><ol><li><p>列出本地主机的镜像</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">docker images<br>docker images -<span class="hljs-selector-tag">a</span><br>docker images -aq<br></code></pre></td></tr></table></figure></li><li><p>查询某个镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> search<span class="hljs-meta"> [IMAGE]</span><br></code></pre></td></tr></table></figure></li><li><p>拉取镜像，不加tag时默认采用最新版本latest</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull<span class="hljs-meta"> [IMAGE:TAG]</span><br></code></pre></td></tr></table></figure></li><li><p>查看镜像&#x2F;容器&#x2F;数据卷所占的空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker system <span class="hljs-built_in">df</span><br></code></pre></td></tr></table></figure></li><li><p>删除某个镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> rmi<span class="hljs-meta"> [IMAGE ID]</span><br></code></pre></td></tr></table></figure></li><li><p>删除所有镜像</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">docker rmi <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">images</span> -<span class="hljs-params">q</span>)</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-容器命令"><a href="#2-3-容器命令" class="headerlink" title="2.3 容器命令"></a>2.3 容器命令</h3><ol><li><p>新建并启动容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker run <span class="hljs-selector-attr">[OPTIONS]</span> **IMAGE** <span class="hljs-selector-attr">[COMMAND]</span> <span class="hljs-selector-attr">[ARG...]</span><br></code></pre></td></tr></table></figure><p>OPTIONS说明（常用）：有些是一个减号，有些是两个减号 </p><ul><li>–name：为容器指定一个名称</li><li>-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)</li><li>-i：以交互模式运行容器，通常与 -t 同时使用</li><li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；也即 启动交互式容器(前台有伪终端，等待交互) </li><li>-P: 随机 端口映射，大写P </li><li>-p: 指定 端口映射，小写p</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -it ubuntu <span class="hljs-regexp">/bin/</span>bash <span class="hljs-comment"># 与ubuntu进行交互</span><br><span class="hljs-keyword">exit</span> <span class="hljs-comment"># 退出并停止容器</span><br>ctrl + p + q <span class="hljs-comment"># 退出不停止容器</span><br>docker exec -it [CONTAINER ID] <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><ul><li>attach 直接进入容器启动命令的终端，不会启动新的进程。用exit退出，会导致容器的停止。</li><li>exec 是在容器中打开新的终端，并且可以启动新的进程。用exit退出，不会导致容器的停止。</li><li>一般使用 docker exec 命令，因为退出容器终端，不会导致容器的停止。</li></ul></li><li><p>列出所有正在运行的容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker ps <span class="hljs-selector-attr">[OPTIONS]</span> <br></code></pre></td></tr></table></figure><p>OPTIONS说明（常用）： </p><ul><li>-a：列出当前所有 正在运行 的容器 + 历史上运行过 的 </li><li>-l：显示最近创建的容器。 </li><li>-n：显示最近n个创建的容器。 </li><li>-q：静默模式，只显示容器编号。</li></ul></li><li><p>启动已停止运行的容器</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docker <span class="hljs-keyword">start</span> [CONTAINER ID <span class="hljs-keyword">or</span> <span class="hljs-type">NAME</span>]<br></code></pre></td></tr></table></figure></li><li><p>重启容器</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docker <span class="hljs-keyword">restart</span> [CONTAINER ID <span class="hljs-keyword">or</span> <span class="hljs-type">NAME</span>]<br></code></pre></td></tr></table></figure></li><li><p>停止容器</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran">docker <span class="hljs-keyword">stop</span> [CONTAINER ID or <span class="hljs-keyword">NAME</span>]<br>docker kill [CONTAINER ID or <span class="hljs-keyword">NAME</span>] # 强制停止<br></code></pre></td></tr></table></figure></li><li><p>停止所有容器</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">docker stop <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">ps</span> -<span class="hljs-params">aq</span>)</span><br></code></pre></td></tr></table></figure></li><li><p>删除容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> rm<span class="hljs-meta"> [CONTAINER ID]</span><br></code></pre></td></tr></table></figure></li><li><p>删除所有容器</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">docker rm <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">ps</span> -<span class="hljs-params">aq</span>)</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-Redis演示"><a href="#2-4-Redis演示" class="headerlink" title="2.4 Redis演示"></a>2.4 Redis演示</h3><ol><li><p>Redis前台交互式启动</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -it redis:<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure></li><li><p>Redis后台守护式启动</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d redis:<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">docker</span> logs<span class="hljs-meta"> [CONTAINER ID]</span><br></code></pre></td></tr></table></figure></li><li><p>查看容器内运行的进程</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker <span class="hljs-attribute">top</span> <span class="hljs-selector-attr">[CONTAINER ID]</span><br></code></pre></td></tr></table></figure></li><li><p>查看容器内部细节</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> inspect<span class="hljs-meta"> [CONTAINER ID]</span><br></code></pre></td></tr></table></figure></li><li><p>从容器内拷贝文件到主机上</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">docker</span> <span class="hljs-meta">cp</span>  容器ID:容器内路径 目的主机路径<br></code></pre></td></tr></table></figure></li><li><p>导入和导出容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span>  容器ID:容器内路径 目的主机路径<br><span class="hljs-built_in">cat</span> 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-Docker镜像"><a href="#3-Docker镜像" class="headerlink" title="3. Docker镜像"></a>3. Docker镜像</h2><h3 id="3-1-基础概念"><a href="#3-1-基础概念" class="headerlink" title="3.1 基础概念"></a>3.1 基础概念</h3><p>是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。  </p><p>只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。 </p><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持 对文件系统的修改作为一次提交来一层层的叠加， 同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。 镜像可以通过分层来进行继承 ，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><ul><li><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 </p></li><li><p>重点理解：</p><p>Docker镜像层都是只读的，容器层是可写的。</p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><p>所有对容器的改动都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p></li></ul><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221206131046744.png" alt="image-20221206131046744" style="zoom:50%;" /><h3 id="3-2-commit案例"><a href="#3-2-commit案例" class="headerlink" title="3.2 commit案例"></a>3.2 commit案例</h3><ol><li><p>Docker Ubuntu容器内执行安装vim命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> update <br>apt-<span class="hljs-built_in">get</span> -y install vim<br></code></pre></td></tr></table></figure></li><li><p>提交新的ubuntu</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker commit <span class="hljs-attribute">-m</span>=<span class="hljs-string">&quot;提交的描述信息&quot;</span> <span class="hljs-attribute">-a</span>=<span class="hljs-string">&quot;作者&quot;</span> 容器ID 要创建的目标镜像名:[标签名]<br></code></pre></td></tr></table></figure></li></ol><p>Docker中的镜像分层， 支持通过扩展现有镜像，创建新的镜像 。类似Java继承于一个Base基础类，自己再按需扩展。 </p><p>新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层</p><h3 id="3-3-本地镜像发布到私有库"><a href="#3-3-本地镜像发布到私有库" class="headerlink" title="3.3 本地镜像发布到私有库"></a>3.3 本地镜像发布到私有库</h3><ol><li><p>下载镜像Docker Registry</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull registry</span><br></code></pre></td></tr></table></figure></li><li><p>运行私有库Registry，相当于本地有个私有Docker hub</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">docker run -d -p <span class="hljs-number">5000</span><span class="hljs-symbol">:</span><span class="hljs-number">5000</span>  -v /zzyyuse/myregistry/<span class="hljs-symbol">:/tmp/registry</span> --privileged=<span class="hljs-literal">true</span> registry<br></code></pre></td></tr></table></figure><p>默认情况，仓库被创建在容器的&#x2F;var&#x2F;lib&#x2F;registry目录下，建议自行用容器卷映射，方便于宿主机联调 </p></li><li><p>curl查看私有库镜像</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -XGET http:<span class="hljs-regexp">//</span><span class="hljs-number">10.249</span>.<span class="hljs-number">238.5</span>:<span class="hljs-number">5000</span><span class="hljs-regexp">/v2/</span>_catalog<br></code></pre></td></tr></table></figure></li><li><p>将需要发布的镜像tag修改为符合私服规范的tag</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> tag  myubuntu:<span class="hljs-number">0</span>.<span class="hljs-number">1</span>  <span class="hljs-number">10.249.238.5:5000</span>/myubuntu:<span class="hljs-number">0</span>.<span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure></li><li><p>push推送到私有库</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> push <span class="hljs-number">192.168.111.162:5000</span>/zzyyubuntu:<span class="hljs-number">1</span>.<span class="hljs-number">2</span> <br></code></pre></td></tr></table></figure></li></ol><h2 id="4-Docker容器数据卷"><a href="#4-Docker容器数据卷" class="headerlink" title="4. Docker容器数据卷"></a>4. Docker容器数据卷</h2><p>一句话：类似Redis的数据持久化机制 RDB与AOF</p><p>将docker容器内的数据保存进宿主机的磁盘中</p><p>运行一个带有容器卷存储功能的容器实例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -it <span class="hljs-attribute">--privileged</span>=<span class="hljs-literal">true</span> -v /宿主机绝对路径目录:/容器内目录   镜像名<br></code></pre></td></tr></table></figure><ol><li>数据卷可在容器之间共享或重用数据 </li><li>卷中的更改可以直接实时生效到宿主机</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ol><p>数据卷案例</p><ol><li><p>映射添加数据卷</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -it <span class="hljs-attribute">--privileged</span>=<span class="hljs-literal">true</span> -v /tmp/host_data:/tmp/docker_data <span class="hljs-attribute">--name</span>=u1 ubuntu<br></code></pre></td></tr></table></figure></li><li><p>在docker容器中添加文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /tmp/docker_data/<br><span class="hljs-built_in">touch</span> dockerin.txt<br></code></pre></td></tr></table></figure></li><li><p>在宿主机对应目录下查看，同步成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /tmp/host_data/<br><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure></li><li><p>查看数据卷是否挂载成功</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker <span class="hljs-keyword">inspect</span> 容器ID<br></code></pre></td></tr></table></figure></li></ol><p>读写限制：容器实例内部被限制，只能读取不能写</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -it <span class="hljs-attribute">--privileged</span>=<span class="hljs-literal">true</span> -v /宿主机绝对路径目录:/容器内目录:ro  镜像名<br></code></pre></td></tr></table></figure><h2 id="5-Docker-MySQL主从复制"><a href="#5-Docker-MySQL主从复制" class="headerlink" title="5. Docker MySQL主从复制"></a>5. Docker MySQL主从复制</h2><ol><li><p>新建主服务器容器实例5007</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -p <span class="hljs-number">3307</span>:<span class="hljs-number">3306</span> --name mysql-master -v <span class="hljs-regexp">/mydata/my</span>sql-master<span class="hljs-regexp">/log:/</span>var<span class="hljs-regexp">/log/my</span>sql -v <span class="hljs-regexp">/mydata/my</span>sql-master<span class="hljs-regexp">/data:/</span>var<span class="hljs-regexp">/lib/my</span>sql -v <span class="hljs-regexp">/mydata/my</span>sql-master<span class="hljs-regexp">/conf:/</span>etc<span class="hljs-regexp">/mysql/</span>conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:<span class="hljs-number">8.0</span>.<span class="hljs-number">31</span><br></code></pre></td></tr></table></figure></li><li><p>进入&#x2F;mydata&#x2F;mysql-master&#x2F;conf目录下新建my.cnf</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span> <br><span class="hljs-comment">## 设置server_id，同一局域网中需要唯一 </span><br><span class="hljs-attr">server_id</span>=<span class="hljs-number">101</span>  <br><span class="hljs-comment">## 指定不需要同步的数据库名称 </span><br><span class="hljs-attr">binlog-ignore-db</span>=mysql   <br><span class="hljs-comment">## 开启二进制日志功能 </span><br><span class="hljs-attr">log-bin</span>=mall-mysql-bin   <br><span class="hljs-comment">## 设置二进制日志使用内存大小（事务） </span><br><span class="hljs-attr">binlog_cache_size</span>=<span class="hljs-number">1</span>M   <br><span class="hljs-comment">## 设置使用的二进制日志格式（mixed,statement,row） </span><br><span class="hljs-attr">binlog_format</span>=mixed   <br><span class="hljs-comment">## 二进制日志过期清理时间。默认值为0，表示不自动清理。 </span><br><span class="hljs-attr">expire_logs_days</span>=<span class="hljs-number">7</span>   <br><span class="hljs-comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。 </span><br><span class="hljs-comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致 </span><br><span class="hljs-attr">slave_skip_errors</span>=<span class="hljs-number">1062</span> <br></code></pre></td></tr></table></figure></li><li><p>修改完配置后重启master实例</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker restart mysql-<span class="hljs-literal">master</span><br></code></pre></td></tr></table></figure></li><li><p>进入mysql-master容器</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker exec -it mysql-<span class="hljs-keyword">master</span> <span class="hljs-title">/bin</span>/bash<br>mysql -uroot -proot<br></code></pre></td></tr></table></figure></li><li><p>master容器实例内创建数据同步用户</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;slave&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">REPLICATION</span> SLAVE, <span class="hljs-keyword">REPLICATION</span> CLIENT <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;slave&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br><br>MySQL8额外步骤：<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;slave&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br>flush <span class="hljs-keyword">privileges</span>;<br></code></pre></td></tr></table></figure></li><li><p>新建从服务器容器实例3308（与主机密码不要设置为一样的）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -p <span class="hljs-number">3308</span>:<span class="hljs-number">3306</span> --name mysql-slave -v <span class="hljs-regexp">/mydata/my</span>sql-slave<span class="hljs-regexp">/log:/</span>var<span class="hljs-regexp">/log/my</span>sql -v <span class="hljs-regexp">/mydata/my</span>sql-slave<span class="hljs-regexp">/data:/</span>var<span class="hljs-regexp">/lib/my</span>sql -v <span class="hljs-regexp">/mydata/my</span>sql-slave<span class="hljs-regexp">/conf:/</span>etc<span class="hljs-regexp">/mysql/</span>conf.d -e MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span> -d mysql:<span class="hljs-number">8.0</span>.<span class="hljs-number">31</span><br></code></pre></td></tr></table></figure></li><li><p>进入&#x2F;mydata&#x2F;mysql-slave&#x2F;conf目录下新建my.cnf</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span> <br><span class="hljs-comment">## 设置server_id，同一局域网中需要唯一 </span><br><span class="hljs-attr">server_id</span>=<span class="hljs-number">102</span> <br><span class="hljs-comment">## 指定不需要同步的数据库名称 </span><br><span class="hljs-attr">binlog-ignore-db</span>=mysql   <br><span class="hljs-comment">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用 </span><br><span class="hljs-attr">log-bin</span>=mall-mysql-slave1-bin   <br><span class="hljs-comment">## 设置二进制日志使用内存大小（事务） </span><br><span class="hljs-attr">binlog_cache_size</span>=<span class="hljs-number">1</span>M   <br><span class="hljs-comment">## 设置使用的二进制日志格式（mixed,statement,row） </span><br><span class="hljs-attr">binlog_format</span>=mixed   <br><span class="hljs-comment">## 二进制日志过期清理时间。默认值为0，表示不自动清理。 </span><br><span class="hljs-attr">expire_logs_days</span>=<span class="hljs-number">7</span>   <br><span class="hljs-comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。 </span><br><span class="hljs-comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致 </span><br><span class="hljs-attr">slave_skip_errors</span>=<span class="hljs-number">1062</span>   <br><span class="hljs-comment">## relay_log配置中继日志 </span><br><span class="hljs-attr">relay_log</span>=mall-mysql-relay-bin   <br><span class="hljs-comment">## log_slave_updates表示slave将复制事件写进自己的二进制日志 </span><br><span class="hljs-attr">log_slave_updates</span>=<span class="hljs-number">1</span>   <br><span class="hljs-comment">## slave设置为只读（具有super权限的用户除外） </span><br><span class="hljs-attr">read_only</span>=<span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure></li><li><p>修改完配置后重启slave实例</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker restart mysql-<span class="hljs-literal">slave</span><br></code></pre></td></tr></table></figure></li><li><p>在主数据库中查看主从同步状态，得到file与position（用于从数据库配置参数）</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">show master status;<br><br><span class="hljs-section">mysql&gt; show master status;</span><br><span class="hljs-section">+-----------------------+----------+--------------+------------------+-------------------+</span><br><span class="hljs-section">| File                  | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="hljs-section">+-----------------------+----------+--------------+------------------+-------------------+</span><br><span class="hljs-section">| mall-mysql-bin.000004 |      714 |              | mysql            |                   |</span><br><span class="hljs-section">+-----------------------+----------+--------------+------------------+-------------------+</span><br></code></pre></td></tr></table></figure></li><li><p>在从数据库中配置主从复制</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">change master <span class="hljs-keyword">to</span> <span class="hljs-attribute">master_host</span>=<span class="hljs-string">&#x27;10.249.238.5&#x27;</span>, <span class="hljs-attribute">master_user</span>=<span class="hljs-string">&#x27;slave&#x27;</span>, <span class="hljs-attribute">master_password</span>=<span class="hljs-string">&#x27;123456&#x27;</span>, <span class="hljs-attribute">master_port</span>=3307, <span class="hljs-attribute">master_log_file</span>=<span class="hljs-string">&#x27;mall-mysql-bin.000004&#x27;</span>, <span class="hljs-attribute">master_log_pos</span>=714, <span class="hljs-attribute">master_connect_retry</span>=30; <br></code></pre></td></tr></table></figure><p>master_host：主数据库的IP地址； </p><p>master_port：主数据库的运行端口； </p><p>master_user：在主数据库创建的用于同步数据的用户账号； </p><p>master_password：在主数据库创建的用于同步数据的用户密码； </p><p>master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数； </p><p>master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数； </p><p>master_connect_retry：连接失败重试的时间间隔，单位为秒。 </p></li><li><p>在从数据库中开启主从同步</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-literal">start</span> <span class="hljs-literal">slave</span>;<br></code></pre></td></tr></table></figure></li><li><p>查看从数据库状态，发现已同步</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">show</span> <span class="hljs-string">slave</span> <span class="hljs-string">status;</span><br><span class="hljs-attr">Slave_IO_Running:</span> <span class="hljs-literal">Yes</span><br><span class="hljs-attr">Slave_SQL_Running:</span> <span class="hljs-literal">Yes</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="6-分布式存储"><a href="#6-分布式存储" class="headerlink" title="6. 分布式存储"></a>6. 分布式存储</h2><h3 id="6-1-哈希取余分区"><a href="#6-1-哈希取余分区" class="headerlink" title="6.1 哈希取余分区"></a>6.1 哈希取余分区</h3><p>2亿条记录就是2亿个k,v，我们单机不行必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式：</p><p>hash(key) % N个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。 </p><p>优点：简单粗暴，直接有效，只需要预估好数据规划好节点，例如3台、8台、10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。</p><p>缺点：原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：Hash(key)&#x2F;3会变成Hash(key) &#x2F;?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。 某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。</p><h3 id="6-2-一致性哈希算法分区"><a href="#6-2-一致性哈希算法分区" class="headerlink" title="6.2 一致性哈希算法分区"></a>6.2 一致性哈希算法分区</h3><ol><li><p>构建一致性哈希环</p><p>一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间[0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连(0 &#x3D; 2^32),这样让它逻辑上形成了一个环形空间。 </p></li><li><p>将集群中各个IP节点映射到环上的某一个位置。 </p><p>将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。</p></li><li><p>当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置， 从此位置沿环顺时针行走，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。</p></li></ol><p>优点：</p><ul><li><p>容错性：假设Node C宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则 受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据 ，其它不会受到影响。简单说，就是C挂了，受到影响的只是B、C之间的数据，并且这些数据会转移到D进行存储。</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221207143658100.png" alt="image-20221207143658100" style="zoom:50%;" /></li><li><p>扩展性：数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可， 不会导致hash取余全部数据重新洗牌。</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221207143624648.png" alt="image-20221207143624648" style="zoom: 50%;" /></li></ul><p>缺点：Hash环的数据倾斜问题 </p><p>一致性Hash算法在服务 <strong>节点太少时</strong> ，容易因为节点分布不均匀而造成 <strong>数据倾斜</strong> （被缓存的对象大部分集中缓存在某一台服务器上）</p><h2 id="7-Docker-Redis集群搭建"><a href="#7-Docker-Redis集群搭建" class="headerlink" title="7. Docker Redis集群搭建"></a>7. Docker Redis集群搭建</h2><h3 id="7-1-主从搭建"><a href="#7-1-主从搭建" class="headerlink" title="7.1 主从搭建"></a>7.1 主从搭建</h3><ol><li><p>搭建Redis集群</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker run -d <span class="hljs-params">--name</span> redis-node-1 <span class="hljs-params">--net</span> host <span class="hljs-params">--privileged=true</span> -v <span class="hljs-string">/data/redis/share/redis-node-1</span>:<span class="hljs-string">/data</span> redis<span class="hljs-function">:6.0.16</span> <span class="hljs-params">--cluster-enabled</span> yes <span class="hljs-params">--appendonly</span> yes <span class="hljs-params">--port</span> 6381 <br>  <br>docker run -d <span class="hljs-params">--name</span> redis-node-2 <span class="hljs-params">--net</span> host <span class="hljs-params">--privileged=true</span> -v <span class="hljs-string">/data/redis/share/redis-node-2</span>:<span class="hljs-string">/data</span> redis<span class="hljs-function">:6.0.16</span> <span class="hljs-params">--cluster-enabled</span> yes <span class="hljs-params">--appendonly</span> yes <span class="hljs-params">--port</span> 6382 <br>  <br>docker run -d <span class="hljs-params">--name</span> redis-node-3 <span class="hljs-params">--net</span> host <span class="hljs-params">--privileged=true</span> -v <span class="hljs-string">/data/redis/share/redis-node-3</span>:<span class="hljs-string">/data</span> redis<span class="hljs-function">:6.0.16</span> <span class="hljs-params">--cluster-enabled</span> yes <span class="hljs-params">--appendonly</span> yes <span class="hljs-params">--port</span> 6383 <br>  <br>docker run -d <span class="hljs-params">--name</span> redis-node-4 <span class="hljs-params">--net</span> host <span class="hljs-params">--privileged=true</span> -v <span class="hljs-string">/data/redis/share/redis-node-4</span>:<span class="hljs-string">/data</span> redis<span class="hljs-function">:6.0.16</span> <span class="hljs-params">--cluster-enabled</span> yes <span class="hljs-params">--appendonly</span> yes <span class="hljs-params">--port</span> 6384 <br>  <br>docker run -d <span class="hljs-params">--name</span> redis-node-5 <span class="hljs-params">--net</span> host <span class="hljs-params">--privileged=true</span> -v <span class="hljs-string">/data/redis/share/redis-node-5</span>:<span class="hljs-string">/data</span> redis<span class="hljs-function">:6.0.16</span> <span class="hljs-params">--cluster-enabled</span> yes <span class="hljs-params">--appendonly</span> yes <span class="hljs-params">--port</span> 6385 <br>  <br>docker run -d <span class="hljs-params">--name</span> redis-node-6 <span class="hljs-params">--net</span> host <span class="hljs-params">--privileged=true</span> -v <span class="hljs-string">/data/redis/share/redis-node-6</span>:<span class="hljs-string">/data</span> redis<span class="hljs-function">:6.0.16</span> <span class="hljs-params">--cluster-enabled</span> yes <span class="hljs-params">--appendonly</span> yes <span class="hljs-params">--port</span> 6386 <br></code></pre></td></tr></table></figure></li><li><p>进入容器，为集群构建主从关系</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">docker exec -it redis-node-<span class="hljs-number">1</span> /bin/bash<br><br>redis-cli --cluster create <span class="hljs-number">10.249.238.5</span>:<span class="hljs-number">6381 10.249</span>.<span class="hljs-number">238.5:6382</span> <span class="hljs-number">10.249.238.5</span>:<span class="hljs-number">6383 10.249</span>.<span class="hljs-number">238.5:6384</span> <span class="hljs-number">10.249.238.5</span>:<span class="hljs-number">6385 10.249</span>.<span class="hljs-number">238.5:6386</span>  --cluster-replicas <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure></li></ol><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221207153624644.png" alt="image-20221207153624644" style="zoom:50%;" /><ol start="3"><li>通过 <code>redis-cli -p 6381 -c</code> 命令进入集群，以防止路由失效</li><li>通过命令 <code>redis-cli --cluster check 10.249.238.5:6381</code> 查看集群状态</li><li>主从切换：主机宕机，从机上位</li></ol><h3 id="7-2-主从扩容"><a href="#7-2-主从扩容" class="headerlink" title="7.2 主从扩容"></a>7.2 主从扩容</h3><ol><li><p>新建两个Redis节点</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker run -d <span class="hljs-params">--name</span> redis-node-7 <span class="hljs-params">--net</span> host <span class="hljs-params">--privileged=true</span> -v <span class="hljs-string">/data/redis/share/redis-node-7</span>:<span class="hljs-string">/data</span> redis<span class="hljs-function">:6.0.16</span> <span class="hljs-params">--cluster-enabled</span> yes <span class="hljs-params">--appendonly</span> yes <span class="hljs-params">--port</span> 6387 <br><br>docker run -d <span class="hljs-params">--name</span> redis-node-8 <span class="hljs-params">--net</span> host <span class="hljs-params">--privileged=true</span> -v <span class="hljs-string">/data/redis/share/redis-node-8</span>:<span class="hljs-string">/data</span> redis<span class="hljs-function">:6.0.16</span> <span class="hljs-params">--cluster-enabled</span> yes <span class="hljs-params">--appendonly</span> yes <span class="hljs-params">--port</span> 6388 <br></code></pre></td></tr></table></figure></li><li><p>进入6387容器内部</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker exec -it redis-<span class="hljs-keyword">node</span><span class="hljs-title">-7</span> /bin/bash<br></code></pre></td></tr></table></figure><p>将新增的6387节点作为master节点加入集群</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali"><span class="hljs-comment"># 6387 就是将要作为master新增节点 </span><br><span class="hljs-comment"># 6381 就是原来集群节点里面的领路人</span><br>redis-cli --cluster<span class="hljs-built_in"> add-node </span>10.249.238.5:6387 10.249.238.5:6381<br></code></pre></td></tr></table></figure></li><li><p>检查集群情况</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">redis-cli --cluster<span class="hljs-built_in"> check </span>10.249.238.5:6381<br></code></pre></td></tr></table></figure><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221207171056093.png" alt="image-20221207171056093" style="zoom: 50%;" /></li><li><p>重新分派槽号</p><p>4台机器：平分之后为4096</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">redis-<span class="hljs-keyword">cli</span> --<span class="hljs-keyword">cluster</span> reshard 10.249.238.5:6381<br></code></pre></td></tr></table></figure><p>为什么6387是3个新的区间，以前的还是连续？</p><p>重新分配成本太高，所以前3家各自匀出来一部分，从6381&#x2F;6382&#x2F;6383三个旧节点分别匀出1364个坑位给新节点6387</p></li></ol><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221207171611411.png" alt="image-20221207171611411" style="zoom:50%;" /><ol start="5"><li><p>为主节点6387分配从节点6388</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">redis-cli --cluster<span class="hljs-built_in"> add-node </span>10.249.238.5:6388 10.249.238.5:6387 --cluster-slave --cluster-master-id b8fbe4eba45cb5f8c44eca3fe15e0a96d927d27c<br></code></pre></td></tr></table></figure></li></ol><h3 id="7-3-主从缩容"><a href="#7-3-主从缩容" class="headerlink" title="7.3 主从缩容"></a>7.3 主从缩容</h3><p>将添加的两个节点6387和6388下线（先删从节点，再删主节点）</p><ol><li><p>将6388删除</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">redis-cli --cluster del-<span class="hljs-keyword">node</span> <span class="hljs-title">10</span>.<span class="hljs-number">249.238</span>.<span class="hljs-number">5</span>:<span class="hljs-number">6388</span> <span class="hljs-number">67673</span>fee431f0146671773da6326076bb8b30343<br></code></pre></td></tr></table></figure></li><li><p>将6387的槽号清空，重新分配。这里全部分配给6382</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">redis-<span class="hljs-keyword">cli</span> --<span class="hljs-keyword">cluster</span> reshard 10.249.238.5:6381 <br></code></pre></td></tr></table></figure></li><li><p>将6387删除</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">redis-cli --cluster del-<span class="hljs-keyword">node</span> <span class="hljs-title">10</span>.<span class="hljs-number">249.238</span>.<span class="hljs-number">5</span>:<span class="hljs-number">6387</span> b8fbe4eba45cb5f8c44eca3fe15e0a96d927d27c<br></code></pre></td></tr></table></figure></li></ol><h2 id="8-DockerFile"><a href="#8-DockerFile" class="headerlink" title="8. DockerFile"></a>8. DockerFile</h2><p>Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p><h3 id="8-1-DockerFile基础"><a href="#8-1-DockerFile基础" class="headerlink" title="8.1 DockerFile基础"></a>8.1 DockerFile基础</h3><ol><li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li><li>指令按照从上到下，顺序执行</li><li>表示注释</li><li>每条指令都会创建一个新的镜像层并对镜像进行提交</li></ol><p>执行DockerFile基本流程</p><ol><li>docker从基础镜像运行一个容器</li><li>执行一条指令并对容器作出修改</li><li>执行类似docker commit的操作提交一个新的镜像层</li><li>docker再基于刚提交的镜像运行一个新容器</li><li>执行dockerfile中的下一条指令直到所有指令都执行完成</li></ol><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221207174219551.png" alt="image-20221207174219551" style="zoom:50%;" /><h3 id="8-2-DockerFile常见保留字"><a href="#8-2-DockerFile常见保留字" class="headerlink" title="8.2 DockerFile常见保留字"></a>8.2 DockerFile常见保留字</h3><h3 id="8-3-DockerFile自定义镜像"><a href="#8-3-DockerFile自定义镜像" class="headerlink" title="8.3 DockerFile自定义镜像"></a>8.3 DockerFile自定义镜像</h3><p>需要指定centos版本，并且 <code>RUN yum -y install glibc</code>不加版本号</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs awk">FROM centos:<span class="hljs-number">7</span><br>MAINTAINER ltyzzz&lt;ltyzzz2000@gmail.com&gt;<br> <br>ENV MYPATH <span class="hljs-regexp">/usr/</span>local<br>WORKDIR <span class="hljs-variable">$MYPATH</span><br><br><span class="hljs-comment">#安装vim编辑器</span><br>RUN yum -y install vim<br><span class="hljs-comment">#安装ifconfig命令查看网络IP</span><br>RUN yum -y install net-tools<br><span class="hljs-comment">#安装java8及lib库</span><br>RUN yum -y install glibc<br>RUN mkdir <span class="hljs-regexp">/usr/</span>local/java<br><span class="hljs-comment">#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置</span><br>ADD jdk-<span class="hljs-number">8</span>u331-linux-aarch64.tar.gz <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span><br><span class="hljs-comment">#配置java环境变量</span><br>ENV JAVA_HOME <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span>jdk1.<span class="hljs-number">8.0</span>_331<br>ENV JRE_HOME <span class="hljs-variable">$JAVA_HOME</span>/jre<br>ENV CLASSPATH <span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/lib/</span>dt.jar:<span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/lib/</span>tools.jar:<span class="hljs-variable">$JRE_HOME</span>/lib:<span class="hljs-variable">$CLASSPATH</span><br>ENV PATH <span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><br>EXPOSE <span class="hljs-number">80</span><br><br>CMD echo <span class="hljs-variable">$MYPATH</span><br>CMD echo <span class="hljs-string">&quot;success--------------ok&quot;</span><br>CMD <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><h3 id="8-4-DockerFile虚悬镜像"><a href="#8-4-DockerFile虚悬镜像" class="headerlink" title="8.4 DockerFile虚悬镜像"></a>8.4 DockerFile虚悬镜像</h3><p>仓库名、标签都是<none>的镜像，即dangling image</p><p>编写虚悬镜像步骤</p><ol><li><p>编写Dockerfile文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">vim Dockerfile<br><br><span class="hljs-keyword">from</span> ubuntu<br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;action is success&#x27;</span> </span><br></code></pre></td></tr></table></figure></li><li><p>构建镜像</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">docker build .<br></code></pre></td></tr></table></figure></li><li><p>查看虚悬镜像</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker image ls -f dangling=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="9-Docker部署模块"><a href="#9-Docker部署模块" class="headerlink" title="9. Docker部署模块"></a>9. Docker部署模块</h2><h3 id="9-1-部署过程"><a href="#9-1-部署过程" class="headerlink" title="9.1 部署过程"></a>9.1 部署过程</h3><p>通过打包Springboot项目得到jar包，并通过Dockerfile生成镜像，以容器形式运行在虚拟机上</p><ol><li><p>打包Springboot项目：package</p></li><li><p>在虚拟机中的&#x2F;mydocker目录下编写Dockerfile文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 基础镜像java</span><br><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">8</span> <br><span class="hljs-comment"># 作者 </span><br><span class="hljs-keyword">MAINTAINER</span> lty <br><span class="hljs-comment"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp </span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /tmp </span><br><span class="hljs-comment"># 将jar包添加到容器中并更名为zzyy_docker.jar </span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> docker-demo-0.0.1-SNAPSHOT.jar lty_docker.jar</span><br><span class="hljs-comment"># 运行jar包 </span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> bash -c <span class="hljs-string">&#x27;touch /lty_docker.jar&#x27;</span> </span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;/lty_docker.jar&quot;</span>] </span><br><span class="hljs-comment">#暴露6001端口作为微服务 </span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">6001</span><br></code></pre></td></tr></table></figure></li><li><p>将生成的jar包拖动到虚拟机mydocker目录下</p></li><li><p>通过如下命令生成镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> build -t lty_docker:<span class="hljs-number">1</span>.<span class="hljs-number">0</span> .<br></code></pre></td></tr></table></figure></li><li><p>以容器方式后台运行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d -p <span class="hljs-number">6001</span>:<span class="hljs-number">6001</span> <span class="hljs-number">376</span>a8091251b<br></code></pre></td></tr></table></figure></li></ol><h3 id="9-2-容器通信bug"><a href="#9-2-容器通信bug" class="headerlink" title="9.2 容器通信bug"></a>9.2 容器通信bug</h3><p>主机中的容器失去与外界容器的连接:</p><ol><li>主机可以与其他主机通信。</li><li>在主机中运行的容器无法与其他主机通信。</li></ol><p>后台运行通过Dockerfile打包的Springboot镜像后提示：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-symbol">WARNING: </span>IPv4 forwarding is disabled. Networking will not work.<br></code></pre></td></tr></table></figure><p>解决方案：</p><ol><li><p>将以下内容添加到 &#x2F;etc&#x2F;sysctl.conf 中</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">net.ipv4.ip_forward</span>=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>重启网络服务</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">service network restart</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="10-Docker网络"><a href="#10-Docker网络" class="headerlink" title="10. Docker网络"></a>10. Docker网络</h2><p>docker启动后，会建立一个名为docker0的虚拟网桥，可用ifconfig命令查看</p><ul><li>容器间的互联和通信以及端口映射</li><li>容器IP变动时候可以通过服务名直接网络通信而不受到影响</li></ul><h3 id="10-1-网络命令"><a href="#10-1-网络命令" class="headerlink" title="10.1 网络命令"></a>10.1 网络命令</h3><ol><li><p>查看网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure></li><li><p>查看网络源数据</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker network <span class="hljs-keyword">inspect</span>  XXX网络名字<br></code></pre></td></tr></table></figure></li><li><p>删除网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network <span class="hljs-built_in">rm</span> XXX网络名字<br></code></pre></td></tr></table></figure></li></ol><h3 id="10-2-网络模式"><a href="#10-2-网络模式" class="headerlink" title="10.2 网络模式"></a>10.2 网络模式</h3><ol><li>bridge模式：使用–network bridge指定，默认使用docker0<ul><li>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为docker0，它在 内核层 连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到 同一个物理网络 。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码， 让主机和容器之间可以通过网桥相互通信。</li></ul></li><li>host模式：使用–network host指定<ul><li>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行NAT 转换。</li></ul></li><li>none模式：使用–network none指定<ul><li>在none模式下，并不为Docker容器进行任何网络配置。 也就是说，这个Docker容器没有网卡、IP、路由等信息，只有一个lo。需要我们自己为Docker容器添加网卡、配置IP等。</li></ul></li><li>container模式：使用–network container:NAME或者容器ID指定<ul><li>新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</li></ul></li></ol><h2 id="11-Docker-Compose"><a href="#11-Docker-Compose" class="headerlink" title="11. Docker-Compose"></a>11. Docker-Compose</h2><p>Docker-Compose是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。</p><h3 id="11-1-Linux-Arm64-安装Docker-Compose"><a href="#11-1-Linux-Arm64-安装Docker-Compose" class="headerlink" title="11.1 Linux Arm64 安装Docker-Compose"></a>11.1 Linux Arm64 安装Docker-Compose</h3><p>Docker-Compose目前没有arm64版本，目前只支持pip安装</p><ol><li><p>安装apt-get</p><ul><li>apt-get命令是ubuntu等操作系统的安装命令，和yum为同类</li></ul><p>下载apt-get</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/dvershinin/</span>apt-get-centos<span class="hljs-regexp">/master/</span>apt-get.sh -o <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>apt-get<br></code></pre></td></tr></table></figure><p>修改权限</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">chmod <span class="hljs-number">0755</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>apt-get<br></code></pre></td></tr></table></figure></li><li><p>安装Docker Compose</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span> -<span class="hljs-keyword">y</span><br>sudo apt-<span class="hljs-built_in">get</span> upgrade -<span class="hljs-keyword">y</span><br>sudo apt-<span class="hljs-built_in">get</span> install curl <span class="hljs-keyword">python3</span>-pip libffi-dev <span class="hljs-keyword">python</span>-openssl libssl-dev zlib1g-dev gcc g++ <span class="hljs-keyword">make</span> -<span class="hljs-keyword">y</span><br>curl -sSL https://<span class="hljs-built_in">get</span>.docker.<span class="hljs-keyword">com</span>/ | <span class="hljs-keyword">sh</span><br>sudo snap install rustup --classic<br>sudo apt install rustc<br>sudo pip3 install docker-compose<br>sudo docker-compose --<span class="hljs-keyword">version</span><br></code></pre></td></tr></table></figure><p>sudo pip3 install docker-compose命令报错时，执行如下命令，然后再重新安装</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">sudo -H pip3 install <span class="hljs-comment">--upgrade pip</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="11-2-Compose核心概念"><a href="#11-2-Compose核心概念" class="headerlink" title="11.2 Compose核心概念"></a>11.2 Compose核心概念</h3><p>服务：一个个应用容器实例，比如订单微服务、库存微服务、mysql容器、nginx容器或者redis容器</p><p>工程：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</p><h3 id="11-3-Compose使用步骤"><a href="#11-3-Compose使用步骤" class="headerlink" title="11.3 Compose使用步骤"></a>11.3 Compose使用步骤</h3><ol><li>编写Dockerfile定义各个微服务应用并构建出对应的镜像文件</li><li>使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。</li><li>执行 <code>docker-compose up</code> 命令 来启动并运行整个应用程序，完成一键部署上线</li></ol><h3 id="11-4-Compose常用命令"><a href="#11-4-Compose常用命令" class="headerlink" title="11.4 Compose常用命令"></a>11.4 Compose常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">Compose 常用命令 <br>docker-compose -h                           <span class="hljs-comment">#  查看帮助 </span><br>docker-compose up                           <span class="hljs-comment">#  启动所有 docker-compose服务 </span><br>docker-compose up -d                        <span class="hljs-comment">#  启动所有 docker-compose服务 并后台运行 </span><br>docker-compose down                         <span class="hljs-comment">#  停止并删除容器、网络、卷、镜像。 </span><br>docker-compose <span class="hljs-built_in">exec</span>  yml里面的服务<span class="hljs-built_in">id</span>                 <span class="hljs-comment"># 进入容器实例内部  docker-compose exec  docker-compose.yml文件中写的服务id  /bin/bash </span><br>docker-compose ps                      <span class="hljs-comment"># 展示当前docker-compose编排过的运行的所有容器 </span><br>docker-compose top                     <span class="hljs-comment"># 展示当前docker-compose编排过的容器进程 </span><br>docker-compose logs  yml里面的服务<span class="hljs-built_in">id</span>     <span class="hljs-comment">#  查看容器输出日志 </span><br>docker-compose config     <span class="hljs-comment">#  检查配置 </span><br>docker-compose config -q  <span class="hljs-comment">#  检查配置，有问题才有输出 </span><br>docker-compose restart   <span class="hljs-comment">#  重启服务 </span><br>docker-compose start     <span class="hljs-comment">#  启动服务 </span><br>docker-compose stop      <span class="hljs-comment">#  停止服务 </span><br></code></pre></td></tr></table></figure><h2 id="12-Docker-Portainer"><a href="#12-Docker-Portainer" class="headerlink" title="12. Docker Portainer"></a>12. Docker Portainer</h2><p>安装命令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -d -p <span class="hljs-number">8000</span>:<span class="hljs-number">8000</span> -p <span class="hljs-number">9000</span>:<span class="hljs-number">9000</span> --name portainer --restart=always -v <span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/docker.sock:/</span>var<span class="hljs-regexp">/run/</span>docker.sock -v portainer_data:<span class="hljs-regexp">/data portainer/</span>portainer<br></code></pre></td></tr></table></figure><p>通过虚拟机访问Portainner</p>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署</tag>
      
      <tag>容器化</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC项目记录</title>
    <link href="/2022/12/07/RPC%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/12/07/RPC%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="RPC项目记录"><a href="#RPC项目记录" class="headerlink" title="RPC项目记录"></a>RPC项目记录</h1><h2 id="1-引入Proxy代理层"><a href="#1-引入Proxy代理层" class="headerlink" title="1. 引入Proxy代理层"></a>1. 引入Proxy代理层</h2><p>采用JDK类代理，执行的逻辑为：将请求方法放入SEND_QUEUE队列中，自旋等待结果响应结果（从RESP_MAP中取出）</p><p>关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">RESP_MAP.put(rpcInvocation.getUuid(), OBJECT);<br>SEND_QUEUE.add(rpcInvocation); <span class="hljs-comment">// 放入阻塞队列中</span><br><span class="hljs-comment">// 可以设置超时时间</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> RESP_MAP.get(rpcInvocation.getUuid());<br>    <span class="hljs-keyword">if</span> (object <span class="hljs-keyword">instanceof</span> RpcInvocation) &#123;<br>        <span class="hljs-keyword">return</span> ((RpcInvocation) object).getResponse();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-1-基本流程"><a href="#1-1-基本流程" class="headerlink" title="1.1 基本流程"></a>1.1 基本流程</h3><ol><li><p>Client启动时会开启一个异步线程阻塞队列，等待接收代理类放入的RpcInvocation，并将其顺序发送给对应Server</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">asyncSendJob.start();<br><span class="hljs-comment">// 异步线程 run代码：真正执行网络通信的操作</span><br><span class="hljs-type">RpcInvocation</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> SEND_QUEUE.take(); <span class="hljs-comment">// 阻塞等待接收代理类放入RpcInvocation</span><br><span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> JSON.toJSONString(data);<br><span class="hljs-type">RpcProtocol</span> <span class="hljs-variable">rpcProtocol</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcProtocol</span>(json.getBytes());<br><span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> ConnectionHandler.getChannelFuture(data.getTargetServiceName());<br>channelFuture.channel().writeAndFlush(rpcProtocol);<br></code></pre></td></tr></table></figure></li><li><p>Client先通过代理类为RpcInvocation（RpcProtocol中content的具体实现）设置必要的参数，</p><ul><li>如：目标服务、目标方法、参数、UUID等，其中UUID是为了保证Client接收结果时判断一致</li></ul><p>代理类还有如下几点核心操作：</p><ul><li>将该uuid放入一个结果集map中，key为uuid，value为NULL对象</li><li>将封装好的RpcInvocation类放入阻塞队列中</li><li>最后代理类开始自旋一定时间，从结果集map中通过uuid获取其value：RpcInvocation，从中获取response结果</li></ul></li><li><p>异步线程阻塞队列阻塞式地获取到RpcInvocation后，将其再次封装为RpcProtocol（包含有magicNumber、content、contentLength），经过Encoder编码后发送给Server</p></li><li><p>Server收到后进行Decode解码，ServerHandler将解码后的结果转为RpcProtocol，并获取其content，将content再转为RpcInvocation类。从该类中获取对应的目标服务属性，通过该属性从map（专门用来保存已经注册的服务信息）中找到对应服务，再通过目标方法属性从服务中找到对应的方法，并invoke执行得到返回结果。</p><p>注意，之前传递的RpcInvocation类的response为空，为它set返回结果。</p><p>最后将完整的RpcInvocation再次封装为RpcProtocol类并通过Encoder编码发送给Client</p></li><li><p>Client通过Decoder将数据包解码，经由ClientHandler将解码后的结果转为RpcProtocol，再将其cotent转为RpcInvocation，通过之前的结果集map判断请求与响应是否一致。若一致，则将其放入结果集map，此时自旋等待的代理类便可从中取到RpcInvocation，并返回给Client。</p></li></ol><h2 id="2-引入Zookeeper注册中心"><a href="#2-引入Zookeeper注册中心" class="headerlink" title="2. 引入Zookeeper注册中心"></a>2. 引入Zookeeper注册中心</h2><p>Zookeeper节点</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/irpc/</span>com.ltyzzz.core.service.DataService<span class="hljs-regexp">/provider/</span><span class="hljs-number">10.249</span>.<span class="hljs-number">19.183</span>:<span class="hljs-number">9093</span><br></code></pre></td></tr></table></figure><p>添加Zookeeper注册中心后</p><h3 id="2-1-Server端实现"><a href="#2-1-Server端实现" class="headerlink" title="2.1 Server端实现"></a>2.1 Server端实现</h3><p>Server main代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Server</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>();<br>server.initServerConfig(); <span class="hljs-comment">// 初始化当前服务提供者的基本信息</span><br>server.exportService(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataServiceImpl</span>()); <span class="hljs-comment">// 暴露所提供的服务接口</span><br>server.startApplication(); <span class="hljs-comment">// 启动服务端</span><br></code></pre></td></tr></table></figure><ul><li><p>在exportService方法中，将服务添加map中，服务提供者添加到set中</p><p>URL类是配置类，基于其进行存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">PROVIDER_CLASS_MAP.put(interfaceClass.getName(), serviceBean);<br><span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>();<br>url.setServiceName(interfaceClass.getName());<br>url.setApplicationName(serverConfig.getApplicationName());<br>url.addParameter(<span class="hljs-string">&quot;host&quot;</span>, CommonUtils.getIpAddress());<br>url.addParameter(<span class="hljs-string">&quot;port&quot;</span>, String.valueOf(serverConfig.getServerPort()));<br>PROVIDER_URL_SET.add(url); <br></code></pre></td></tr></table></figure></li><li><p>在startApplication方法中，调用batchExportUrl方法，开启异步任务，从PROVIDER_URL_SET中获取URL，进行服务注册</p><p>其中registerService由ZookeeperRegister实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">registryService.register(url); <span class="hljs-comment">// 注册该服务 -&gt; 本质是在Zookeeper中建立相应的节点</span><br><span class="hljs-comment">// register方法中除了建立节点，还需要将URL添加到PROVIDER_URL_SET中</span><br><span class="hljs-comment">// -&gt; PROVIDER_URL_SET.add(url);</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-Client端实现"><a href="#2-2-Client端实现" class="headerlink" title="2.2 Client端实现"></a>2.2 Client端实现</h3><p>Client main代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>();<br><span class="hljs-type">RpcReference</span> <span class="hljs-variable">rpcReference</span> <span class="hljs-operator">=</span> client.initClientApplication(); <span class="hljs-comment">//RpcReference用于实现JDK代理</span><br><span class="hljs-type">DataService</span> <span class="hljs-variable">dataService</span> <span class="hljs-operator">=</span> rpcReference.getProxy(DataService.class);<br>client.doSubscribeService(DataService.class); <span class="hljs-comment">// 订阅DataService类</span><br>ConnectionHandler.setBootstrap(client.getBootstrap()); <span class="hljs-comment">// 为ConnectionHandler设置bootstrap，具体参照2.4</span><br>client.doConnectServer(); <span class="hljs-comment">// 建立连接 -&gt; 本质是</span><br>client.startClient(); <span class="hljs-comment">// 开启异步任务，进行网络通信，具体操作仍为阻塞队列逻辑</span><br></code></pre></td></tr></table></figure><ul><li><p>在initClientApplication方法中，除了进行Bootstrap等与Netty相关的初始化操作外，还进行了事件监听器的初始化</p><p>在init方法中，向iRpcListenerLoader中添加了ServiceUpdateListener监听器</p><p>监听事件参照 <code>2.3</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">iRpcListenerLoader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IRpcListenerLoader</span>();<br>iRpcListenerLoader.init();<br></code></pre></td></tr></table></figure></li><li><p>在doSubscribeService方法中，初始化ZookeeperRegister，定义URL。根据此URL订阅相应的服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>();<br>url.setApplicationName(clientConfig.getApplicationName());<br>url.setServiceName(serviceBean.getName());<br>url.addParameter(<span class="hljs-string">&quot;host&quot;</span>, CommonUtils.getIpAddress());<br>abstractRegister.subscribe(url); <span class="hljs-comment">// 订阅该服务 -&gt; 本质是在Zookeeper中建立相应的节点</span><br><span class="hljs-comment">// register方法中除了建立节点，还需要将URL添加到SUBSCRIBE_SERVICE_LIST中</span><br><span class="hljs-comment">// -&gt; SUBSCRIBE_SERVICE_LIST.add(url.getServiceName());</span><br></code></pre></td></tr></table></figure></li><li><p>在doConnectServer方法中，提前与所有已注册的服务建立连接，并监听这些服务的变化（上线、下线、更改等）</p><ol><li>监听事件参照 <code>2.3</code></li><li>ConnectionHandler建立连接逻辑参照 <code>2.4</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String providerServiceName : SUBSCRIBE_SERVICE_LIST) &#123;<br>    <span class="hljs-comment">// getProviderIps方法获得形如「10.249.19.183:9093」此类的IP地址列表</span><br>    List&lt;String&gt; providerIps = abstractRegister.getProviderIps(providerServiceName);<br>    <span class="hljs-keyword">for</span> (String providerIp : providerIps) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// connect方法作用为往CONNECT_MAP中放相应的连接</span><br>            ConnectionHandler.connect(providerServiceName, providerIp);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;[doConnectServer] connect fail &quot;</span>, e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>();<br>    url.setServiceName(providerServiceName);<br>    <span class="hljs-comment">// 开启Watcher监听事件</span><br>    abstractRegister.doAfterSubscribe(url);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-3-监听事件机制实现"><a href="#2-3-监听事件机制实现" class="headerlink" title="2.3 监听事件机制实现"></a>2.3 监听事件机制实现</h3><p>订阅之后开启监听事件，主要用于监听已注册服务的变化</p><ol><li><p>IRpcListenerLoader：用于注册与管理监听器。当事件发生时，调用相应的监听器回调方法</p><p>IRpcEvent为发生事件接口，IRpcListener为事件监听器接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;IRpcListener&gt; iRpcListenerList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">eventThreadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>); <span class="hljs-comment">// 执行回调callBack方法</span><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">├── register<span class="hljs-constructor">Listener(IRpcListener <span class="hljs-params">iRpcListener</span>)</span> <span class="hljs-comment">// 注册监听器事件</span><br>├── send<span class="hljs-constructor">Event(IRpcEvent <span class="hljs-params">iRpcEvent</span>)</span> <span class="hljs-comment">// 调用监听器对应回调方法</span><br></code></pre></td></tr></table></figure><p>sendEvent方法实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (IRpcListener&lt;?&gt; iRpcListener : iRpcListenerList) &#123;<br>    <span class="hljs-comment">// 获取listener上监听事件的泛型</span><br>    Class&lt;?&gt; type = getInterfaceT(iRpcListener);<br>    <span class="hljs-comment">// 判断Listener监听事件的泛型是否与Watcher传递的一致</span><br>    <span class="hljs-keyword">if</span>(type.equals(iRpcEvent.getClass()))&#123;<br>        eventThreadPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 一致则异步回调处理</span><br>                    iRpcListener.callBack(iRpcEvent.getData());<br>                &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>主要监听逻辑位于ZookeeperRegister中的watchChildNodeData方法，如下：</p><p>当监听的Zookeeper服务Node发生变化时，触发Watcher事件，Watcher内调用ListenerLoader方法（事件为方法参数），由ListenerLoader寻找对应的Listener（通过传入的事件与Listener泛型上的事件对比）。</p><ul><li>URLChangeWrapper对应为发生变化的URL包装类：包括serviceName与providerUrlList</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> &#123;<br>    System.out.println(watchedEvent);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> watchedEvent.getPath();<br>    List&lt;String&gt; childrenData = zkClient.getChildrenData(path);<br>    <span class="hljs-type">URLChangeWrapper</span> <span class="hljs-variable">urlChangeWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLChangeWrapper</span>();<br>    urlChangeWrapper.setProviderUrl(childrenData);<br>    urlChangeWrapper.setServiceName(path.split(<span class="hljs-string">&quot;/&quot;</span>)[<span class="hljs-number">2</span>]);<br>    <span class="hljs-type">IRpcEvent</span> <span class="hljs-variable">iRpcEvent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IRpcUpdateEvent</span>(urlChangeWrapper);<br>    IRpcListenerLoader.sendEvent(iRpcEvent);<br><span class="hljs-comment">// 继续循环监听</span><br>    watchChildNodeData(path);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-ConnectionHandler实现"><a href="#2-4-ConnectionHandler实现" class="headerlink" title="2.4 ConnectionHandler实现"></a>2.4 ConnectionHandler实现</h3><p>按照单一职责的设计原则，将与连接有关的功能都统一封装在了一起。</p><p>主要用于Netty在客户端与服务端之间建立连接、断开连接、按照服务名获取连接等操作。</p><ol><li><p>建立连接逻辑如下：connect方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 形如 10.249.19.183:9093</span><br>String[] providerAddress = providerIp.split(<span class="hljs-string">&quot;:&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> providerAddress[<span class="hljs-number">0</span>];<br><span class="hljs-type">Integer</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> Integer.valueOf(providerAddress[<span class="hljs-number">1</span>]);<br><span class="hljs-comment">// 关键代码：创建ChannelFuture，即与目的服务简历底层通信连接</span><br><span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(ip, port).sync();<br><span class="hljs-comment">// 连接包装类对象</span><br><span class="hljs-type">ChannelFutureWrapper</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureWrapper</span>();<br>wrapper.setChannelFuture(channelFuture);<br>wrapper.setHost(ip);<br>wrapper.setPort(port);<br>SERVER_ADDRESS.add(providerIp);<br>List&lt;ChannelFutureWrapper&gt; channelFutureWrappers = CONNECT_MAP.get(providerServiceName);<br><span class="hljs-keyword">if</span> (CommonUtils.isEmptyList(channelFutureWrappers)) &#123;<br>    channelFutureWrappers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>&#125;<br>channelFutureWrappers.add(wrapper);<br><span class="hljs-comment">// 将连接添加到CONNECT_MAP中</span><br><span class="hljs-comment">// 连接CONNECT_MAP -&gt; key：需要调用的serviceName</span><br><span class="hljs-comment">//  -&gt; value：与多个服务提供者建立的连接，为List</span><br>CONNECT_MAP.put(providerServiceName, channelFutureWrappers);<br></code></pre></td></tr></table></figure></li><li><p>获取连接逻辑如下：getChannelFuture方法</p><p>每个服务可以有多个服务提供者（对应于多个物理机器）</p><p>负载均衡策略：采用简单的random函数随机选取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;ChannelFutureWrapper&gt; channelFutureWrappers = CONNECT_MAP.get(providerServiceName);<br><span class="hljs-keyword">if</span> (CommonUtils.isEmptyList(channelFutureWrappers)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;no provider exist for &quot;</span> + providerServiceName);<br>&#125;<br><span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> channelFutureWrappers.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(channelFutureWrappers.size())).getChannelFuture();<br><span class="hljs-keyword">return</span> channelFuture;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-5-远程调用流程"><a href="#2-5-远程调用流程" class="headerlink" title="2.5 远程调用流程"></a>2.5 远程调用流程</h3><h2 id="3-引入路由层"><a href="#3-引入路由层" class="headerlink" title="3. 引入路由层"></a>3. 引入路由层</h2><p>同一个服务可能对应着多个服务提供者，因此当客户端请求服务时，需要通过负载均衡策略从中选择一个合适的服务提供者</p><p>之前的设计思路为：从多个<strong>连接</strong>（ChannelFuture通道）中随机选择一个，进行网络通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> channelFutureWrappers.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(channelFutureWrappers.size())).getChannelFuture();<br></code></pre></td></tr></table></figure><p>引入路由层，可以自定义负载均衡策略进行优化。</p><p>基于 <code>SERVICE_ROUTER_MAP</code> 实现</p><ul><li>key为服务提供者名字，value为对应的连接数组</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">key -&gt; ProviderServiceName: <span class="hljs-built_in">String</span><br>value -&gt; ChannelFutureWrapper[]: <span class="hljs-built_in">Array</span><br></code></pre></td></tr></table></figure><h3 id="3-1-带权重的随机选取策略"><a href="#3-1-带权重的随机选取策略" class="headerlink" title="3.1 带权重的随机选取策略"></a>3.1 带权重的随机选取策略</h3><p>自定义随机选取逻辑，将转化后的连接数组存入 SERVICE_ROUTER_MAP 中</p><p>虽然是随机选取，但是权重值越大，被选取的次数也会越多</p><p>默认初始情况下weight值为100</p><h3 id="3-2-轮询策略"><a href="#3-2-轮询策略" class="headerlink" title="3.2 轮询策略"></a>3.2 轮询策略</h3><p>直接按照添加的先后顺序获取连接，将转化后的连接数组存入 SERVICE_ROUTER_MAP 中</p><h3 id="3-3-获取连接实现"><a href="#3-3-获取连接实现" class="headerlink" title="3.3 获取连接实现"></a>3.3 获取连接实现</h3><p>ChannelFuturePollingRef为实现类，用于从SERVICE_ROUTER_MAP中根据服务提供者名字轮询获取连接</p><p>本质是通过原子类取模运算获取连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">referenceTimes</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">public</span> ChannelFutureWrapper <span class="hljs-title function_">getChannelFutureWrapper</span><span class="hljs-params">(String serviceName)</span> &#123;<br>    ChannelFutureWrapper[] arr = SERVICE_ROUTER_MAP.get(serviceName);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> referenceTimes.getAndIncrement();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (i % arr.length);<br>    <span class="hljs-keyword">return</span> arr[index];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-权重更新事件"><a href="#3-4-权重更新事件" class="headerlink" title="3.4 权重更新事件"></a>3.4 权重更新事件</h3><p>每个服务提供者在注册服务时默认的权重初始值为100。当该值被修改后，触发权重更新事件，修改对应的 SERVICE_ROUTER_MAP</p><p>该更新事件也是通过Watcher与自定义的监听事件机制实现，参考 <code>2.3</code></p><h2 id="4-整合序列化"><a href="#4-整合序列化" class="headerlink" title="4. 整合序列化"></a>4. 整合序列化</h2><p>引入多种序列化策略，由用户自行配置与选择对应的策略</p><ul><li>FastJson</li><li>Hessian</li><li>Kryo</li><li>JDK自带的序列化</li></ul><h3 id="4-1-序列化工厂"><a href="#4-1-序列化工厂" class="headerlink" title="4.1 序列化工厂"></a>4.1 序列化工厂</h3><p>创建序列化工厂接口，定义接口方法：serialize与deserialize（均为范型方法）</p><p>具体的序列化策略去实现该工厂类。</p><ul><li>SerializeFactory<ul><li>FastJsonSerializeFactory</li><li>HessianSerializeFactory</li><li>KryoSerializeFactory</li><li>JdkSerializeFactory</li></ul></li></ul><h3 id="4-2-序列化策略配置"><a href="#4-2-序列化策略配置" class="headerlink" title="4.2 序列化策略配置"></a>4.2 序列化策略配置</h3><p>序列化策略在Server与Client初始化时从配置文件中加载</p><h2 id="5-引入责任链模式"><a href="#5-引入责任链模式" class="headerlink" title="5. 引入责任链模式"></a>5. 引入责任链模式</h2><h3 id="5-1-责任链模式的意义"><a href="#5-1-责任链模式的意义" class="headerlink" title="5.1 责任链模式的意义"></a>5.1 责任链模式的意义</h3><ol><li><p>对客户端请求进行鉴权</p><p>客户端请求的远程接口可能需要进行权限校验（比如与用户隐私相关的数据），服务端必须确认该请求合法才可放行</p></li><li><p>分组管理服务</p><p>同一个服务可能存在多个分支，有的分支为dev代表正在处于开发阶段，有的分支为test代表正在处于测试阶段。</p><p>为了避免客户端调用到正在开发中的服务，在进行远程调用时，需要根据group进行过滤。</p></li><li><p>基于ip直连方式访问服务端</p><p>可能存在两个名字相同但代码逻辑不同的服务。为了避免出现不同的结果，需要根据服务提供方的ip进行过滤</p></li><li><p>调用过程中记录日志信息</p></li></ol><p>传统模式中，客户端需要在发送请求之前，逐个的调用过滤请求的方法；服务端在接受请求之前，也需要逐个调用过滤请求的方法</p><p>这种模式下，代码耦合度高，且扩展性差。</p><p>而采用责任链模式可以带来：</p><ul><li>发送者与接收方的处理对象类之间解耦。</li><li>封装每个处理对象，处理类的最小封装原则。</li><li>可以任意添加处理对象，调整处理对象之间的顺序，提高了维护性和可拓展性，可以根据需求新增处理类，满足开闭原则。</li><li>增强了对象职责指派的灵活性，当流程发生变化的时候，可以动态地改变链内的调动次序可动态的新增或者删除。</li><li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</li><li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li></ul><h3 id="5-2-责任链设计"><a href="#5-2-责任链设计" class="headerlink" title="5.2 责任链设计"></a>5.2 责任链设计</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xl">├── IFilter.java<br>├── IC<span class="hljs-function"><span class="hljs-title">lientFilter</span>.java              -&gt;</span> 继承IFilter接口<br>├── IS<span class="hljs-function"><span class="hljs-title">erverFilter</span>.java-&gt;</span> 继承IFilter接口<br>├── client<br>│   ├── C<span class="hljs-function"><span class="hljs-title">lientFilterChain</span>.java-&gt;</span> 客户端过滤链<br>│   ├── C<span class="hljs-function"><span class="hljs-title">lientLogFilterImpl</span>.java-&gt;</span> 日志过滤器实现类<br>│   ├── D<span class="hljs-function"><span class="hljs-title">irectInvokeFilterImpl</span>.java -&gt;</span> IP过滤器实现类<br>│   └── G<span class="hljs-function"><span class="hljs-title">roupFilterImpl</span>.java-&gt;</span> 分组过滤器实现类<br>└── server<br>    ├── S<span class="hljs-function"><span class="hljs-title">erverFilterChain</span>.java-&gt;</span> 服务器过滤链<br>    ├── S<span class="hljs-function"><span class="hljs-title">erverLogFilterImpl</span>.java-&gt;</span> 日志过滤器实现类<br>    └── S<span class="hljs-function"><span class="hljs-title">erverTokenFilterImpl</span>.java  -&gt;</span> Token安全校验过滤器实现类<br><br></code></pre></td></tr></table></figure><ol><li>首先创建IFilter接口，然后分别创建服务器与客户端对应的接口，继承IFilter接口</li><li>分别创建服务器与客户端过滤链，用于存放过滤器实现类，并遍历过滤器实现类集合，执行过滤方法</li><li>依次实现过滤器实现类</li></ol><h2 id="6-可插拔式组件"><a href="#6-可插拔式组件" class="headerlink" title="6. 可插拔式组件"></a>6. 可插拔式组件</h2><h3 id="6-1-SPI优势"><a href="#6-1-SPI优势" class="headerlink" title="6.1 SPI优势"></a>6.1 SPI优势</h3><p>使用Java SPI机制的优势是实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替换框架组件。</p><p>相比使用提供接口jar包，供第三方服务模块实现接口的方式，SPI的方式使得源框架，不必关心接口的实现类的路径，可以不用通过下面的方式获取接口实现类：</p><ul><li>代码硬编码import 导入实现类</li><li>指定类全路径反射获取：例如在JDBC4.0之前，JDBC中获取数据库驱动类需要通过**Class.forName(“com.mysql.jdbc.Driver”)**，类似语句先动态加载数据库相关的驱动，然后再进行获取连接等的操作</li><li>第三方服务模块把接口实现类实例注册到指定地方，源框架从该处访问实例</li></ul><p>通过SPI的方式，第三方服务模块实现接口后，在第三方的项目代码的META-INF&#x2F;services目录下的配置文件指定实现类的全路径名，源码框架即可找到实现类</p><h3 id="6-2-SPI设计思路"><a href="#6-2-SPI设计思路" class="headerlink" title="6.2 SPI设计思路"></a>6.2 SPI设计思路</h3><p>设计一个SPI加载类，通过当前Class的类加载器去加载META-INF&#x2F;irpc&#x2F;目录底下存在的资源文件</p><p>在需要加载资源时（初始化序列化框架、初始化过滤链、初始化路由策略、初始化注册中心），使用SPI加载类去实现</p><p>从而避免了在代码中通过switch语句以硬编码的方式选择资源</p><h2 id="7-队列与多线程"><a href="#7-队列与多线程" class="headerlink" title="7. 队列与多线程"></a>7. 队列与多线程</h2><h3 id="7-1-串行同步阻塞问题"><a href="#7-1-串行同步阻塞问题" class="headerlink" title="7.1 串行同步阻塞问题"></a>7.1 串行同步阻塞问题</h3><p>NIO线程常见的阻塞情况，一共两大类：</p><ul><li><p>无意识：在ChannelHandler中编写了可能导致NIO线程阻塞的代码，但是用户没有意识到，包括但不限于查询各种数据存储器的操作、第三方服务的远程调用、中间件服务的调用、等待锁等。</p></li><li><p>有意识：用户知道有耗时逻辑需要额外处理，但是在处理过程中翻车了，比如主动切换耗时逻辑到业务线程池或者业务的消息队列做处理时发生阻塞，最典型的有对方是阻塞队列，锁竞争激烈导致耗时，或者投递异步任务给消息队列时异机房的网络耗时，或者任务队列满了导致等待，等等。</p></li></ul><p>服务端接收到消息之后</p><ol><li><p>需要对消息进行解码，使字节序列变为消息对象。</p></li><li><p>将消息对象与上下文传入ServerHandler中进行进一步处理。</p><p>可能某个业务Handler处理流程非常耗时，如查询数据库。为了避免线程被长时间占用，采用异步消费进行处理</p></li></ol><p>客户端通过动态代理层封装RpcInvocation对象并将其放入SEND_QUEUE队列后，需要同步阻塞等待最终处理的响应结果</p><ul><li>可以将此处改为同步与异步两种方式</li></ul><h3 id="7-2-异步设计"><a href="#7-2-异步设计" class="headerlink" title="7.2 异步设计"></a>7.2 异步设计</h3><ol><li><p>对于服务端：</p><p>当请求抵达服务器时，将其直接丢入业务阻塞队列中，然后开辟一个新的线程，从阻塞队列中循环获取Handler请求任务。</p><p>将获取到的任务对象交付于业务线程池进行消费处理。</p></li><li><p>对于客户端：</p><p>在RpcReferenceWrapper中设置一个isAsync字段，用于判断是否为异步。</p><p>若该字段为True，则在动态代理层中，不需要同步阻塞等待响应结果，直接返回null即可。</p></li></ol><h2 id="附：额外记录"><a href="#附：额外记录" class="headerlink" title="附：额外记录"></a>附：额外记录</h2><h3 id="附1-本地公共缓存"><a href="#附1-本地公共缓存" class="headerlink" title="附1 本地公共缓存"></a>附1 本地公共缓存</h3><p>缓存中主要存放客户端订阅信息、服务端注册信息、服务对应的通信连接信息、用于实现异步的队列等通用数据</p><p>分为客户端缓存与服务端缓存： CommonClientCache 与 CommonServerCache</p><h3 id="附2-服务端终止监听事件"><a href="#附2-服务端终止监听事件" class="headerlink" title="附2 服务端终止监听事件"></a>附2 服务端终止监听事件</h3><p>当某一服务提供者下线时，需要将其对应的服务器从Zookeeper注册中心中移除</p><p>监听机制原理相同，参考 <code>2.3</code></p><p>回调方法逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callBack</span><span class="hljs-params">(Object t)</span> &#123;<br>    <span class="hljs-keyword">for</span> (URL url : PROVIDER_URL_SET) &#123;<br>        REGISTRY_SERVICE.unRegister(url);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="附3-可扩展性设计"><a href="#附3-可扩展性设计" class="headerlink" title="附3 可扩展性设计"></a>附3 可扩展性设计</h3><h4 id="冗余类"><a href="#冗余类" class="headerlink" title="冗余类"></a>冗余类</h4><p>该RPC框架中很多地方存在着冗余设计，比如RpcReference、ApplicationShutdownHook、ChannelFuturePollingRef等</p><p>这些类中可能只有一个属性或一个方法，但是单独抽象成一个类，便于之后在此基础上进行扩展。</p><h4 id="事件监听解耦"><a href="#事件监听解耦" class="headerlink" title="事件监听解耦"></a>事件监听解耦</h4><p>Watcher对Zookeeper节点进行监听，当事件发生后，并不是直接处理，而是将该事件交于IRpcListenerLoader，让其选择对应对应的事件监听器去处理，进一步解耦。</p><p>因此，在初始化客户端与服务端的时候，需要将事件监听器注册到IRpcListenerLoader上进行管理。</p><h3 id="附4-包装类设计"><a href="#附4-包装类设计" class="headerlink" title="附4 包装类设计"></a>附4 包装类设计</h3><p>将同一业务逻辑下的属性进行封装，如：</p><ul><li><p>URLChangeWrapper：当节点信息发生变化时，触发监听事件。</p><p>将改变节点的路径与对应的服务名存放到该类中。当Watcher监听到节点信息变化时，便可将信息封装到该类中，发送给IRpcListenerLoader去处理</p></li><li><p>ChannelFutureWrapper：底层网络通信连接类，SERVICE_ROUTER_MAP存储的连接数组就是这个类</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
      <tag>分布式</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统学习笔记</title>
    <link href="/2022/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统学习笔记"><a href="#操作系统学习笔记" class="headerlink" title="操作系统学习笔记"></a>操作系统学习笔记</h1><h2 id="1-操作系统概述"><a href="#1-操作系统概述" class="headerlink" title="1. 操作系统概述"></a>1. 操作系统概述</h2><h3 id="1-1-操作系统概念"><a href="#1-1-操作系统概念" class="headerlink" title="1.1 操作系统概念"></a>1.1 操作系统概念</h3><ol><li>控制和管理整个计算机系统的硬件和软件资源，合理组织调度计算机的工作和资源。<ul><li>处理机管理、存储器管理、文件管理、设备管理</li></ul></li><li>提供给用户其它软件方便的接口与环境<ul><li>命令接口：用户直接使用<ul><li>联机命令接口：终端命令直接交互</li><li>脱机命令接口：将所有需要执行的命令放入文件中批量执行</li></ul></li><li>程序接口：系统调用，用户通过程序间接使用</li><li>GUI图形用户界面</li></ul></li><li>是计算机系统中最基本的系统软件</li></ol><p>操作系统将CPU抽象为进程、磁盘抽象为文件、内存抽象为地址空间，提供给应用程序使用</p><p>操作系统层次架构：硬件之上、应用程序之下，处于中间层</p><p>操作系统主要关注Kernel内核，而非暴露在外部的Shell。</p><ul><li>CPU管理、内存管理、文件系统管理、中断处理与IO设备驱动</li></ul><h3 id="1-2-操作系统特征"><a href="#1-2-操作系统特征" class="headerlink" title="1.2 操作系统特征"></a>1.2 操作系统特征</h3><p>OS Kernel 特征：并发与共享互为存在条件、没有并发与共享则谈不上虚拟与异步</p><ol><li><p>并发：两个或多个事件在同一时间间隔内发生。宏观上同时发生，微观上交替发生。</p><ul><li><p>区分概念 -&gt; 并行：两个或多个事件在同一时刻同时发生。</p></li><li><p>一个单核CPU同一时刻只能执行一个程序 -&gt; 并发</p></li><li><p>尽管目前存在多核CPU，但仍然需要并发性</p></li></ul></li><li><p>共享：系统中的资源可供内存中多个并发执行的进程使用</p><ul><li>互斥共享：一个时间段内仅允许一个进程访问该资源</li><li>同时共享：一个时间段内多个进程“同时”访问该资源（宏观同时、微观交替）</li></ul></li><li><p>虚拟：利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务</p><ul><li>空分复用</li><li>时分复用</li></ul></li><li><p>异步：程序的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进。但只要运行环境相同，OS需要保证最终程序运行的结果也相同。</p></li></ol><h3 id="1-3-操作系统运行机制"><a href="#1-3-操作系统运行机制" class="headerlink" title="1.3 操作系统运行机制"></a>1.3 操作系统运行机制</h3><p>两种指令：</p><ul><li>特权指令：如内存清理指令，不允许用户程序使用</li><li>非特权指令：如普通的运算指令</li></ul><p>两种处理器状态：用程序状态寄存器PSW实现</p><ul><li>用户态：此时CPU只能执行非特权指令</li><li>核心态：两种指令均可执行</li></ul><p>两种程序：</p><ul><li>内核程序：操作系统的内核程序是系统管理者，运行在核心态</li><li>应用程序：普通应用程序运行在用户态</li></ul><h3 id="1-4-操作系统内核"><a href="#1-4-操作系统内核" class="headerlink" title="1.4 操作系统内核"></a>1.4 操作系统内核</h3><p>内核是计算机配置的底层软件，是操作系统最基本、最核心的部分。</p><ul><li>时钟管理：实现计算机计时功能。所有管理工作需要基于计时实现。</li><li>中断处理：负责实现中断机制</li><li>原语：是一种特殊程序，是最接近硬件的部分，这种程序的运行具有原子性。</li><li>为系统资源进行管理的功能：进程管理、存储器管理、设备管理<ul><li>有的系统将此归于操作系统内核，有的系统则不这样做</li></ul></li></ul><h3 id="1-5-操作系统体系结构"><a href="#1-5-操作系统体系结构" class="headerlink" title="1.5 操作系统体系结构"></a>1.5 操作系统体系结构</h3><p>大内核：将操作系统的主要功能模块都作为系统内核，运行在内核态</p><ul><li>优点：高性能</li><li>缺点：内核代码庞大、结构混乱、难以维护</li></ul><p>微内核：只将最基本功能留在内核</p><ul><li>优点：内核功能少、结构清晰、易于维护</li><li>缺点：需要频繁在核心态与用户态之间切换，性能低</li></ul><h3 id="1-6-中断和异常"><a href="#1-6-中断和异常" class="headerlink" title="1.6 中断和异常"></a>1.6 中断和异常</h3><p>中断机制：使得多道程序并发执行，避免了串行执行的低效率。</p><ul><li>当中断发生时，CPU立即进入核心态</li><li>当中断发生后，运行的进程暂停运行，由操作系统内核对中断进行处理</li><li>对于不同的中断信号，进行不同的处理</li></ul><p>发生了中断则意味着需要操作系统介入开展管理工作。由于操作系统的管理工作需要使用特权指令，所以CPU需要从用户态切换为内核态，使操作系统获得计算机的控制权。</p><ul><li>用户态 -&gt; 核心态：中断实现（唯一途径）</li><li>核心态 -&gt; 用户态：执行一个特权指令，通过PSW设置</li></ul><p>中断的分类：</p><ul><li><p>内中断：也称为异常、例外、陷入</p><ul><li>自愿中断：即指令中断</li><li>强迫中断：硬件故障与软件中断</li></ul></li><li><p>外中断：外设请求、人工干预，如IO操作完成后发出的中断信号</p><p>处理过程如下：</p><ol><li>执行完每个指令后，CPU需检查当前是否有外部中断信号</li><li>如果检测到，则需要保护被中断进程的CPU环境（通过PC、PSW、各种寄存器等）</li><li>根据中断信号类型转入相应的中断处理程序</li><li>恢复原进程的CPU环境并退出中断，返回原进程继续向下执行</li></ol></li></ul><h3 id="1-7-系统调用"><a href="#1-7-系统调用" class="headerlink" title="1.7 系统调用"></a>1.7 系统调用</h3><p>操作系统需要向上提供一些简单易用的服务。包括命令接口与程序接口。</p><p>其中，程序接口由一组系统调用组成。</p><ul><li>系统调用可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</li><li>用户进程想要操纵共享资源，只能通过系统调用向操作系统发出请求，由操作系统对各个请求协调管理。这样可以保证系统的稳定性与安全性，防止用户进行非法操作。</li></ul><p>系统调用分类：在核心态下完成</p><ul><li>设备管理、文件管理、进程控制、进程通信、内存管理</li></ul><p>系统调用过程：</p><ol><li>用户态传递系统调用参数</li><li>用户态执行陷入指令：唯一一个只能在用户态执行、不能在内核态执行的指令<ul><li>陷入指令实在用户态执行的，执行陷入指令后立即引发一个内中断，CPU进入内核态</li></ul></li><li>内核态调用相应服务程序</li><li>返回用户程序</li></ol><h2 id="2-进程"><a href="#2-进程" class="headerlink" title="2. 进程"></a>2. 进程</h2><h3 id="2-1-进程概述"><a href="#2-1-进程概述" class="headerlink" title="2.1 进程概述"></a>2.1 进程概述</h3><p>程序段、数据段、PCB三部分组成了<strong>进程实体</strong></p><h4 id="2-1-1-进程定义"><a href="#2-1-1-进程定义" class="headerlink" title="2.1.1 进程定义"></a>2.1.1 进程定义</h4><ul><li>进程是程序的一次执行过程</li><li>进程是一个程序及其数据在处理机上顺序执行时发生的活动</li><li>进程是具有独立功能的程序在数据集合上运行的过程，是系统进行资源分配与调度的一个独立单位</li><li>进程是进程实体的运行过程</li></ul><h4 id="2-1-2-进程组成"><a href="#2-1-2-进程组成" class="headerlink" title="2.1.2 进程组成"></a>2.1.2 进程组成</h4><p>程序段：存放程序代码</p><p>数据段：存放程序运行时使用、产生的运算数据。如全局变量、局部变量等</p><p>PCB：操作系统通过PCB管理进程，其中存储着管理所需要的信息</p><ul><li>进程描述信息：进程标识符PID、用户标识符UID</li><li>进程控制和管理信息：进程当前状态、进程优先级</li><li>资源分配清单：程序段指针、数据段指针、键盘、鼠标</li><li>处理机相关信息：各种寄存器值 -&gt; 便于进程切换</li></ul><h4 id="2-1-3-进程组织"><a href="#2-1-3-进程组织" class="headerlink" title="2.1.3 进程组织"></a>2.1.3 进程组织</h4><ol><li>连接方式：<ul><li>按照进程状态将PCB分为多个队列</li><li>操作系统持有指向各个队列的指针</li></ul></li><li>索引方式：<ul><li>根据进程状态的不同，建立多张索引表</li><li>操作系统持有指向各个索引表的指针</li></ul></li></ol><h4 id="2-1-4-进程特征"><a href="#2-1-4-进程特征" class="headerlink" title="2.1.4 进程特征"></a>2.1.4 进程特征</h4><ul><li>动态性：进程是程序的一次执行过程，动态地产生、变化和消亡</li><li>并发性：内存中有多个进程实体，可并发执行</li><li>独立性：进程是能独立运行、独立获得资源、独立接收调度的基本单位</li><li>异步性：各进程按各自独立、不可预知的速度前进，OS需提供进程同步机制解决异步问题</li><li>结构性：每个进程都配置一个PCB。由程序段、数据段和PCB组成</li></ul><h4 id="2-1-5-进程状态与转换"><a href="#2-1-5-进程状态与转换" class="headerlink" title="2.1.5 进程状态与转换"></a>2.1.5 进程状态与转换</h4><p>三种基本状态：Running、Ready、Waiting&#x2F;Blocked</p><ul><li>Running：占有CPU，并在CPU上运行<ul><li>单核下每一时刻只有一个进程处于运行态，多核下可以有多个</li></ul></li><li>Ready：已具备运行条件，但没有空闲CPU，暂时不能运行</li><li>Waiting&#x2F;Blocked：因等待某一事件暂时不能运行</li></ul><p>另外两种状态：New、Terminated</p><ul><li>New：进程正在被创建，操作系统为其分配资源，初始化PCB</li><li>Terminated：进程正在从系统重撤销，回收资源与撤销PCB</li></ul><p>转换：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221112203658516.png" alt="image-20221112203658516"></p><h4 id="2-1-6-进程控制"><a href="#2-1-6-进程控制" class="headerlink" title="2.1.6 进程控制"></a>2.1.6 进程控制</h4><p>进程控制：对系统中所有进程实施有效的管理。它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><ul><li>创建进程：初始化PCB，分配系统资源</li><li>创建态 -&gt; 就绪态：修改PCB内容，将PCB添加到就绪队列</li><li>就绪态 -&gt; 运行态：恢复进程运行环境，修改PCB内容和相应队列</li><li>运行态 -&gt; 阻塞态：保存进程运行环境，修改PCB内容和相应队列</li><li>阻塞态 -&gt; 就绪态：需要修改PCB内容和相应队列。如果等待的是资源，还需要为进程分配系统资源。</li><li>运行态 -&gt; 就绪态：保存进程运行环境，修改PCB内容和相应队列</li><li>运行态 -&gt; 终止态：回收进程拥有的资源，撤销PCB</li></ul><p>实现进程控制：</p><p>使用原语实现进程控制。原语的特点是在执行期间不允许中断，即原子性操作。</p><p>原语采用“关中断指令”和“开中断指令”实现</p><ol><li>更新PCB中的信息<ul><li>修改进程状态标志</li><li>将当前进程的运行环境保存到PCB</li><li>从PCB中恢复该进程的运行环境</li></ul></li><li>将PCB插入到合适的队列</li><li>分配&#x2F;回收资源</li></ol><h4 id="2-1-7-进程通信"><a href="#2-1-7-进程通信" class="headerlink" title="2.1.7 进程通信"></a>2.1.7 进程通信</h4><p>进程通信：进程之间的信息交换</p><p>各进程拥有的内存地址空间相互独立，为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p><p>为了保证进程间的安全通信：</p><ul><li>共享存储：操作系统开辟一块共享空间供各个进程共享使用，但进程对共享空间的访问必须是互斥的<ul><li>基于数据结构的共享：限定了数据格式大小，低级通信</li><li>基于存储区的共享：自由，高级通信</li></ul></li><li>管道通信：用于连接读写进程的一个共享文件，即在内存中开辟一个固定大小的缓冲区<ul><li>只能采用半双工通信，某一时间段内只能实现单向传输，若要实现双向同时通信，则需要设置两个管道</li><li>各进程需要互斥地访问管道</li><li>数据以字符流形式写入管道，当管道写满时，写进程的write将被阻塞，等待读进程将数据取走。当数据全部被取走后，管道为空，此时读进程的read将被阻塞</li><li>如果没有写满，则不允许读；如果没有读空，则不允许写</li><li>数据一旦被读出，就从管道中被抛弃，这意味着读进程最多只有一个</li></ul></li><li>消息传递：以格式化消息为单位进行数据交换<ul><li>直接通信：消息直接挂到接收进程的消息缓冲队列上</li><li>间接通信：消息需要先发到中间实体信箱中</li></ul></li></ul><h4 id="2-1-8-线程概念和多线程模型"><a href="#2-1-8-线程概念和多线程模型" class="headerlink" title="2.1.8 线程概念和多线程模型"></a>2.1.8 线程概念和多线程模型</h4><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</p><p>引入线程之后，不仅进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程也可以并发处理各种任务。</p><ul><li>资源分配与调度<ul><li>无线程时：进程是资源分配、调度的基本单位</li><li>引入线程后：进程是资源分配的基本单位，线程是调度的基本单位</li></ul></li><li>并发性<ul><li>无线程时：只能进程间并发</li><li>引入线程后：线程之间也可以并发，提升了并发度</li></ul></li><li>系统开销<ul><li>无线程时：切换进程运行环境的开销很大</li><li>引入线程后：同一进程内的线程切换不需要切换进程环境，系统开销很小</li></ul></li></ul><p>线程的实现方式：</p><ul><li>用户级线程：由应用程序通过线程库实现<ul><li>所有线程管理工作都由应用程序负责</li><li>用户级线程中，线程切换在用户态下即可完成，无需操作系统干预</li><li>在用户看来，存在多个线程，但操作系统内核并意识不到县城的存在。即：对用户不透明，对操作系统透明</li></ul></li><li>内核级线程：由操作系统内核完成对线程的管理工作</li></ul><p>多线程模型：内核级线程才是处理机CPU核分配的单位</p><ul><li>多对一模型：多个用户级线程映射到一个内核级线程<ul><li>优点：在用户空间即可完成线程切换，开销小，效率高</li><li>缺点：如果一个用户级离县城阻塞，会导致整个进程均被阻塞</li></ul></li><li>一对一模型：一个用户级线程映射到一个内核级线程<ul><li>优点：并发能力强，不会出现单个线程阻塞造成进程阻塞的问题</li><li>缺点：一个用户进程占用多个内核级线程，线程切换操作由操作系统内核完成，需要切换到核心态，管理成本高，开销大</li></ul></li><li>多对多模型：<ul><li>克服了并发度低的缺点、克服了一个用户进程占用过多内核级线程开销大的缺点</li></ul></li></ul><h3 id="2-2-调度算法"><a href="#2-2-调度算法" class="headerlink" title="2.2 调度算法"></a>2.2 调度算法</h3><h4 id="2-2-1-调度概念"><a href="#2-2-1-调度概念" class="headerlink" title="2.2.1  调度概念"></a>2.2.1  调度概念</h4><p>往往进程数量多于CPU数量。需要按照一定算法从就绪队列中选择一个进程并将CPU资源分配给它。</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221113194506806.png" alt="image-20221113194506806"></p><h4 id="2-2-2-调度算法评价指标"><a href="#2-2-2-调度算法评价指标" class="headerlink" title="2.2.2 调度算法评价指标"></a>2.2.2 调度算法评价指标</h4><p>CPU利用率：忙碌时间 &#x2F; 总时间</p><p>系统吞吐量：完成作业的数量 &#x2F; 总花费时间</p><p>周转时间：从作业被提交到系统开始，到作业完成为止的时间间隔</p><ul><li>包含：<ol><li>作业在外存后备队列上等待作业调度的时间</li><li>进程在就绪队列上等待进程调度的时间</li><li>进程在CPU上执行的时间</li><li>进程等待I&#x2F;O操作完成的时间</li></ol></li></ul><p>带权周转时间：作业周转时间 &#x2F; 作业实际运行的时间 &gt;&#x3D; 1</p><p>等待时间：进程&#x2F;作业处于等待处理机状态时间之和</p><p>响应时间：从用户提交请求到首次产生响应的时间</p><h4 id="2-2-3-先来先服务FCFS"><a href="#2-2-3-先来先服务FCFS" class="headerlink" title="2.2.3 先来先服务FCFS"></a>2.2.3 先来先服务FCFS</h4><p>从公平角度出发，按照作业&#x2F;进程到达的先后顺序进行服务</p><ul><li>用于作业调度时，考虑哪个作业先到达后备队列</li><li>用于进程调度时，考虑哪个进程先到达就绪队列</li></ul><p>非抢占式算法</p><p>优点：公平、算法实现简单，不会导致饥饿</p><p>缺点：有利于长作业，不利于短作业。短作业排在长作业之后需要等待较长时间。</p><h4 id="2-2-4-短作业优先SJF"><a href="#2-2-4-短作业优先SJF" class="headerlink" title="2.2.4 短作业优先SJF"></a>2.2.4 短作业优先SJF</h4><p>追求最少的平均等待时间、最少的平均周转时间、最少的平均带权周转时间</p><p>即最短的作业&#x2F;进程优先得到服务，每次调度时选择当前已到达且运行时间最短的作业&#x2F;进程。为非抢占式的。</p><p>优点：“最短的”平均等待时间、平均周转时间</p><p>缺点：不公平，对短作业有利，对长作业不利，可能产生饥饿现象</p><h5 id="抢占式短作业优先版本SRTN"><a href="#抢占式短作业优先版本SRTN" class="headerlink" title="抢占式短作业优先版本SRTN"></a>抢占式短作业优先版本SRTN</h5><p>最短剩余时间优先算法：如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程就需要重新回到就绪队列。</p><h4 id="2-2-5-高响应比优先算法HRRN"><a href="#2-2-5-高响应比优先算法HRRN" class="headerlink" title="2.2.5 高响应比优先算法HRRN"></a>2.2.5 高响应比优先算法HRRN</h4><p>综合考虑作业&#x2F;进程的等待时间与要求服务的时间</p><p>响应比：等待时间 + 要求服务时间 &#x2F; 要求服务时间</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221113203612255.png" alt="image-20221113203612255"></p><p>以上算法均没有考虑响应时间，不区分任务的紧急程度，对用户而言交互性很差。</p><h4 id="2-2-6-时间片轮转-Round-Robin"><a href="#2-2-6-时间片轮转-Round-Robin" class="headerlink" title="2.2.6 时间片轮转 Round-Robin"></a>2.2.6 时间片轮转 Round-Robin</h4><p>公平地轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p><p>按照各个进程到达就绪队列的顺序，轮流让每个进程执行一个时间片。如进程未在一个时间片内执行完，则剥夺CPU，将进程重新放到就绪队列队尾重新排队。</p><p>适用于进程调度，只要作业放入内存并建立了进程后才分配时间片。</p><p>属于抢占式算法，由时钟发出中断通知CPU时间片已到。</p><ul><li>若时间片设置过大，则时间片轮转调度算法可能退化为先来先服务调度算法，会增大进程响应时间。</li><li>若时间片设置过小，则导致进程切换过于频繁，使实际进程执行时间比例减少</li></ul><p>优点：公平、响应快、适用于分时操作系统、无饥饿</p><p>缺点：高频切换进程带来开销、不区分任务紧急程度</p><h4 id="2-2-7-优先级调度算法"><a href="#2-2-7-优先级调度算法" class="headerlink" title="2.2.7 优先级调度算法"></a>2.2.7 优先级调度算法</h4><p>需要根据任务的紧急程度来决定处理顺序</p><p>调度时选择优先级最高的作业&#x2F;进程</p><p>优点：灵活地调整对各种作业&#x2F;进程的偏好程度</p><p>缺点：可能导致饥饿</p><h4 id="2-2-8-多级反馈队列调度算法"><a href="#2-2-8-多级反馈队列调度算法" class="headerlink" title="2.2.8 多级反馈队列调度算法"></a>2.2.8 多级反馈队列调度算法</h4><ol><li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>新进程到达时先进入第1级队列，按照FCFS原则排队等待分配时间片。<ul><li>若用完时间片进程还未结束，则进程进入下一级队列的队尾</li><li>若此时已经在最下级队列，则重新放到该队列队尾</li></ul></li><li>只有第k级队列为空时，才会为k+1级对头的进程分配时间片</li></ol><p>是一种抢占式算法</p><p>优点：</p><ol><li>对各类型进程相对公平</li><li>每个新到达的进程都可以很快得到响应</li><li>短进程只用较少的时间就可完成</li><li>可灵活地调整各类进程的偏好程度</li></ol><h3 id="2-3-进程同步与互斥"><a href="#2-3-进程同步与互斥" class="headerlink" title="2.3 进程同步与互斥"></a>2.3 进程同步与互斥</h3><p>同步：两个或多个进程协调工作次序</p><p>互斥：一个时间段只允许一个进程访问该资源，互斥访问临界资源</p><ul><li><p>进入区、临界区、退出区、剩余区</p></li><li><p>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</p></li><li><p>忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待</p></li><li><p>有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）</p></li><li><p>让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</p></li></ul><h4 id="2-3-1-进程互斥实现"><a href="#2-3-1-进程互斥实现" class="headerlink" title="2.3.1 进程互斥实现"></a>2.3.1 进程互斥实现</h4><ol><li><p>单标志法：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221114180859131.png" alt="image-20221114180859131"></p><p>缺点：Starvation：If P0 never enters CS, P1 starve</p></li><li><p>双标志先检查法</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221114181642885.png" alt="image-20221114181642885"></p><p>缺点：存在并发问题，违反忙则等待原则。原因是while循环的检查与上锁两个步骤不具有原子性，在这之间可能出现线程切换。</p><p>双标志后检查法：调换了检查与上锁步骤</p><p>缺点：存在并发问题，造成死锁，导致线程均无法进入临界区。</p></li><li><p>Perterson算法 </p><p>孔融让梨思想：先表达自己的意愿，再主动请对方先使用临界区</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221114182353399.png" alt="image-20221114182353399"></p></li></ol><h4 id="2-3-2-信号量机制"><a href="#2-3-2-信号量机制" class="headerlink" title="2.3.2 信号量机制"></a>2.3.2 信号量机制</h4><p>用户进程可以使用操作系统提供的一对原语对信号量进行操作</p><ul><li>信号量：表示系统中某种资源的数量</li><li>一对原语：wait、signal 或 P、V操作</li></ul><p>整型信号量</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221115211728841.png" alt="image-20221115211728841" style="zoom:50%;" /><p>记录型信号量</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221115211815584.png" alt="image-20221115211815584" style="zoom: 50%;" /><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221115211905535.png" alt="image-20221115211905535" style="zoom: 50%;" /><h5 id="信号量实现进程互斥"><a href="#信号量实现进程互斥" class="headerlink" title="信号量实现进程互斥"></a>信号量实现进程互斥</h5><p>对于不同的临界资源需要设置不同的互斥信号量</p><ol><li>划定临界区</li><li>设置互斥信号量为mutex，初始值为1</li><li>在临界区之前执行 P(mutex)</li><li>在临界区之后执行 V(mutex)</li></ol><p>P-V操作必须成对出现</p><h5 id="信号量实现进程同步"><a href="#信号量实现进程同步" class="headerlink" title="信号量实现进程同步"></a>信号量实现进程同步</h5><p>进程并发执行，存在异步性，因此两者交替推进的次序是不确定的。</p><ol><li>设置同步信号量S，初始值为0</li><li>在前操作之后执行 V(S)</li><li>在后操作之前执行 P(S)</li></ol><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221115213153034.png" alt="image-20221115213153034" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>并发</tag>
      
      <tag>线程</tag>
      
      <tag>内存</tag>
      
      <tag>进程</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习笔记</title>
    <link href="/2022/11/11/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/11/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL笔记"><a href="#MySQL笔记" class="headerlink" title="MySQL笔记"></a>MySQL笔记</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h2><h3 id="1-1-事务介绍"><a href="#1-1-事务介绍" class="headerlink" title="1.1 事务介绍"></a>1.1 事务介绍</h3><p>事务是一组操作的集合，是一个不可分割的工作单位。</p><p>事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，这些操作要么同时成功，要么同时失败。</p><ul><li>注意：MySQL事务默认是自动提交的。每执行完一条语句，MySQL会隐式地提交</li></ul><h3 id="1-2-事务操作"><a href="#1-2-事务操作" class="headerlink" title="1.2 事务操作"></a>1.2 事务操作</h3><ol><li><p>通过设置事务提交来控制事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> @<span class="hljs-variable">@autocommit</span>;<br><span class="hljs-keyword">set</span> @<span class="hljs-variable">@autocommit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; # 取消事务手动提交<br></code></pre></td></tr></table></figure></li><li><p>开启事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">start</span> transaction<br></code></pre></td></tr></table></figure></li><li><p>提交与回滚事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">commit</span>; # 提交<br><span class="hljs-keyword">rollback</span>; # 回滚<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-3-事务四大特性"><a href="#1-3-事务四大特性" class="headerlink" title="1.3 事务四大特性"></a>1.3 事务四大特性</h3><p>ACID</p><ul><li>原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性：事务一旦提交或回滚，它对数据库中的数据改变是永久的。</li></ul><h3 id="1-4-并发事务问题"><a href="#1-4-并发事务问题" class="headerlink" title="1.4 并发事务问题"></a>1.4 并发事务问题</h3><ul><li>脏读：一个事务读到另外一个事务还未提交的数据</li><li>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同。原因是另一个事务修改了其中的部分数据。</li><li>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在。原因是另一个事务在此过程中插入了此条数据。</li></ul><h3 id="1-5-事务隔离级别"><a href="#1-5-事务隔离级别" class="headerlink" title="1.5  事务隔离级别"></a>1.5  事务隔离级别</h3><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111224048721.png" alt="image-20221111224048721" style="zoom:50%;" /><ul><li><p>查看事务隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> @<span class="hljs-variable">@transaction</span>_isolation<br></code></pre></td></tr></table></figure></li><li><p>设置事务隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> [<span class="hljs-keyword">GLOBAL</span><span class="hljs-operator">|</span>SESSION] transaction_isolation <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;隔离级别&#x27;</span><br><span class="hljs-comment">-- 隔离级别格式：READ-UNCOMMITTED ，READ-COMMITTED  ，REPEATABLE-READ  ，SERIALIZABLE</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2. 存储引擎"></a>2. 存储引擎</h2><h3 id="2-1-MySQL体系结构"><a href="#2-1-MySQL体系结构" class="headerlink" title="2.1  MySQL体系结构"></a>2.1  MySQL体系结构</h3><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111224506954.png" alt="image-20221111224506954" style="zoom:50%;" /><ol><li>连接层：完成诸如连接处理、授权认证等操作。在该层引入线程池概念，为通过认证安全接入的客户端提供线程</li><li>服务层：完成绝大多数核心功能，如SQL接口，并完成缓存的查询、SQL的分析与优化、部分内置函数的执行。在该层，服务器会解析查询并创建相应的内部解析数，对其完成相应的优化：如表查询顺序、是否利用索引等。</li><li>引擎层：真正负责MySQL中数据的存储和提取。</li><li>存储层：将数据（redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等）存储在文件系统之上</li></ol><h3 id="2-2-存储引擎介绍"><a href="#2-2-存储引擎介绍" class="headerlink" title="2.2 存储引擎介绍"></a>2.2 存储引擎介绍</h3><p>存储引擎是MySQL数据库的核心</p><ul><li>存储引擎是存储数据、建立索引、更新查询数据等技术的实现方式</li><li>存储引擎是基于表的，而不是基于库的。在创建表时，可以为表指定存储引擎</li></ul><h4 id="2-2-1-InnoDB"><a href="#2-2-1-InnoDB" class="headerlink" title="2.2.1 InnoDB"></a>2.2.1 InnoDB</h4><p>InnoDB是一种兼顾高可靠性与高性能的通用存储引擎，在MySQL5.5之后为默认存储引擎</p><p>特点：</p><ol><li>DML操作遵循ACID模型，支持事务</li><li>行级锁，提高并发访问性能</li><li>支持外键FOREIGN KEY约束，保证数据完整性与正确性</li></ol><p>文件：xxx.ibd。xxx为表名，该引擎下每张表都会对应一个表空间文件：存储该表的表结构、数据与索引</p><p>逻辑存储结构</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111225328390.png" alt="image-20221111225328390" style="zoom:50%;" /><ul><li>表空间：InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是其表空间文件，其中包含多个Segment段</li><li>段：表空间是由各个段组成的：数据段、索引段、回滚段等。一个段中包含多个区</li><li>区：区是表空间的单元结构，每个区大小为1M。默认情况下，页大小为16K，即一个区中一共有64个连续的页</li><li>页：页是组成区的最小单元，页也是InnoDB存储引擎磁盘管理的最小单元，每个页大小默认为16KB</li><li>行：InnoDB存储引擎是面向行的，数据是按行存放</li></ul><h3 id="2-3-存储引擎对比"><a href="#2-3-存储引擎对比" class="headerlink" title="2.3 存储引擎对比"></a>2.3 存储引擎对比</h3><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111225819681.png" alt="image-20221111225819681" style="zoom:50%;" /><p>InnoDB与MyISAM区别：</p><ul><li>InnoDB支持事务；而MyISAM不支持</li><li>InnoDB支持行锁与表锁；而MyISAM只支持表锁，不支持行锁</li><li>InnoDB支持外键；而MyISAM不支持</li></ul><h2 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h2><h3 id="3-1-索引概述"><a href="#3-1-索引概述" class="headerlink" title="3.1 索引概述"></a>3.1 索引概述</h3><p>索引是一种帮助MySQL高效获取数据的数据结构。除数据库本身存储的数据，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构通过某种方式引用指向数据，从而实现高级查找算法。</p><p>优点：</p><ol><li>提高数据检索的效率，降低数据库IO成本</li><li>通过索引对数据进行排序，降低数据排序成本，降低CPU消耗</li></ol><p>缺点：</p><ol><li>索引也需要占据空间（不过磁盘不值钱）</li><li>索引大大提升了查询效率，但同时也降低了更新表的速度</li></ol><h3 id="3-2-索引结构"><a href="#3-2-索引结构" class="headerlink" title="3.2 索引结构"></a>3.2 索引结构</h3><h4 id="3-2-1-二叉搜索树"><a href="#3-2-1-二叉搜索树" class="headerlink" title="3.2.1 二叉搜索树"></a>3.2.1 二叉搜索树</h4><p>二叉搜索树虽然能提升查询效率，但是存在极端情况：顺序插入时会形成链表</p><p>此外：大数据量的情况下，二叉树的层级较深，检索速度慢</p><p>若采用红黑树，虽然解决了极端情况出现的链表问题，但仍然存在第二点问题。</p><h4 id="3-2-2-B-Tree"><a href="#3-2-2-B-Tree" class="headerlink" title="3.2.2 B-Tree"></a>3.2.2 B-Tree</h4><p>B树是一种多路平衡查找树，相比于二叉树，B树每个节点可以有多个分支。</p><p>以一颗最大度数为5的B-Tree为例，每个节点最多可以存储4个key，5个指针</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111230857511.png" alt="image-20221111230857511"></p><h4 id="3-2-3-B-Tree"><a href="#3-2-3-B-Tree" class="headerlink" title="3.2.3 B+Tree"></a>3.2.3 B+Tree</h4><p>B+Tree是B-Tree的变体。其只有叶子节点存放具体的数据。</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111231037171.png" alt="image-20221111231037171"></p><p>B+Tree与B-Tree的对比：</p><ol><li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ol><h4 id="3-2-4-Hash"><a href="#3-2-4-Hash" class="headerlink" title="3.2.4 Hash"></a>3.2.4 Hash</h4><p>MySQL中除了支持B+Tree索引，还支持Hash索引</p><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O(1)）。</p><p>但是哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后<code>HashMap</code>为了减少链表过长的时候搜索时间过长引入了红黑树。</p><p>优点：Hash索引对于单条数据查询效率很高</p><p>缺点：Hash索引只能用于对等比较，不支持范围查询；无法利用索引完成排序操作</p><h3 id="3-3-索引分类"><a href="#3-3-索引分类" class="headerlink" title="3.3 索引分类"></a>3.3 索引分类</h3><p>在MySQL数据库中，索引主要分为：主键索引、唯一索引、常规索引、全文索引</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111232503785.png" alt="image-20221111232503785" style="zoom:50%;" /><p>根据索引的存储形式，又可分为：聚集索引、二级索引</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111232559549.png" alt="image-20221111232559549" style="zoom:50%;" /><p>聚集索引选取规则：</p><ol><li>如果存在主键，则主键索引就是聚集索引</li><li>如果不存在主键，则使用第一个唯一索引作为聚集索引</li><li>如果表没有主键或没有唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li></ol><ul><li>聚集索引的叶子节点下存放的为这一行的数据</li><li>二级索引的叶子节点下存放的为该字段对应的主键值</li></ul><p>执行 <code>select * from user when name = &#39;Arm&#39;</code>，其中name为索引</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111232932026.png" alt="image-20221111232932026" style="zoom: 33%;" /><p>具体过程为：</p><ol><li>由于是根据name字段进行查询，所以先根据name&#x3D;’Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</li><li>由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。 </li><li>最终拿到这一行的数据，直接返回即可。</li></ol><p>回表查询：先到二级索引中查找数据，找到主键值之后，再到聚集索引中根据主键值获取数据。</p><h3 id="3-4-索引语法"><a href="#3-4-索引语法" class="headerlink" title="3.4 索引语法"></a>3.4 索引语法</h3><ol><li><p>创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [ <span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT ] INDEX index_name <span class="hljs-keyword">ON</span> table_name ( index_col_name,... );<br></code></pre></td></tr></table></figure></li><li><p>查看索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> table_name;<br></code></pre></td></tr></table></figure></li><li><p>删除索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-5-SQL性能分析"><a href="#3-5-SQL性能分析" class="headerlink" title="3.5 SQL性能分析"></a>3.5 SQL性能分析</h3><h4 id="3-5-1-SQL执行频率"><a href="#3-5-1-SQL执行频率" class="headerlink" title="3.5.1 SQL执行频率"></a>3.5.1 SQL执行频率</h4><p>通过如下命令，可以查看当前数据库的 INSERT、UPDATE、DELETE、SELECT的访问频次：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- show [session|global] status</span><br><span class="hljs-comment">-- session 是查看当前会话 </span><br><span class="hljs-comment">-- global 是查询全局数据 </span><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Com_______&#x27;</span>;<br></code></pre></td></tr></table></figure><p>通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 </p><ul><li>如果是以增删改为主，我们可以考虑不对其进行索引的优化。</li><li>如果是以查询为主，那么就要考虑对数据库的索引进行优化了。</li></ul><h4 id="3-5-2-慢查询日志"><a href="#3-5-2-慢查询日志" class="headerlink" title="3.5.2 慢查询日志"></a>3.5.2 慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p><p>MySQL的慢查询日志默认没有开启，查看系统变量 slow_query_log。</p><p>如果要开启慢查询日志，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 开启MySQL慢日志查询开关 </span><br><span class="hljs-attr">slow_query_log</span>=<span class="hljs-number">1</span> <br><span class="hljs-comment"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志 </span><br><span class="hljs-attr">long_query_time</span>=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="3-5-3-profile详情"><a href="#3-5-3-profile详情" class="headerlink" title="3.5.3 profile详情"></a>3.5.3 profile详情</h4><p>通过 <code>show profiles</code> 能够查询出每一条命令的执行时间</p><p>通过set语句在session&#x2F;global级别开启profiling：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> profiling <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>执行完一系列业务SQL操作后，通过如下命令查询执行耗时</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查看每一条SQL的耗时基本情况 </span><br><span class="hljs-keyword">show</span> profiles; <br><span class="hljs-comment">-- 查看指定query_id的SQL语句各个阶段的耗时情况 </span><br><span class="hljs-keyword">show</span> profile <span class="hljs-keyword">for</span> query query_id; <br><span class="hljs-comment">-- 查看指定query_id的SQL语句CPU的使用情况 </span><br><span class="hljs-keyword">show</span> profile cpu <span class="hljs-keyword">for</span> query query_id;<br></code></pre></td></tr></table></figure><h4 id="3-5-4-explain"><a href="#3-5-4-explain" class="headerlink" title="3.5.4 explain"></a>3.5.4 explain</h4><p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 直接在select语句之前加上关键字 </span><br>explain <span class="hljs-operator">/</span> <span class="hljs-keyword">desc</span> EXPLAIN <span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 ;<br></code></pre></td></tr></table></figure><p>Explain 执行计划中各个字段的含义: </p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111234650646.png" alt="image-20221111234650646" style="zoom:50%;" /><h3 id="3-6-索引使用规则"><a href="#3-6-索引使用规则" class="headerlink" title="3.6 索引使用规则"></a>3.6 索引使用规则</h3><h2 id="4-SQL优化"><a href="#4-SQL优化" class="headerlink" title="4. SQL优化"></a>4. SQL优化</h2><h3 id="4-1-插入数据"><a href="#4-1-插入数据" class="headerlink" title="4.1 插入数据"></a>4.1 插入数据</h3><ul><li><p>insert优化</p><ul><li>执行批量插入：500 ~ 1000条</li><li>手动开启与提交事务</li><li>主键顺序插入</li></ul></li><li><p>大批量插入数据</p><ul><li>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时需要MySQL提供的load指令</li></ul><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221112163647221.png" alt="image-20221112163647221"></p><p>使用如下指令，将数据脚本文件中的数据加载到表结构中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 客户端连接服务端时，加上参数 -–local-infile </span><br>mysql –<span class="hljs-operator">-</span><span class="hljs-keyword">local</span><span class="hljs-operator">-</span>infile <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p <br><span class="hljs-comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关 </span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> local_infile <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <br><span class="hljs-comment">-- 执行load指令将准备好的数据，加载到表结构中 </span><br>load data <span class="hljs-keyword">local</span> infile <span class="hljs-string">&#x27;/root/sql1.log&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> tb_user fields <br>terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span> lines terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\n&#x27;</span> ;<br></code></pre></td></tr></table></figure><p>开启local_infile之后，在任意一个数据库中创建一张表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tb_user` ( <br>    `id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT, <br>    `username` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <br>    `password` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <br>    `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, `birthday` <span class="hljs-type">DATE</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, <br>    `sex` <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, <br>    <span class="hljs-keyword">PRIMARY</span> KEY (`id`), <br>    <span class="hljs-keyword">UNIQUE</span> KEY `unique_user_username` (`username`) <br>) ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 ;<br></code></pre></td></tr></table></figure><p>然后在数据库上加载对应的文件</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">load</span> data <span class="hljs-keyword">local</span> infile <span class="hljs-string">&#x27;/Users/xxx/Documents/load_user_100w_sort.sql&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> tb_user fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span> lines terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221112164957718.png" alt="image-20221112164957718"></p><p>从中可见性能提升了很多</p></li></ul><h3 id="4-2-主键优化"><a href="#4-2-主键优化" class="headerlink" title="4.2 主键优化"></a>4.2 主键优化</h3><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221112165939874.png" alt="image-20221112165939874" style="zoom:50%;" /><p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储到下一个页中，页与页之间会通过指针连接。</p><ul><li><p>页分裂</p><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。</p><ul><li>主键顺序插入时，当前页满了之后，会插入到下一页。页与页之间用指针相连。</li><li>主键乱序插入时，当插入的主键id在中间且当前页已经写满时，会将当前页的后一半数据移动到新的一页，然后再插入该主键id，此时需要重新设置页与页之间的链表指针 &#x3D;&gt; 页分裂</li></ul></li><li><p>页合并</p><ul><li>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</li><li>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</li></ul></li></ul><p>索引设计原则：</p><ol><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改。</li></ol><h3 id="4-3-order-by优化"><a href="#4-3-order-by优化" class="headerlink" title="4.3 order by优化"></a>4.3 order by优化</h3><p>MySQL的排序，有两种方式：</p><ul><li>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sortbuffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</li><li>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</li></ul><p>在优化排序操作时，尽量采用Using Index</p><p>order by优化原则</p><ol><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size，默认256K</li></ol><h3 id="4-4-group-by优化"><a href="#4-4-group-by优化" class="headerlink" title="4.4 group by优化"></a>4.4 group by优化</h3><p>在分组操作中，我们需要通过以下两点进行优化，以提升性能：</p><ol><li>在分组操作时，可以通过索引来提高效率。</li><li>分组操作时，索引的使用也是满足最左前缀法则的。</li></ol><h3 id="4-5-limit优化"><a href="#4-5-limit优化" class="headerlink" title="4.5 limit优化"></a>4.5 limit优化</h3><p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_sku t , (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_sku <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">2000000</span>,<span class="hljs-number">10</span>) a <span class="hljs-keyword">where</span> t.id <span class="hljs-operator">=</span> a.id;<br></code></pre></td></tr></table></figure><h3 id="4-6-count优化"><a href="#4-6-count优化" class="headerlink" title="4.6 count优化"></a>4.6 count优化</h3><p>当表的数据量很大时，对表执行count操作是非常耗时的</p><ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。</li><li>InnoDB执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li><li>如果想大幅度提升InnoDB表的count效率，可以借助Redis手动统计计数</li></ul><p>count用法：count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221112200822172.png" alt="image-20221112200822172" style="zoom:50%;" /><h3 id="4-7-update优化"><a href="#4-7-update优化" class="headerlink" title="4.7 update优化"></a>4.7 update优化</h3><p>在采用update语句进行更新数据操作时，最好将索引作为查询数据的条件。这是因为InnoDB的行锁是针对索引加锁，而不是针对记录加锁。如果索引失效，则行锁会自动升级为表锁。</p>]]></content>
    
    
    <categories>
      
      <category>数据库及缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事务</tag>
      
      <tag>MySQL</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis笔记:实战篇</title>
    <link href="/2022/11/05/Redis%E7%AC%94%E8%AE%B0-%E5%AE%9E%E6%88%98%E7%AF%87/"/>
    <url>/2022/11/05/Redis%E7%AC%94%E8%AE%B0-%E5%AE%9E%E6%88%98%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis实战篇"><a href="#Redis实战篇" class="headerlink" title="Redis实战篇"></a>Redis实战篇</h1><h2 id="1-短信登录"><a href="#1-短信登录" class="headerlink" title="1. 短信登录"></a>1. 短信登录</h2><p>项目整体架构如下：</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221025174859439.png" alt="image-20221025174859439" style="zoom: 33%;" /><p>通过Nginx将前端请求转发到后端服务器中，Redis与MySQL作为数据库。</p><h3 id="1-1-导入项目"><a href="#1-1-导入项目" class="headerlink" title="1.1 导入项目"></a>1.1 导入项目</h3><ol><li><p>创建hmdp数据库，导入SQL文件 <code>hmdp.sql</code></p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221025171044276.png" alt="image-20221025171044276"></p><p>表介绍：</p><ul><li>tb_user：用户表</li><li>tb_user_info：用户详情表</li><li>tb_shop：商户信息表</li><li>tb_shop_type：商户类型表</li><li>tb_blog：用户日记表（达人探店日记）</li><li>tb_follow：用户关注表</li><li>tb_voucher：优惠券表</li><li>tb_voucher_order：优惠券订单表</li></ul></li><li><p>导入后端项目：<code>hm-dianping</code></p><p>将application.yaml文件中MySQL与Redis配置修改为自己的</p><p>之后启动SpringBoot项目，并访问 <code>http://localhost:8081/shop-type/list</code>，显示出数据则说明配置成功！</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221025172132464.png" alt="image-20221025172132464"></p></li><li><p>导入前端项目：配置nginx</p><p>由于我使用的是Mac M1，用homebrew安装的nginx，分享一下我的配置方法</p><ol><li><p>将 <code>/opt/homebrew/etc/nginx/nginx.conf</code> 修改为老师提供的nginx配置文件（修改前记得备份之前的配置文件）</p></li><li><p>将 <code>/opt/homebrew/var/www</code> 下的文件全部替换为老师提供的nginx包下的html下的文件</p></li><li><p>采用如下命令更新配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">nginx -c <span class="hljs-regexp">/opt/</span>homebrew<span class="hljs-regexp">/etc/</span>nginx/nginx.conf<br></code></pre></td></tr></table></figure></li><li><p>采用如下命令重启nginx</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nginx -s reload</span><br></code></pre></td></tr></table></figure></li><li><p>访问 <code>localhost:8080</code>，即可成功</p></li></ol></li></ol><h3 id="1-2-基于Session的短信登录"><a href="#1-2-基于Session的短信登录" class="headerlink" title="1.2 基于Session的短信登录"></a>1.2 基于Session的短信登录</h3><h4 id="1-2-1-流程分析"><a href="#1-2-1-流程分析" class="headerlink" title="1.2.1 流程分析"></a>1.2.1 流程分析</h4><h5 id="服务端发送短信验证码流程"><a href="#服务端发送短信验证码流程" class="headerlink" title="服务端发送短信验证码流程"></a>服务端发送短信验证码流程</h5><ol><li>服务端接收到手机号，校验手机号是否符合规则，符合则进入下一步</li><li>生成验证码，并将验证码保存到Session中</li><li>发送验证码</li></ol><h5 id="短信验证码登录与注册流程"><a href="#短信验证码登录与注册流程" class="headerlink" title="短信验证码登录与注册流程"></a>短信验证码登录与注册流程</h5><ol><li>用户提交手机号与验证码，服务端校验验证码，若正确，则进入下一步</li><li>根据手机号查询信息<ul><li>若用户存在，登陆成功，保存用户到Session</li><li>若用户不存在，用户为新用户，则将其保存到数据库中，保存用户到Session</li></ul></li></ol><h5 id="校验登录状态"><a href="#校验登录状态" class="headerlink" title="校验登录状态"></a>校验登录状态</h5><ol><li>用户访问网站，携带Cookie，通过Cookie中的SessionID获取对应的Session，从Session中获取用户信息，判断信息是否有效<ul><li>若信息有效，用户存在，则将信息保存到ThreadLocal中，便于后续使用</li><li>若信息无效，用户不存在，结束</li></ul></li></ol><h4 id="1-2-2-功能实现"><a href="#1-2-2-功能实现" class="headerlink" title="1.2.2 功能实现"></a>1.2.2 功能实现</h4><h5 id="发送短信验证码"><a href="#发送短信验证码" class="headerlink" title="发送短信验证码"></a>发送短信验证码</h5><ol><li><p>更改controller包下UserController中的sendCode方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;code&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;phone&quot;)</span> String phone, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// TODO 发送短信验证码并保存验证码</span><br>    <span class="hljs-keyword">return</span> userService.sendCode(phone, session);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在UserServiceImpl中实现该方法</p><p>注意：验证码的发送用log输出日志模拟一下即可，表示发送成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// 1.校验手机号</span><br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>        <span class="hljs-comment">// 2.如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.符合，生成验证码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<br>    <span class="hljs-comment">// 4.保存验证码到Session</span><br>    session.setAttribute(<span class="hljs-string">&quot;code&quot;</span>, code);<br>    <span class="hljs-comment">// 5.发送验证码</span><br>    log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="登录与注册"><a href="#登录与注册" class="headerlink" title="登录与注册"></a>登录与注册</h5><ol><li><p>更改Controller包下UserController中的login方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> LoginFormDTO loginForm, HttpSession session)</span>&#123;<br>    <span class="hljs-comment">// TODO 实现登录功能</span><br>    <span class="hljs-keyword">return</span> userService.login(loginForm, session);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在UserService中实现该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// 1.校验手机号</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 2.校验验证码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> (String) session.getAttribute(<span class="hljs-string">&quot;code&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>    <span class="hljs-keyword">if</span> (cacheCode == <span class="hljs-literal">null</span> || !cacheCode.equals(code)) &#123;<br>        <span class="hljs-comment">// 3.不一致报错</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4.一致，根据手机号查询用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br>    <span class="hljs-comment">// 5.判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 6.不存在，创建用户并保存</span><br>        user = createUserWithPhone(phone);<br>    &#125;<br>    <span class="hljs-comment">// 7.保存用户信息到Session</span><br>    session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br><br><span class="hljs-keyword">private</span> User <span class="hljs-title function_">createUserWithPhone</span><span class="hljs-params">(String phone)</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setPhone(phone);<br>    user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(<span class="hljs-number">10</span>));<br>    save(user);<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="登录校验拦截器"><a href="#登录校验拦截器" class="headerlink" title="登录校验拦截器"></a>登录校验拦截器</h5><p>情景分析：</p><p>登录完成之后，一些请求需要校验用户的登录状态，然后才能允许执行进一步的操作（比如查看订单等）</p><p>如果在每个请求的方法中都添加校验逻辑，会增加很多冗余代码。</p><p>因此，我们采用登录校验拦截器，在请求到达每个Controller之前，对其做校验，获取用户信息。</p><p>为了避免线程安全问题，将用户信息保存到ThreadLocal中，这样每个请求对应着自己的用户信息，互不干扰。</p><ol><li><p>在utils包下创建LoginInterceptor</p><p>UserHolder其实是一个工具类，用于将用户信息保存到ThreadLocal以及从ThreadLocal中取用户信息</p><p>移除用户是为了防止内存泄露</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.获取session</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-comment">// 2.获取session中的用户</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-comment">// 3.判断用户是否存在</span><br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 4.不存在则拦截</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 5.存在则保存用户信息到ThreadLocal</span><br>        UserHolder.saveUser((User) user);<br>        <span class="hljs-comment">// 6.放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 移除用户</span><br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在config下创建MVCConfig类，将拦截器进行配置，对于一些不必要拦截的路径进行排除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MVCConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>())<br>                .excludePathPatterns(<span class="hljs-string">&quot;/user/code&quot;</span>, <span class="hljs-string">&quot;/user/login&quot;</span>, <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                        <span class="hljs-string">&quot;/shop/**&quot;</span>, <span class="hljs-string">&quot;/shop-type/**&quot;</span>, <span class="hljs-string">&quot;/voucher/**&quot;</span>, <span class="hljs-string">&quot;/upload/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>更改UserController中的me方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/me&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">me</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>    <span class="hljs-keyword">return</span> Result.ok(user);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>需要注意的是：UserHolder中将UserDTO改为User（老师视频中的代码与提供的代码有些出入）</p><h5 id="隐藏敏感信息"><a href="#隐藏敏感信息" class="headerlink" title="隐藏敏感信息"></a>隐藏敏感信息</h5><p>为了隐藏用户敏感信息，将用户信息存入Session时，需要将User转为UserDTO对象。修改流程如下：</p><ol><li><p>将UserServiceImpl中的login方法存入Session的代码更改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 7.保存用户信息到Session</span><br>session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>, BeanUtil.copyProperties(user, UserDTO.class));<br></code></pre></td></tr></table></figure></li><li><p>更改LoginInterceptor中保存用户信息到ThreadLocal的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 5.存在则保存用户信息到ThreadLocal</span><br>UserHolder.saveUser((UserDTO) user);<br></code></pre></td></tr></table></figure></li><li><p>最后将UserHolder工具类中的User全部更改为UserDTO</p></li></ol><p>更改之后重启SpringBoot，进行登录测试，此时对应的me请求返回结果就没有敏感信息了</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221025210030885.png" alt="image-20221025210030885" style="zoom: 50%;" /><h4 id="1-2-3-集群Session共享问题"><a href="#1-2-3-集群Session共享问题" class="headerlink" title="1.2.3 集群Session共享问题"></a>1.2.3 集群Session共享问题</h4><p>session共享问题：多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题。</p><p>即使采用Tomcat之间拷贝Session机制，也存在拷贝时间的延迟以及内存占用问题</p><p>Session的替代方案必须满足：数据共享、内存存储、key-value结构</p><h3 id="1-3-基于Redis的短信登录"><a href="#1-3-基于Redis的短信登录" class="headerlink" title="1.3 基于Redis的短信登录"></a>1.3 基于Redis的短信登录</h3><h4 id="1-3-1-流程分析"><a href="#1-3-1-流程分析" class="headerlink" title="1.3.1 流程分析"></a>1.3.1 流程分析</h4><h5 id="服务端发送短信验证码流程-1"><a href="#服务端发送短信验证码流程-1" class="headerlink" title="服务端发送短信验证码流程"></a>服务端发送短信验证码流程</h5><p>与Session的流程基本一致</p><ol><li>服务端接收到手机号，校验手机号是否符合规则，符合则进入下一步</li><li>生成验证码，并将验证码保存到Redis中<ul><li>采用手机号作为key：<code>phone:xxxxx</code>，验证码作为value，值类型为string</li><li>设置一定时间的有效期</li></ul></li><li>发送验证码</li></ol><h5 id="短信验证码登录与注册流程-1"><a href="#短信验证码登录与注册流程-1" class="headerlink" title="短信验证码登录与注册流程"></a>短信验证码登录与注册流程</h5><ol><li>用户提交手机号与验证码，服务端校验验证码，若正确，则进入下一步</li><li>根据手机号查询信息<ul><li>若用户存在，登陆成功，保存用户到Redis</li><li>若用户不存在，用户为新用户，则将其保存到数据库中，保存用户到Redis</li><li>Redis中的用户信息：采用Token作为key，用户信息作为value，采用Hash结构存储<ul><li>Token是放于请求头中的，为了确保用户隐私与值唯一性，该Token值需要以一定规则生成</li><li>设置一定时间的有效期</li></ul></li></ul></li><li>将Token返回给前端</li></ol><h5 id="校验登录状态-1"><a href="#校验登录状态-1" class="headerlink" title="校验登录状态"></a>校验登录状态</h5><ol><li>用户访问网站，发起请求中携带着Token，通过Token从Redis中获取用户信息，判断信息是否有效<ul><li>若信息有效，用户存在，则将信息保存到ThreadLocal中，便于后续使用，并更新Token的有效期</li><li>若信息无效，用户不存在</li></ul></li></ol><h4 id="1-3-2-功能实现"><a href="#1-3-2-功能实现" class="headerlink" title="1.3.2 功能实现"></a>1.3.2 功能实现</h4><h5 id="发送短信验证码-1"><a href="#发送短信验证码-1" class="headerlink" title="发送短信验证码"></a>发送短信验证码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// 1.校验手机号</span><br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>        <span class="hljs-comment">// 2.如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.符合，生成验证码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<br>    <span class="hljs-comment">// 4.保存验证码到Redis</span><br>    template.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-comment">// 5.发送验证码</span><br>    log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="登录与注册-1"><a href="#登录与注册-1" class="headerlink" title="登录与注册"></a>登录与注册</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>        <span class="hljs-comment">// 1.校验手机号</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>        <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 2.校验验证码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> template.opsForValue().get(LOGIN_CODE_KEY + phone);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>        <span class="hljs-keyword">if</span> (cacheCode == <span class="hljs-literal">null</span> || !cacheCode.equals(code)) &#123;<br>            <span class="hljs-comment">// 3.不一致报错</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 4.一致，根据手机号查询用户</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br>        <span class="hljs-comment">// 5.判断用户是否存在</span><br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 6.不存在，创建用户并保存</span><br>            user = createUserWithPhone(phone);<br>        &#125;<br>        <span class="hljs-comment">// 7.保存用户信息到Redis</span><br>        <span class="hljs-comment">// 7.1.生成Token</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>        <span class="hljs-comment">// 7.2.将User转为Hash存储</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);<br>        Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(),<br>                CopyOptions.create().setIgnoreNullValue(<span class="hljs-literal">true</span>).setFieldValueEditor((name, value) -&gt; value.toString()));<br>        <span class="hljs-comment">// 7.3.存储</span><br>        template.opsForHash().putAll(LOGIN_USER_KEY + token, userMap);<br>        <span class="hljs-comment">// 7.4.设置有效期</span><br>        template.expire(LOGIN_USER_KEY + token, LOGIN_USER_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-comment">// 8.返回Token</span><br>        <span class="hljs-keyword">return</span> Result.ok(token);<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221025215121245.png" alt="image-20221025215121245"></p><p>上述报错发生的原因是UserDTO中的id字段为Long类型，而Redis存储时无法使用Long类型数据</p><p>为了防止发生上述报错，可以看到7.2步骤中将User转为Hash存储时，通过BeanUtil方法，将所有字段的均转为了String类型</p><h5 id="登录校验拦截器-1"><a href="#登录校验拦截器-1" class="headerlink" title="登录校验拦截器"></a>登录校验拦截器</h5><p>只需更改preHandle中的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1.获取请求头中的Token</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>    <span class="hljs-keyword">if</span> (StrUtil.isBlank(token)) &#123;<br>        response.setStatus(<span class="hljs-number">401</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2.获取Redis中的用户</span><br>    Map&lt;Object, Object&gt; userMap = template.opsForHash().entries(LOGIN_USER_KEY + token);<br><br>    <span class="hljs-comment">// 3.判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (userMap.isEmpty()) &#123;<br>        <span class="hljs-comment">// 4.不存在则拦截</span><br>        response.setStatus(<span class="hljs-number">401</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 5.将查询到的Hash数据转为UserDTO对象</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(), <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 6.存在则保存用户信息到ThreadLocal</span><br>    UserHolder.saveUser((UserDTO) userDTO);<br>    <span class="hljs-comment">// 7.刷新Token有效期</span><br>    template.expire(LOGIN_USER_KEY + token, LOGIN_USER_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-comment">// 8.放行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-3-拦截器优化"><a href="#1-3-3-拦截器优化" class="headerlink" title="1.3.3 拦截器优化"></a>1.3.3 拦截器优化</h4><p>情景分析：</p><p>通过登录校验拦截器进行刷新Token的有效时间可能会存在这样一个问题：</p><ul><li>用户的请求并没有通过登录校验拦截器（如访问主页等无需校验的操作），但是用户仍然一致活跃在网页中。如果超过指定时间Token过期后，用户需要重新进行登录，这样会造成不好的用户体验。</li></ul><p>解决方案：</p><p>将之前的登录校验拦截器拆分为两个拦截器，</p><p>第一个拦截器用于：获取Token，通过Redis查询用户，保存到ThreadLocal，刷新Token有效期</p><p>第二拦截器用于：查询ThreadLocal，判断是否存在用户，存在则放行，不存在则拦截</p><ol><li><p>复制之前的 LoginInterceptor，命名为 RefreshTokenInterceptor，对preHandle方法做修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1.获取请求头中的Token</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>    <span class="hljs-keyword">if</span> (StrUtil.isBlank(token)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2.获取Redis中的用户</span><br>    Map&lt;Object, Object&gt; userMap = template.opsForHash().entries(LOGIN_USER_KEY + token);<br>    <span class="hljs-comment">// 3.判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (userMap.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 4.将查询到的Hash数据转为UserDTO对象</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(), <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 5.存在则保存用户信息到ThreadLocal</span><br>    UserHolder.saveUser((UserDTO) userDTO);<br>    <span class="hljs-comment">// 6.刷新Token有效期</span><br>    template.expire(LOGIN_USER_KEY + token, LOGIN_USER_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-comment">// 7.放行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改LoginInterceptor中的preHandle方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 判断是否需要拦截</span><br>    <span class="hljs-keyword">if</span> (UserHolder.getUser() == <span class="hljs-literal">null</span>) &#123;<br>        response.setStatus(<span class="hljs-number">401</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改MVCConfig类，注意两个拦截器要设置先后顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>    registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>())<br>        .excludePathPatterns(<span class="hljs-string">&quot;/user/code&quot;</span>, <span class="hljs-string">&quot;/user/login&quot;</span>, <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                             <span class="hljs-string">&quot;/shop/**&quot;</span>, <span class="hljs-string">&quot;/shop-type/**&quot;</span>, <span class="hljs-string">&quot;/voucher/**&quot;</span>, <span class="hljs-string">&quot;/upload/**&quot;</span>)<br>        .order(<span class="hljs-number">1</span>);<br>    registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RefreshTokenInterceptor</span>(template)).order(<span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-商户查询缓存"><a href="#2-商户查询缓存" class="headerlink" title="2. 商户查询缓存"></a>2. 商户查询缓存</h2><h3 id="2-1-缓存"><a href="#2-1-缓存" class="headerlink" title="2.1 缓存"></a>2.1 缓存</h3><p>缓存为数据交换的缓冲区（cache），是数据存储的临时地方，读写性能较高</p><p>缓存作用：</p><ol><li>降低后端负载</li><li>提高读写效率，降低响应时间</li></ol><p>缓存成本：</p><ol><li>数据一致性成本：MySQL与Redis数据一致</li><li>代码维护成本</li><li>运维成本</li></ol><h3 id="2-2-添加商户缓存"><a href="#2-2-添加商户缓存" class="headerlink" title="2.2 添加商户缓存"></a>2.2 添加商户缓存</h3><p>添加缓存之前：客户端直接请求数据库，数据库查询得到数据后返回给客户端</p><p>添加缓存之后：客户端先请求Redis，Redis若有对应数据，则直接返回；若没有，再去查询数据库，并将数据写入到Redis</p><h4 id="2-2-1-流程分析"><a href="#2-2-1-流程分析" class="headerlink" title="2.2.1 流程分析"></a>2.2.1 流程分析</h4><p>根据ID查询商户缓存流程：</p><p>根据商铺ID从Redis中查询缓存，判断缓存是否命中</p><ul><li>若命中，则返回商铺信息</li><li>若未命中，则根据ID从MySQL中查询<ul><li>若MySQL中存在，则将商铺信息写入Redis，最后返回商铺信息</li><li>若MySQL中不存在，则返回error</li></ul></li></ul><h4 id="2-2-2-功能实现"><a href="#2-2-2-功能实现" class="headerlink" title="2.2.2 功能实现"></a>2.2.2 功能实现</h4><ol><li><p>更改ShopController中的queryShopById方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-keyword">return</span> shopService.queryById(id);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>依据之前分析的流程，在ShopService中实现该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.从Redis中查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> template.opsForValue().get(CACHE_SHOP_KEY + id);<br>    <span class="hljs-comment">// 2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;<br>        <span class="hljs-comment">// 3.存在则直接返回</span><br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br>    <span class="hljs-comment">// 4.不存在则根据ID查询数据库</span><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> getById(id);<br>    <span class="hljs-comment">// 5.不存在返回错误</span><br>    <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 6.存在则写入Redis</span><br>    template.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop));<br>    <span class="hljs-keyword">return</span> Result.ok(shop);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-缓存更新策略"><a href="#2-3-缓存更新策略" class="headerlink" title="2.3 缓存更新策略"></a>2.3 缓存更新策略</h3><p>为了解决缓存与数据库中实际信息不一致的问题，需要引入缓存更新策略。</p><h4 id="2-3-1-策略类型"><a href="#2-3-1-策略类型" class="headerlink" title="2.3.1 策略类型"></a>2.3.1 策略类型</h4><ol><li><p>内存淘汰：</p><p>默认开启，无需维护，利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据</p><p>此策略虽然成本低，但无法确保一致性</p></li><li><p>超时剔除：</p><p>给缓存数据添加TTL时间，到期后自动删除缓存，下次查询时更新缓存</p><p>一致性一般，维护成本低</p></li><li><p>主动更新：</p><p>编写业务逻辑，在修改数据库的同时，更新缓存</p><p>一致性好，但维护成本高</p></li></ol><p>业务场景选择：</p><ul><li>低一致性需求：使用内存淘汰机制。例如：店铺类型等长时间内不会改变的缓存数据</li><li>高一致性需求：主动更新，并以超时剔除作为兜底方案。例如：店铺详情查询的缓存</li></ul><h4 id="2-3-2-主动更新策略"><a href="#2-3-2-主动更新策略" class="headerlink" title="2.3.2 主动更新策略"></a>2.3.2 主动更新策略</h4><ol><li>Cache Aside Pattern：缓存调用者在更新数据库同时更新缓存</li><li>Read&#x2F;Write Through Pattern：缓存与数据库整合为一个服务，由服务维护一致性。调用者只需调用服务，无需关心一致性问题。</li><li>Write Behind Caching Pattern：调用者只操作缓存，由其他线程异步地将缓存数据持久化到数据库中，最终保持一致</li></ol><p>第二种策略虽然简化了调用者的操作，但是维护这样一个服务复杂度较高。</p><p>第三种策略存在有一致性与可靠性问题。若缓存服务器宕机，则对于缓存所做的操作（内存层面）都会丢失。</p><p>第一种策略虽然需要手写业务逻辑，但是可控性更高，适用范围广。</p><p>操作缓存与数据库时需要考虑的问题：</p><ol><li><p>删除缓存 or 更新缓存？</p><ul><li>更新缓存：每次更新数据库时都对缓存进行更新，会导致较多的无效写操作。因此可能在此期间并没有人进行读操作。</li><li>删除缓存：更新数据库时让缓存失效，等到下一次有人查询时再通过数据库添加缓存。</li></ul></li><li><p>如何保证缓存与数据库的操作同时成功或失败？原子性问题</p><ul><li>单体系统：将缓存与数据库操作放在一个事务中</li><li>分布式系统：利用TCC等分布式事务方案</li></ul></li><li><p>先操作缓存还是先操作数据库？线程安全问题</p><ul><li><p>先删缓存，再操作数据库：</p><p>一个线程删完缓存之后，还未来得及更新数据，另一个线程便进行查询操作，而查询缓存未命中，则查询数据库，并又将旧的数据写入缓存，此时第一个线程才更新完数据。</p><p>线程不安全，造成缓存与数据库不一致的情况</p></li><li><p>先操作数据库，再删缓存：</p><p>一个线程进行查询操作，但是查询缓存未命中，则查询数据库并得到数据。而此时另一个线程进行更新数据库操作，该操作对于第一个线程是不可见的，因此第一个线程在写入缓存时，仍然写入的是旧数据。</p></li><li><p>方案二发生的可能性更低，因为需要满足缓存失效、数据库更新快于写入缓存等极端条件。因此选择方案二。</p></li></ul></li></ol><h4 id="2-3-3-代码实现"><a href="#2-3-3-代码实现" class="headerlink" title="2.3.3 代码实现"></a>2.3.3 代码实现</h4><ol><li><p>在查询代码的写入缓存逻辑中，添加缓存超时时间，作为保底方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 6.存在则写入Redis</span><br>template.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);<br></code></pre></td></tr></table></figure></li><li><p>更改ShopController中的updateShop方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PutMapping</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">updateShop</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Shop shop)</span> &#123;<br>    <span class="hljs-comment">// 写入数据库</span><br>    <span class="hljs-keyword">return</span> shopService.update(shop);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在ShopService中实现该方法：注意为确保缓存与数据库操作的原子性，需要添加事务注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">update</span><span class="hljs-params">(Shop shop)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> shop.getId();<br>    <span class="hljs-keyword">if</span> (id == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺id不能为空&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 1.更新数据库</span><br>    updateById(shop);<br>    <span class="hljs-comment">// 2.删缓存</span><br>    template.delete(CACHE_SHOP_KEY + shop.getId());<br>    <span class="hljs-comment">// 3.返回</span><br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-缓存穿透"><a href="#2-4-缓存穿透" class="headerlink" title="2.4 缓存穿透"></a>2.4 缓存穿透</h3><h4 id="2-4-1-介绍与解决思路"><a href="#2-4-1-介绍与解决思路" class="headerlink" title="2.4.1 介绍与解决思路"></a>2.4.1 介绍与解决思路</h4><p>客户端请求的数据在缓存和数据库中都不存在，最终这些请求均会到达数据库。若多线程高并发请求，则会使数据库崩溃。</p><p>解决方案：</p><ol><li>缓存空对象：当请求到达数据库，数据库也不存在时，则缓存一个空对象，之后再次请求时，缓存命中并返回空对象。<ul><li>优点：实现简单，维护方便</li><li>缺点：额外内存消耗（可设置TTL解决）、短期不一致（可能缓存空对象后，又插入了真实数据，造成缓存与数据库不一致）</li></ul></li><li>布隆过滤器<ul><li>优点：内存占用少，没有多余key</li><li>缺点：实现复杂，存在误判可能性</li></ul></li></ol><h4 id="2-4-2-代码实现"><a href="#2-4-2-代码实现" class="headerlink" title="2.4,2 代码实现"></a>2.4,2 代码实现</h4><p>修改ShopServiceImpl中的queryById方法</p><p>需要注意的是：isNotBlank方法只有在为Null以及为””的情况下返回false</p><ul><li>如果其返回true，则表示缓存中存在店铺信息，直接返回信息</li><li>如果其返回false，则需进一步判断是Null还是””<ul><li>如果是””，则代表已设置了空对象，报错</li><li>如果是Null，则代表当前缓存中不存在该信息，则需要进一步查询数据库</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.从Redis中查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> template.opsForValue().get(CACHE_SHOP_KEY + id);<br>    <span class="hljs-comment">// 2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;<br>        <span class="hljs-comment">// 3.存在则直接返回</span><br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br>    <span class="hljs-comment">// 判断命中的是否是空值</span><br>    <span class="hljs-keyword">if</span> (shopJson != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺信息不存在！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4.不存在则根据ID查询数据库</span><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> getById(id);<br>    <span class="hljs-comment">// 5.不存在，将空值写入Redis，返回错误</span><br>    <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;<br>        template.opsForValue().set(CACHE_SHOP_KEY + id, <span class="hljs-string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 6.存在则写入Redis</span><br>    template.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-keyword">return</span> Result.ok(shop);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-缓存雪崩"><a href="#2-5-缓存雪崩" class="headerlink" title="2.5 缓存雪崩"></a>2.5 缓存雪崩</h3><p>在同一时段有大量的缓存key同时失效或Redis宕机，导致大量请求进入数据库，带来巨大压力</p><p>解决方案：</p><ol><li>给不同key设置随机的TTL值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ol><h3 id="2-6-缓存击穿"><a href="#2-6-缓存击穿" class="headerlink" title="2.6 缓存击穿"></a>2.6 缓存击穿</h3><p>缓存击穿也被称为热点key问题，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数请求进入数据库，在瞬间给数据库造成巨大冲击。</p><p>解决方案：</p><ol><li><p>互斥锁：并发线程中只有一个线程获取到锁，进行缓存重建操作，重建完成并释放锁之后，其他线程再次查询缓存。</p></li><li><p>逻辑过期：为缓存设置逻辑过期时间，若某个线程发现逻辑时间已过期，便去获取互斥锁，获取成功之后去开启新线程重建缓存，其直接返回过期的数据即可。</p><p>其他线程访问时也是同理，若其发现逻辑时间过期，则去获取互斥锁，若获取失败，说明有线程正在重建缓存，其直接返回过期数据</p></li></ol><p>对比：</p><ol><li><p>互斥锁没有额外内存消耗，实现简单，可以保证一致性</p><p>但互斥锁的性能较差，且存在死锁风险</p></li><li><p>逻辑过期线程无需等待，性能较好</p><p>但其不保证一致性，有额外的内存消耗，实现较为复杂</p></li></ol><h4 id="2-6-1-代码实现"><a href="#2-6-1-代码实现" class="headerlink" title="2.6.1 代码实现"></a>2.6.1 代码实现</h4><h5 id="基于互斥锁"><a href="#基于互斥锁" class="headerlink" title="基于互斥锁"></a>基于互斥锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 缓存穿透</span><br>    <span class="hljs-comment">// Shop shop = queryWithPassThrough(id);</span><br>    <span class="hljs-comment">// 互斥锁解决缓存击穿</span><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> queryWithMutex(id);<br>    <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok(shop);<br>&#125;<br><br><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithMutex</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.从Redis中查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> template.opsForValue().get(CACHE_SHOP_KEY + id);<br>    <span class="hljs-comment">// 2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;<br>        <span class="hljs-comment">// 3.存在则直接返回</span><br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br>        <span class="hljs-keyword">return</span> shop;<br>    &#125;<br>    <span class="hljs-comment">// 判断命中的是否是空值</span><br>    <span class="hljs-keyword">if</span> (shopJson != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 4.实现缓存重建</span><br>    <span class="hljs-comment">// 4.1 获取互斥锁</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>        <span class="hljs-comment">// 4.2 判断是否获取成功</span><br>        <span class="hljs-keyword">if</span> (!isLock) &#123;<br>            <span class="hljs-comment">// 4.3 失败，休眠并充实</span><br>            Thread.sleep(<span class="hljs-number">50</span>);<br>            <span class="hljs-keyword">return</span> queryWithMutex(id);<br>        &#125;<br>        <span class="hljs-comment">// 4.4 成功，则根据id查询数据库</span><br>        shop = getById(id);<br>        <span class="hljs-comment">// 5.不存在，将空值写入Redis，返回错误</span><br>        <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;<br>            template.opsForValue().set(CACHE_SHOP_KEY + id, <span class="hljs-string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 6.存在则写入Redis</span><br>        template.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 7.释放互斥锁</span><br>        unlock(lockKey);<br>    &#125;<br>    <span class="hljs-keyword">return</span> shop;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="基于逻辑过期"><a href="#基于逻辑过期" class="headerlink" title="基于逻辑过期"></a>基于逻辑过期</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.从Redis中查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> template.opsForValue().get(CACHE_SHOP_KEY + id);<br>    <span class="hljs-comment">// 2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isBlank(shopJson)) &#123;<br>        <span class="hljs-comment">// 3.不存在直接返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 4.命中，将json反序列化为对象</span><br>    <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, RedisData.class);<br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);<br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();<br>    <span class="hljs-comment">// 5.判断是否过期</span><br>    <span class="hljs-comment">// 5.1 未过期，直接返回店铺信息</span><br>    <span class="hljs-keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-keyword">return</span> shop;<br>    &#125;<br>    <span class="hljs-comment">// 5.2 已过期，重建缓存</span><br>    <span class="hljs-comment">// 6.缓存重建</span><br>    <span class="hljs-comment">// 6.1 获取互斥锁</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>    <span class="hljs-comment">// 6.2 判断获取锁是否成功</span><br>    <span class="hljs-keyword">if</span> (isLock) &#123;<br>        <span class="hljs-comment">// 6.3 成功，开启线程池，实现缓存重建</span><br>        CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 重建缓存</span><br>                <span class="hljs-built_in">this</span>.saveShop2Redis(id, <span class="hljs-number">20L</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 释放锁</span><br>                unlock(lockKey);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-comment">// 6.4 返回过期的商铺信息</span><br>    <span class="hljs-keyword">return</span> shop;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-缓存工具封装"><a href="#2-7-缓存工具封装" class="headerlink" title="2.7 缓存工具封装"></a>2.7 缓存工具封装</h3><p>为使得解决缓存问题变得更加通用，封装一个缓存工具类，采用了泛型方法、函数式编程、Lambda表达式实现</p><ul><li>set：存储缓存键值对</li><li>setWithLogicalExpire：存储带有逻辑过期时间的缓存键值对</li><li>queryWithPassThrough：用于解决缓存穿透的查询</li><li>queryWithLogicalExpire：用于解决缓存击穿的查询</li></ul><p>具体流程为：</p><ol><li><p>在utils包下创建CacheClient类</p></li><li><p>添加如下四个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheClient</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate template;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;<br>        template.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWithLogicalExpire</span><span class="hljs-params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-comment">// 设置逻辑过期</span><br>        <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisData</span>();<br>        redisData.setData(value);<br>        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));<br>        template.opsForValue().set(key, JSONUtil.toJsonStr(redisData), time, unit);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> &lt;R, ID&gt; R <span class="hljs-title function_">queryWithPassThrough</span><span class="hljs-params">(String keyPrefix,</span><br><span class="hljs-params">                                          ID id, Class&lt;R&gt; type,</span><br><span class="hljs-params">                                          Function&lt;ID, R&gt; dbFallBack,</span><br><span class="hljs-params">                                          Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>        <span class="hljs-comment">// 1.从Redis中查询商铺缓存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> template.opsForValue().get(key);<br>        <span class="hljs-comment">// 2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(json)) &#123;<br>            <span class="hljs-comment">// 3.存在则直接返回</span><br>            <span class="hljs-keyword">return</span> JSONUtil.toBean(json, type);<br>        &#125;<br>        <span class="hljs-comment">// 判断命中的是否是空值</span><br>        <span class="hljs-keyword">if</span> (json != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 4.不存在则根据ID查询数据库</span><br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dbFallBack.apply(id);<br>        <span class="hljs-comment">// 5.不存在，将空值写入Redis，返回错误</span><br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-literal">null</span>) &#123;<br>            template.opsForValue().set(key, <span class="hljs-string">&quot;&quot;</span>, time, unit);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 6.存在则写入Redis</span><br>        <span class="hljs-built_in">this</span>.set(key, JSONUtil.toJsonStr(r), time, unit);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-keyword">public</span> &lt;R, ID&gt; R <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">(String keyPrefix,</span><br><span class="hljs-params">                                            ID id, Class&lt;R&gt; type,</span><br><span class="hljs-params">                                            Function&lt;ID, R&gt; dbFallBack,</span><br><span class="hljs-params">                                            Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>        <span class="hljs-comment">// 1.从Redis中查询商铺缓存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> template.opsForValue().get(key);<br>        <span class="hljs-comment">// 2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(json)) &#123;<br>            <span class="hljs-comment">// 3.不存在直接返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 4.命中，将json反序列化为对象</span><br>        <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(json, RedisData.class);<br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();<br>        <span class="hljs-comment">// 5.判断是否过期</span><br>        <span class="hljs-comment">// 5.1 未过期，直接返回店铺信息</span><br>        <span class="hljs-keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;<br>            <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        <span class="hljs-comment">// 5.2 已过期，重建缓存</span><br>        <span class="hljs-comment">// 6.缓存重建</span><br>        <span class="hljs-comment">// 6.1 获取互斥锁</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>        <span class="hljs-comment">// 6.2 判断获取锁是否成功</span><br>        <span class="hljs-keyword">if</span> (isLock) &#123;<br>            <span class="hljs-comment">// 6.3 成功，开启线程池，实现缓存重建</span><br>            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">R</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> dbFallBack.apply(id);<br>                    <span class="hljs-built_in">this</span>.setWithLogicalExpire(key, r1, time, unit);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 释放锁</span><br>                    unlock(lockKey);<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">// 6.4 返回过期的商铺信息</span><br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> template.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span> &#123;<br>        template.delete(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-优惠券秒杀"><a href="#3-优惠券秒杀" class="headerlink" title="3. 优惠券秒杀"></a>3. 优惠券秒杀</h2><h3 id="3-1-全局唯一ID"><a href="#3-1-全局唯一ID" class="headerlink" title="3.1 全局唯一ID"></a>3.1 全局唯一ID</h3><h4 id="3-1-1-介绍"><a href="#3-1-1-介绍" class="headerlink" title="3.1.1 介绍"></a>3.1.1 介绍</h4><p>当用户进行优惠券秒杀时，会生成优惠券订单。如果订单编号采用数据库自增ID便会存在如下问题：</p><ol><li>ID规律明显</li><li>会受到当前表数据量的限制</li></ol><p>因此需要全局唯一ID生成器，用于在分布式系统下生成全局唯一ID</p><p>其满足：唯一性、高可用、高性能、递增性、安全性</p><p>该ID的设计规则如下：</p><ul><li>其二进制由64个bit组成：<ul><li>最高位第63位为符号位，始终为0</li><li>62~32位为时间戳，共31个bit</li><li>31~0位为序列号，共32个bit：序列号的自增是通过Redis的increment自增实现</li></ul></li></ul><h4 id="3-1-1-代码实现"><a href="#3-1-1-代码实现" class="headerlink" title="3.1.1 代码实现"></a>3.1.1 代码实现</h4><p>代码实现流程如下：</p><p>在utils包下创建RedisIdWorker类。</p><p>其中需要注意最终结果的返回需要将时间戳与序列号进行拼接，采用移位 + 或运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIdWorker</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_STAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1640995200L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate template;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">(String keyPrefix)</span> &#123;<br>        <span class="hljs-comment">// 1.生成时间戳</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nowSecond</span> <span class="hljs-operator">=</span> now.toEpochSecond(ZoneOffset.UTC);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> nowSecond - BEGIN_STAMP;<br>        <span class="hljs-comment">// 2.生成序列号</span><br>        <span class="hljs-comment">// 2.1 获取当前日期，精确到天</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> template.opsForValue().increment(<span class="hljs-string">&quot;icr:&quot;</span> + keyPrefix + <span class="hljs-string">&quot;:&quot;</span> + date);<br>        <span class="hljs-comment">// 3.拼接并返回</span><br>        <span class="hljs-keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-优惠券秒杀下单"><a href="#3-2-优惠券秒杀下单" class="headerlink" title="3.2 优惠券秒杀下单"></a>3.2 优惠券秒杀下单</h3><h4 id="3-2-1-流程分析"><a href="#3-2-1-流程分析" class="headerlink" title="3.2.1 流程分析"></a>3.2.1 流程分析</h4><p>数据库中有两张表：</p><ul><li>tb_voucher：优惠券的基本信息，优惠金额、使用规则等</li><li>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</li></ul><p>voucher中存储了优惠券的基本信息，而seckill_voucher是特价优惠券，对优惠券添加了额外的抢购信息。</p><p>我们需要向借助于Postman向服务发起请求，添加特价优惠券。</p><p>注意当前时间必须在beginTime与endTime的时间段内，否则前端页面中不会显示出已添加的特价优惠券。</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221031122855313.png" alt="image-20221031122855313" style="zoom:33%;" /><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;shopId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;100元代金券&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subTitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;周一至周五均可使用&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;rules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;全场通用\\n无需预约\\n可无限叠加\\不兑现、不找零\\n仅限堂食&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;payValue&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">8000</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;actualValue&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10000</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;stock&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">100</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;beginTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2022-10-30T10:09:17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;endTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2022-10-30T12:09:17&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>秒杀下单流程分析：</p><ol><li>提交优惠券ID</li><li>查询优惠券信息，判断秒杀是否开始与结束、库存是否充足</li><li>扣减库存，创建订单，返回订单ID</li></ol><h4 id="3-2-2-代码实现"><a href="#3-2-2-代码实现" class="headerlink" title="3.2.2 代码实现"></a>3.2.2 代码实现</h4><ol><li><p>修改VoucherOrderController中的seckillVoucher方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;seckill/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long voucherId)</span> &#123;<br>    <span class="hljs-keyword">return</span> voucherOrderService.seckillVoucher(voucherId);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实现该方法</p></li><li><p>&#96;&#96;&#96;java<br>@Override<br>@Transactional<br>public Result seckillVoucher(Long voucherId) {<br>&#x2F;&#x2F; 1.查询优惠券<br>SeckillVoucher voucher &#x3D; seckillVoucherService.getById(voucherId);<br>&#x2F;&#x2F; 2.判断秒杀是否开始与结束<br>if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {<br>    return Result.fail(“秒杀尚未开始！”);<br>}<br>if (voucher.getEndTime().isBefore(LocalDateTime.now())) {<br>    return Result.fail(“秒杀尚未结束！”);<br>}<br>&#x2F;&#x2F; 3.判断库存是否充足<br>if (voucher.getStock() &lt; 1) {<br>    return Result.fail(“库存不足！”);<br>}<br>&#x2F;&#x2F; 4.扣减库存<br>boolean success &#x3D; seckillVoucherService.update()<br>    .setSql(“stock &#x3D; stock - 1”)<br>    .eq(“voucher_id”, voucherId).update();<br>if (!success) {<br>    return Result.fail(“库存不足！”);<br>}<br>&#x2F;&#x2F; 5.创建订单<br>VoucherOrder voucherOrder &#x3D; new VoucherOrder();<br>long orderId &#x3D; redisIdWorker.nextId(“order”);<br>voucherOrder.setId(orderId);<br>Long userId &#x3D; UserHolder.getUser().getId();<br>voucherOrder.setUserId(userId);<br>voucherOrder.setVoucherId(voucherId);<br>save(voucherOrder);<br>return Result.ok(orderId);<br>}</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### <span class="hljs-number">3.3</span> 超卖问题<br><br>#### <span class="hljs-number">3.2</span><span class="hljs-number">.1</span> 问题与解决方案<br><br>采用JMeter对秒杀接口进行测试，请求数为<span class="hljs-number">200</span>（此处记得在JMeter中设置请求头Token）。发现出现了超卖问题。<br><br>假设线程<span class="hljs-number">1</span>过来查询库存，判断出来库存大于<span class="hljs-number">1</span>，正准备去扣减库存，但是还没有来得及去扣减，此时线程<span class="hljs-number">2</span>过来，线程<span class="hljs-number">2</span>也去查询库存，发现这个数量一定也大于<span class="hljs-number">1</span>，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。<br><br>解决方案如下：<br><br>-   悲观锁：认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。例如Synchronized、Lock都属于悲观锁<br>-   乐观锁：认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其它线程对数据做了修改。如果没有修改则认为是安全的，自己才更新数据。如果已经被其它线程修改说明发生了安全问题，此时可以重试或异常。<br>    -   版本号法：给数据加一个version字段。每当数据修改时，version自增<span class="hljs-number">1</span>。通过version来判断数据是否被修改。<br>    -   CAS法：先比较再修改。在修改时需要判断之前查询到的值与当前的值是否相等，相等才做修改。<br>-   悲观锁 vs 乐观锁<br>    -   悲观锁实现起来较为简单，但是性能一般<br>    -   乐观锁性能好，但是存在成功率低的问题<br><br>#### <span class="hljs-number">3.2</span><span class="hljs-number">.2</span> 代码实现<br><br>乐观锁代码实现：<br><br>修改<span class="hljs-number">3.2</span>部分代码中的扣减库存内容：只需要确保当前数据库库存大于<span class="hljs-number">0</span>，即可扣减库存。<br><br>```java<br><span class="hljs-comment">// 4.扣减库存</span><br>boolean success = seckillVoucherService.update()<br>    .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>    .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>    .update();<br><span class="hljs-keyword">if</span> (!success) &#123;<br>    return Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-一人一单需求"><a href="#3-4-一人一单需求" class="headerlink" title="3.4 一人一单需求"></a>3.4 一人一单需求</h3><h4 id="3-4-1-流程分析"><a href="#3-4-1-流程分析" class="headerlink" title="3.4.1 流程分析"></a>3.4.1 流程分析</h4><p>同一个优惠券，一个用户只能下一单</p><p>添加该需求之后，新的流程为：</p><p>秒杀下单流程分析：</p><ol><li>提交优惠券ID</li><li>查询优惠券信息，判断秒杀是否开始与结束、库存是否充足</li><li>根据优惠券ID与用户ID查询订单。若存在，则说明该用户已下过单，返回失败。</li><li>扣减库存，创建订单，返回订单ID</li></ol><h4 id="3-4-2-代码实现"><a href="#3-4-2-代码实现" class="headerlink" title="3.4.2 代码实现"></a>3.4.2 代码实现</h4><p>第一版代码如下：</p><p>该代码存在线程并发安全问题，多个线程同时查询，同时执行扣减库存操作，同时创建订单，造成一人一单失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 1.查询优惠券</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>    <span class="hljs-comment">// 2.判断秒杀是否开始与结束</span><br>    <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4.一人一单，查询订单</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已经购买过一次！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 5.扣减库存</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>        .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>        .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>        .update();<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 6.创建订单</span><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    voucherOrder.setId(orderId);<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    voucherOrder.setUserId(userId);<br>    voucherOrder.setVoucherId(voucherId);<br>    save(voucherOrder);<br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure><p>第二版代码：悲观锁</p><p>将查询订单、扣减库存、创建订单等代码进行抽取，并添加@Transactional注解，删除原本seckillVoucher方法的事务注解</p><ul><li><p>用用户的ID作为Synchronized锁。</p></li><li><p>释放锁的操作应该在提交事务之后才执行，因此需要在seckillVoucher中加Synchronized锁，包裹createVoucherOrder方法</p></li><li><p>非事务调用事务方法，会导致事务失效。因为调用者是this，是当前对象，而不是代理对象。非代理对象不具备事务功能</p><ol><li><p>添加如下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在启动类HmDianPingApplication中添加注解：<code>@EnableAspectJAutoProxy(exposeProxy = true)</code></p></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 1.查询优惠券</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>    <span class="hljs-comment">// 2.判断秒杀是否开始与结束</span><br>    <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 为避免每次toString得到新的字符串对象，需要采用intern方法将其添加字符串池</span><br>    <span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<br>        <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>        <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 4.一人一单，查询订单</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已经购买过一次！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 5.扣减库存</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>        .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>        .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>        .update();<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 6.创建订单</span><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    voucherOrder.setId(orderId);<br>    voucherOrder.setUserId(userId);<br>    voucherOrder.setVoucherId(voucherId);<br>    save(voucherOrder);<br>    <span class="hljs-comment">// 7.返回订单ID</span><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-集群下的线程安全问题"><a href="#3-5-集群下的线程安全问题" class="headerlink" title="3.5 集群下的线程安全问题"></a>3.5 集群下的线程安全问题</h3><h4 id="3-5-1-前置准备"><a href="#3-5-1-前置准备" class="headerlink" title="3.5.1 前置准备"></a>3.5.1 前置准备</h4><ol><li><p>复制一个新的启动类</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221101175643840.png" alt="image-20221101175643840" style="zoom: 50%;" /></li><li><p>修改nginx配置文件，实现反向代理和负载均衡</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs conf">location /api &#123;  <br>    default_type  application/json;<br>    #internal;  <br>    keepalive_timeout   30s;  <br>    keepalive_requests  1000;  <br>    #支持keep-alive  <br>    proxy_http_version 1.1;  <br>    rewrite /api(/.*) $1 break;  <br>    proxy_pass_request_headers on;<br>    #more_clear_input_headers Accept-Encoding;  <br>    proxy_next_upstream error timeout;  <br>    #proxy_pass http://127.0.0.1:8081;<br>    proxy_pass http://backend;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>采用 <code>nginx -s reload</code> 命令重启nginx</p></li></ol><p>在单机模式下，只有一个JVM，因此采用JVM的同步锁监视器Synchronized可以解决线程安全问题</p><p>而在集群模式下，有多个JVM，因此一个JVM的悲观锁对于另外一个JVM来说是不可见的，因此无法解决线程安全问题</p><h2 id="4-分布式锁"><a href="#4-分布式锁" class="headerlink" title="4. 分布式锁"></a>4. 分布式锁</h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p><p>分布式锁的核心思想：每个服务共用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行。</p><ul><li>可见性：多个线程都能看到相同的结果<ul><li>注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</li></ul></li><li>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</li><li>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</li><li>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</li><li>安全性：安全也是程序中必不可少的一环</li></ul><h3 id="4-2-实现方案"><a href="#4-2-实现方案" class="headerlink" title="4.2 实现方案"></a>4.2 实现方案</h3><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221101180507154.png" alt="image-20221101180507154"></p><h3 id="4-3-基于Redis的分布式锁"><a href="#4-3-基于Redis的分布式锁" class="headerlink" title="4.3 基于Redis的分布式锁"></a>4.3 基于Redis的分布式锁</h3><h4 id="4-3-1-实现思路"><a href="#4-3-1-实现思路" class="headerlink" title="4.3.1 实现思路"></a>4.3.1 实现思路</h4><ol><li>获取锁：<ul><li>采用 <code>setnx</code> 命令确保互斥性，采用 <code>expire</code> 命令确保超时释放，防止Redis宕机造成锁无法释放的问题。</li><li>为确保上述两操作的原子性，可以在同一个 <code>set</code> 命令中，执行上述两个操作。</li><li>非阻塞：若尝试一次成功，则返回 true；否则返回 false</li></ul></li><li>释放锁：<ul><li>手动释放，采用 <code>del</code> 删除</li><li>超时释放</li></ul></li></ol><h4 id="4-3-2-代码实现"><a href="#4-3-2-代码实现" class="headerlink" title="4.3.2 代码实现"></a>4.3.2 代码实现</h4><h5 id="第一版代码"><a href="#第一版代码" class="headerlink" title="第一版代码"></a>第一版代码</h5><ol><li><p>在utils包下添加ILock接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILock</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实现该接口：SimpleRedisLock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate template;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRedisLock</span><span class="hljs-params">(String name, StringRedisTemplate template)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.template = template;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-comment">// 获取线程标识</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> template.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + <span class="hljs-string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 释放锁</span><br>    template.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改VoucherOrderServiceImpl中加锁的逻辑：只对同一个用户做限制（一人一单）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建锁对象</span><br><span class="hljs-type">SimpleRedisLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRedisLock</span>(<span class="hljs-string">&quot;order:&quot;</span> + userId, template);<br><span class="hljs-comment">// 获取锁</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">1200</span>);<br><span class="hljs-keyword">if</span> (!isLock) &#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="防误删"><a href="#防误删" class="headerlink" title="防误删"></a>防误删</h5><p>释放锁时，可能出现释放其他线程锁的情况</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221101181842615.png" alt="image-20221101181842615"></p><p>改进思路：</p><ol><li><p>在获取锁时，需要设置该锁对应的值value：用UUID（当前服务对应的唯一ID） + 当前线程ID作为标识。</p><p>防止不同JVM之间造成的线程ID冲突问题</p></li><li><p>在释放锁时，需要先判断当前线程的标识是否与锁的线程标识一致</p></li></ol><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate template;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br><br>    <span class="hljs-comment">// 注意：hutool包下的UUID方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&quot;-&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRedisLock</span><span class="hljs-params">(String name, StringRedisTemplate template)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.template = template;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-comment">// 获取线程标识</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>        <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> template.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 获取线程标识</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>        <span class="hljs-comment">// 获取锁标识</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> template.opsForValue().get(KEY_PREFIX + name);<br>        <span class="hljs-keyword">if</span> (threadId.equals(id)) &#123;<br>            <span class="hljs-comment">// 释放锁</span><br>            template.delete(KEY_PREFIX + name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Lua脚本解决原子性"><a href="#Lua脚本解决原子性" class="headerlink" title="Lua脚本解决原子性"></a>Lua脚本解决原子性</h5><p>判断锁和释放锁操作之间不存在原子性，可能仍会造成误删。</p><p>代码实现：</p><ol><li><p>在resources下创建 unlock.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 比较线程标识与锁中的标识是否一致</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>]) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>修改SimpleRedisLock：用静态代码块提前读取lua脚本文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hmdp.utils;<br><br><span class="hljs-keyword">import</span> cn.hutool.core.lang.UUID;<br><span class="hljs-keyword">import</span> org.springframework.core.io.ClassPathResource;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;<br><br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> StringRedisTemplate template;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&quot;-&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        UNLOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        UNLOCK_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unlock.lua&quot;</span>));<br>        UNLOCK_SCRIPT.setResultType(Long.class);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRedisLock</span><span class="hljs-params">(String name, StringRedisTemplate template)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.template = template;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-comment">// 获取线程标识</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>        <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> template.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 调用lua脚本</span><br>        template.execute(<br>                UNLOCK_SCRIPT,<br>                Collections.singletonList(KEY_PREFIX + name),<br>                ID_PREFIX + Thread.currentThread().getId());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-4-Redisson"><a href="#4-4-Redisson" class="headerlink" title="4.4 Redisson"></a>4.4 Redisson</h3><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><h4 id="4-4-1-配置"><a href="#4-4-1-配置" class="headerlink" title="4.4.1 配置"></a>4.4.1 配置</h4><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.17.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在config下创建RedissonConfig类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 配置</span><br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://localhost:6379&quot;</span>).setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">// 创建对象</span><br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改VoucherOrderServiceImp中创建锁的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><span class="hljs-comment">// 创建锁对象</span><br><span class="hljs-comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, template);</span><br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userId);<br><span class="hljs-comment">// 获取锁</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock();<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-4-2-可重入锁"><a href="#4-4-2-可重入锁" class="headerlink" title="4.4.2 可重入锁"></a>4.4.2 可重入锁</h4><p>Redisson采用Redis的哈希结构，key为锁的名称，value为哈希结构：field为线程标识，value为重入次数</p><p>加锁解锁流程如下：</p><ol><li>加锁：判断锁是否存在<ul><li>若不存在，则获取锁并添加线程标识，设置锁的有效期，执行业务，进入第2步</li><li>若存在，则判断锁标识是否为当前线程<ul><li>若是，则锁计数加1，并设置锁的有效期，执行业务，进入第2步</li><li>若不是，获取锁失败</li></ul></li></ul></li><li>解锁：判断锁是否是自己的<ul><li>若是，则锁计数减1。<ul><li>若锁计数减为0，则释放锁</li><li>若锁计数不为0，则重置锁的有效期，继续执行上一层的业务，再进入第2步</li></ul></li><li>若不是，说明锁已被超时释放，逻辑结束</li></ul></li></ol><p>其中加锁与解锁中涉及到多个操作原子性的问题，Redisson用lua脚本实现</p><h4 id="4-4-3-锁重试与WatchDog机制"><a href="#4-4-3-锁重试与WatchDog机制" class="headerlink" title="4.4.3 锁重试与WatchDog机制"></a>4.4.3 锁重试与WatchDog机制</h4><p>此部分参照教程</p><p>Redisson分布式锁原理：</p><ul><li>可重入：利用hash结构记录线程id和重入次数</li><li>可重试：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制</li><li>超时续约：利用watchDog，每隔一段时间（releaseTime &#x2F; 3），重置超时时间</li></ul><h4 id="4-4-4-MultiLock"><a href="#4-4-4-MultiLock" class="headerlink" title="4.4.4 MultiLock"></a>4.4.4 MultiLock</h4><p>此锁主要用于解决Redis分布式锁主从一致性问题：</p><p>采用Redis主从模式：写命令会在主机上执行，读命令会在从机上执行</p><p>当主机将数据同步到从机的过程中，主机宕机了，但并没有完成同步数据。当哨兵节点发现主机宕机，并重新选出一个主机时，此时新选出的主机并没有分布式锁的信息，此时便会出现线程安全问题。</p><p>为解决此问题，采用MultiLock。每个节点的都是相同的地位，只有当所有的节点都写入成功，才算是加锁成功。假设某个节点宕机，那么便成功完成加锁。</p><h2 id="5-秒杀优化"><a href="#5-秒杀优化" class="headerlink" title="5. 秒杀优化"></a>5. 秒杀优化</h2><h3 id="5-1-优化思路"><a href="#5-1-优化思路" class="headerlink" title="5.1 优化思路"></a>5.1 优化思路</h3><p>之前秒杀过程如下图所示，tomcat程序中的操作是串行执行。这样会导致较长的执行时间。</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221102204723432.png" alt="image-20221102204723432"></p><p>优化思路为：将耗时比较短的逻辑放入Redis中：判断库存是否充足、判断是否为一人一单，这两个判断是业务的核心逻辑，判断正确无误意味着一定可以完成下单，便可返回订单ID。而耗时较长的逻辑：创建订单、减库存交由另外一个线程去处理，主线程只需要将与秒杀相关的优惠券ID、用户ID、订单ID保存到消息队列，让另外一个线程从队列中读取，并完成剩余的逻辑即可。</p><p>其中一人一单通过Redis中的set集合来完成，key为订单ID，value为set集合，里面存储用户ID。</p><p>新的流程为：</p><ul><li>对于主线程：<ol><li>从Redis中判断订单是否充足、判断是否满足一人一单</li><li>满足条件，则扣减Redis中的库存信息，将用户ID存入对应的set集合。此部分采用lua脚本以确保原子性</li><li>将相关信息添加到阻塞队列中</li><li>返回订单ID</li></ol></li><li>对于另外开辟的线程：<ol><li>从阻塞队列中获取优惠券ID、用户ID、订单ID等信息</li><li>将订单信息添加到数据库中，并扣减数据库中的库存</li></ol></li></ul><p>优化秒杀过程如下图所示</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221102205318170.png" alt="image-20221102205318170"></p><h3 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h3><ol><li><p>修改VoucherServiceImpl中添加秒杀优惠券的方法addSeckillVoucher</p><p>在添加的过程中将库存保存到Redis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSeckillVoucher</span><span class="hljs-params">(Voucher voucher)</span> &#123;<br>    <span class="hljs-comment">// 保存优惠券</span><br>    save(voucher);<br>    <span class="hljs-comment">// 保存秒杀信息</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeckillVoucher</span>();<br>    seckillVoucher.setVoucherId(voucher.getId());<br>    seckillVoucher.setStock(voucher.getStock());<br>    seckillVoucher.setBeginTime(voucher.getBeginTime());<br>    seckillVoucher.setEndTime(voucher.getEndTime());<br>    seckillVoucherService.save(seckillVoucher);<br>    <span class="hljs-comment">// 保存秒杀库存到Redis</span><br>    template.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>用lua脚本实现Redis中查询库存、判断一人一单、减库存等操作</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 1.参数列表</span><br><span class="hljs-comment">-- 1.1.优惠券id</span><br><span class="hljs-keyword">local</span> voucherId = ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-comment">-- 1.2.用户id</span><br><span class="hljs-keyword">local</span> userId = ARGV[<span class="hljs-number">2</span>]<br><span class="hljs-comment">-- 2.数据key</span><br><span class="hljs-comment">-- 2.1.库存key</span><br><span class="hljs-keyword">local</span> stockKey = <span class="hljs-string">&#x27;seckill:stock:&#x27;</span> .. voucherId<br><span class="hljs-comment">-- 2.2.订单key</span><br><span class="hljs-keyword">local</span> orderKey = <span class="hljs-string">&#x27;seckill:order:&#x27;</span> .. voucherId<br><br><span class="hljs-comment">-- 3.脚本业务</span><br><span class="hljs-comment">-- 3.1.判断库存是否充足 get stockKey</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.2.库存不足，返回1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.3.存在，说明是重复下单，返回2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.4.扣库存 incrby stockKey -1</span><br>redis.call(<span class="hljs-string">&#x27;incrby&#x27;</span>, stockKey, <span class="hljs-number">-1</span>)<br><span class="hljs-comment">-- 3.5.下单（保存用户）sadd orderKey userId</span><br>redis.call(<span class="hljs-string">&#x27;sadd&#x27;</span>, orderKey, userId)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>修改VoucherOrderServiceImpl中的seckillVoucher方法</p><p>由于proxy在另外一个线程中也需要用到，所以将其提到外面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;<br><br><span class="hljs-keyword">static</span> &#123;<br>    SECKILL_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>    SECKILL_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;seckill.lua&quot;</span>));<br>    SECKILL_SCRIPT.setResultType(Long.class);<br>&#125;<br><br><span class="hljs-keyword">private</span> IVoucherOrderService proxy;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 1.执行lua脚本</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> template.execute(<br>        SECKILL_SCRIPT,<br>        Collections.emptyList(),<br>        voucherId.toString(), userId.toString()<br>    );<br>    <span class="hljs-comment">// 2.判断结果是否为0</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> result.intValue();<br>    <span class="hljs-comment">// 2.1 不为0，代表没有购买资格</span><br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(r == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;库存不足&quot;</span> : <span class="hljs-string">&quot;不能重复下单&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 2.2 为0，有购买资格，把下单信息保存到阻塞队列</span><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    voucherOrder.setId(orderId);<br>    voucherOrder.setUserId(userId);<br>    voucherOrder.setVoucherId(voucherId);<br>    <span class="hljs-comment">// 2.3 放入阻塞队列</span><br>    orderTasks.add(voucherOrder);<br>    <span class="hljs-comment">// 3.获取代理对象</span><br>    proxy = (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-comment">// 4.返回订单id</span><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>添加阻塞队列处理的逻辑，实现异步在数据库中完成下单操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 阻塞队列，存放相关订单信息</span><br><span class="hljs-keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br><span class="hljs-comment">// 异步执行线程池</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">SECKILL_ORDER_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br><span class="hljs-comment">// 在类初始化之前执行线程池任务</span><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    SECKILL_ORDER_EXECUTOR.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrderHandler</span>());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 1.获取队列中的订单信息</span><br>                <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> orderTasks.take();<br>                <span class="hljs-comment">// 2.创建订单</span><br>                handleVoucherOrder(voucherOrder);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                log.error(<span class="hljs-string">&quot;处理订单异常&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleVoucherOrder</span><span class="hljs-params">(VoucherOrder voucherOrder)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> voucherOrder.getUserId();<br>    <span class="hljs-comment">// 创建锁对象</span><br>    <span class="hljs-comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, template);</span><br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userId);<br>    <span class="hljs-comment">// 获取锁</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock();<br>    <span class="hljs-keyword">if</span> (!isLock) &#123;<br>        log.error(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        proxy.createVoucherOrder(voucherOrder);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-Redis消息队列"><a href="#6-Redis消息队列" class="headerlink" title="6. Redis消息队列"></a>6. Redis消息队列</h2><p>消息队列（Message Queue），字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p>Redis提供了三种不同的方式来实现消息队列：</p><ul><li>list结构：基于List结构模拟消息队列</li><li>PubSub：基本的点对点消息模型</li><li>Stream：比较完善的消息队列模型</li></ul><h3 id="6-1-基于List的消息队列"><a href="#6-1-基于List的消息队列" class="headerlink" title="6.1 基于List的消息队列"></a>6.1 基于List的消息队列</h3><p>Redis的list数据结构是一个双向链表，利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP实现。</p><p>当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p><p>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><h3 id="6-2-基于PubSub的消息队列"><a href="#6-2-基于PubSub的消息队列" class="headerlink" title="6.2 基于PubSub的消息队列"></a>6.2 基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。</p><ul><li>消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。<ul><li>SUBSCRIBE channel [channel] ：订阅一个或多个频道 </li><li>PUBLISH channel msg ：向一个频道发送消息 </li><li>PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</li></ul></li></ul><p>优点：采用发布订阅模型，支持多生产、多消费</p><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失</li></ul><h2 id="7-达人探店"><a href="#7-达人探店" class="headerlink" title="7. 达人探店"></a>7. 达人探店</h2><h3 id="7-1-发布探店笔记"><a href="#7-1-发布探店笔记" class="headerlink" title="7.1 发布探店笔记"></a>7.1 发布探店笔记</h3><p>笔记由图片与文字构成，因此需要两个接口：上传图片接口、发布笔记接口。先上传图片，然后点击发布按钮，完成发布。</p><p>上传图片接口：其中需要注意的是，需要修改SystemConstants类下的IMAGE_UPLOAD_DIR，修改为自己本地nginx或者云存储位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;upload&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UploadController</span> &#123;<br><br>    <span class="hljs-meta">@PostMapping(&quot;blog&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">uploadImage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取原始文件名称</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> image.getOriginalFilename();<br>            <span class="hljs-comment">// 生成新文件名</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> createNewFileName(originalFilename);<br>            <span class="hljs-comment">// 保存文件</span><br>            image.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));<br>            <span class="hljs-comment">// 返回结果</span><br>            log.debug(<span class="hljs-string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);<br>            <span class="hljs-keyword">return</span> Result.ok(fileName);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;文件上传失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>BlogController：完成发布笔记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/blog&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> IBlogService blogService;<br><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">saveBlog</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Blog blog)</span> &#123;<br>        <span class="hljs-comment">//获取登录用户</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>        blog.setUpdateTime(user.getId());<br>        <span class="hljs-comment">//保存探店博文</span><br>        blogService.saveBlog(blog);<br>        <span class="hljs-comment">//返回id</span><br>        <span class="hljs-keyword">return</span> Result.ok(blog.getId());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-2-查看探店笔记"><a href="#7-2-查看探店笔记" class="headerlink" title="7.2 查看探店笔记"></a>7.2 查看探店笔记</h3><p>BlogServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogById</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.查询blog</span><br>    <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> getById(id);<br>    <span class="hljs-keyword">if</span> (blog == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;笔记不存在！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 2.查询blog有关的用户</span><br>    queryBlogUser(blog);<br>    <span class="hljs-keyword">return</span> Result.ok(blog);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-3-点赞功能"><a href="#7-3-点赞功能" class="headerlink" title="7.3 点赞功能"></a>7.3 点赞功能</h3><p>初始时点赞代码位于BlogController的queryBlogLikes接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-comment">//修改点赞数量</span><br>    blogService.update().setSql(<span class="hljs-string">&quot;liked = liked +1 &quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>,id).update();<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><p>但是该代码会导致一个用户可以无限地为一篇笔记点赞，显然不符合实际的业务需求。</p><p>需求如下：</p><ol><li>同一个用户只能点赞一次，再次点击则取消点赞</li><li>如果当前用户已点赞，那么点赞按钮需要高亮显示</li></ol><p>实现步骤：</p><ol><li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li><li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1<ul><li>采用set集合可以对点赞用户进行去重，已点赞的用户存在于某笔记对应的set集合中，则不能再次点赞</li></ul></li><li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li><li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li></ol><p>代码实现：</p><p>修改BlogController对应的likeBlog接口方法，并重写该方法。具体逻辑见注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PutMapping(&quot;/like/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-comment">// 修改点赞数量</span><br>    <span class="hljs-keyword">return</span> blogService.likeBlog(id);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.获取登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 2.判断当前登录用户是否点赞</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">isMember</span> <span class="hljs-operator">=</span> template.opsForSet().isMember(key, userId.toString());<br>    <span class="hljs-keyword">if</span> (BooleanUtil.isFalse(isMember)) &#123;<br>        <span class="hljs-comment">// 3.如果未点赞</span><br>        <span class="hljs-comment">// 3.1 数据库点赞数+1</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>        <span class="hljs-comment">// 3.2 保存用户到Redis的set集合中</span><br>        <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>            template.opsForSet().add(key, userId.toString());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 4.如果已点赞</span><br>        <span class="hljs-comment">// 4.1 数据库点赞数-1</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>        <span class="hljs-comment">// 4.2 把用户从Redis的set集合中移除</span><br>        <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>            template.opsForSet().remove(key, userId.toString());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-4-点赞排行榜"><a href="#7-4-点赞排行榜" class="headerlink" title="7.4 点赞排行榜"></a>7.4 点赞排行榜</h3><p>功能需求为：在笔记的详情页面，将最先为笔记点赞的前N个人显示出来。</p><p>为满足此功能，我们需要统计每个人为笔记点赞的时间，然后按照该时间将set集合从小到大排序，取出前N个人。</p><p>Redis中的sortedSet可以满足此需求，用时间戳作为其的score属性，可完成时间排序。</p><p>代码实现：</p><ol><li><p>修改点赞的逻辑，即likeBlog方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.获取登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 2.判断当前登录用户是否点赞</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br>    <span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> template.opsForZSet().score(key, userId.toString());<br>    <span class="hljs-keyword">if</span> (score == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 3.如果未点赞</span><br>        <span class="hljs-comment">// 3.1 数据库点赞数+1</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>        <span class="hljs-comment">// 3.2 保存用户到Redis的zset集合中，根据点赞时间排序</span><br>        <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>            template.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 4.如果已点赞</span><br>        <span class="hljs-comment">// 4.1 数据库点赞数-1</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>        <span class="hljs-comment">// 4.2 把用户从Redis的zset集合中移除</span><br>        <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>            template.opsForZSet().remove(key, userId.toString());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改点赞列表查询的接口方法：queryBlogLikes</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-keyword">return</span> blogService.queryBlogLikes(id);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br>    <span class="hljs-comment">// 1.查询top5点赞用户</span><br>    Set&lt;String&gt; top5 = template.opsForZSet().range(key, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">if</span> (top5 == <span class="hljs-literal">null</span> || top5.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">// 2.解析出用户id</span><br>    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());<br>    <span class="hljs-type">String</span> <span class="hljs-variable">idStrs</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, ids);<br>    <span class="hljs-comment">// 3.根据用户id查询用户</span><br>    List&lt;UserDTO&gt; users = userService.query()<br>        .in(<span class="hljs-string">&quot;id&quot;</span>, ids)<br>        .last(<span class="hljs-string">&quot;ORDER BY FIELD(id,&quot;</span> + idStrs + <span class="hljs-string">&quot;)&quot;</span>).list()<br>        .stream()<br>        .map(u -&gt; BeanUtil.copyProperties(u, UserDTO.class))<br>        .collect(Collectors.toList());<br>    <span class="hljs-comment">// 4.返回</span><br>    <span class="hljs-keyword">return</span> Result.ok(users);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="8-好友关注"><a href="#8-好友关注" class="headerlink" title="8. 好友关注"></a>8. 好友关注</h2><h3 id="8-1-关注与取关"><a href="#8-1-关注与取关" class="headerlink" title="8.1 关注与取关"></a>8.1 关注与取关</h3><p>关注与被关注是存在于所有用户之间的，因此用一张额外的表 tb_follow 记录这一关系。</p><p>需要编写两个接口：关注取关、判断是否关注</p><p>代码实现：</p><p>FollowController，重写follow与isFollow方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//关注</span><br><span class="hljs-meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long followUserId, <span class="hljs-meta">@PathVariable(&quot;isFollow&quot;)</span> Boolean isFollow)</span> &#123;<br>    <span class="hljs-keyword">return</span> followService.follow(followUserId, isFollow);<br>&#125;<br><span class="hljs-comment">//取消关注</span><br><span class="hljs-meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long followUserId)</span> &#123;<br>      <span class="hljs-keyword">return</span> followService.isFollow(followUserId);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFollow)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-keyword">if</span> (isFollow) &#123;<br>        <span class="hljs-comment">// 1.关注则新增数据</span><br>        <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>        follow.setFollowUserId(followUserId);<br>        follow.setUserId(userId);<br>        save(follow);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 2.取关则删除数据</span><br>        remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Follow&gt;()<br>               .eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId));<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(Long followUserId)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 查询是否关注</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId).count();<br>    <span class="hljs-keyword">return</span> Result.ok(count &gt; <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-共同关注"><a href="#8-2-共同关注" class="headerlink" title="8.2 共同关注"></a>8.2 共同关注</h3><p>共同关注具体为：当前用户查看另外一个用户的主页时，可以查看共同关注，即当前用户与所查看用户的共同关注用户列表</p><p>通过set集合实现共同关注的功能：当调用follow接口关注某人时，可以将被关注的用户放入当前用户对应的一个set集合中，该set集合存储着所有被当前用户关注过的用户。</p><p>代码实现：</p><ol><li><p>修改follow接口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFollow)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span> + userId;<br>    <span class="hljs-keyword">if</span> (isFollow) &#123;<br>        <span class="hljs-comment">// 1.关注则新增数据</span><br>        <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>        follow.setFollowUserId(followUserId);<br>        follow.setUserId(userId);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">save</span> <span class="hljs-operator">=</span> save(follow);<br>        <span class="hljs-keyword">if</span> (save) &#123;<br>            <span class="hljs-comment">// 将关注用户的id放入redis的set集合中</span><br>            template.opsForSet().add(key, followUserId.toString());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 2.取关则删除数据</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">remove</span> <span class="hljs-operator">=</span> remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Follow&gt;()<br>                                .eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId));<br>        <span class="hljs-keyword">if</span> (remove) &#123;<br>            <span class="hljs-comment">// 将关注用户的id从redis的set集合中移除</span><br>            template.opsForSet().remove(key, followUserId.toString());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>查看共同关注，实现followCommons方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/common/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">followCommons</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-keyword">return</span> followService.followCommons(id);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">followCommons</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.获取当前登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span> + userId;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span> + id;<br>    <span class="hljs-comment">// 2.求交集</span><br>    Set&lt;String&gt; intersect = template.opsForSet().intersect(key, key2);<br>    <span class="hljs-keyword">if</span> (intersect == <span class="hljs-literal">null</span> || intersect.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">// 3.解析id集合</span><br>    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());<br>    <span class="hljs-comment">// 4.查询用户</span><br>    List&lt;UserDTO&gt; users = userService.listByIds(ids)<br>        .stream()<br>        .map(u -&gt; BeanUtil.copyProperties(u, UserDTO.class))<br>        .collect(Collectors.toList());<br>    <span class="hljs-keyword">return</span> Result.ok(users);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库及缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>Redis</tag>
      
      <tag>缓存</tag>
      
      <tag>秒杀</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC Solution 1668. Maximum Repeating Substring</title>
    <link href="/2022/11/03/LC-Solution-1668-Maximum-Repeating-Substring/"/>
    <url>/2022/11/03/LC-Solution-1668-Maximum-Repeating-Substring/</url>
    
    <content type="html"><![CDATA[<h1 id="1668-最大重复子字符串"><a href="#1668-最大重复子字符串" class="headerlink" title="1668. 最大重复子字符串"></a><a href="https://leetcode.cn/problems/maximum-repeating-substring/">1668. 最大重复子字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 <code>sequence</code> ，如果字符串 <code>word</code> 连续重复 <code>k</code> 次形成的字符串是 <code>sequence</code> 的一个子字符串，那么单词 <code>word</code> 的 <strong>重复值为 <code>k</code></strong> 。单词 <code>word</code> 的 <strong>最****大重复值</strong> 是单词 <code>word</code> 在 <code>sequence</code> 中最大的重复值。如果 <code>word</code> 不是 <code>sequence</code> 的子串，那么重复值 <code>k</code> 为 <code>0</code> 。</p><p>给你一个字符串 <code>sequence</code> 和 <code>word</code> ，请你返回 <strong>最大重复值 <code>k</code></strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：sequence = <span class="hljs-string">&quot;ababc&quot;</span>, <span class="hljs-built_in">word</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-string">&quot;abab&quot;</span> 是 <span class="hljs-string">&quot;ababc&quot;</span> 的子字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：sequence = <span class="hljs-string">&quot;ababc&quot;</span>, <span class="hljs-built_in">word</span> = <span class="hljs-string">&quot;ba&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：<span class="hljs-string">&quot;ba&quot;</span> 是 <span class="hljs-string">&quot;ababc&quot;</span> 的子字符串，但 <span class="hljs-string">&quot;baba&quot;</span> 不是 <span class="hljs-string">&quot;ababc&quot;</span> 的子字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：sequence = <span class="hljs-string">&quot;ababc&quot;</span>, <span class="hljs-built_in">word</span> = <span class="hljs-string">&quot;ac&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-string">&quot;ac&quot;</span> 不是 <span class="hljs-string">&quot;ababc&quot;</span> 的子字符串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= sequence.length &lt;= 100</code></li><li><code>1 &lt;= word.length &lt;= 100</code></li><li><code>sequence</code> 和 <code>word</code> 都只包含小写英文字母。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h3><p>题目要求当 <code>word</code> 重复出现 <code>k</code> 次时形成的字符串为 <code>sequence</code> 的子字符串。要求返回最大的 <code>k</code> 值。</p><p>我们可以假设理想情况下，即 <code>word</code> 重复 <code>k</code> 次之后与 <code>sequence</code> 相同。</p><p>不难得出：理想情况下，当 <code>k</code> 最大时，应当满足 <code>ceil(len(word) * k) == len(sequence)</code>。其中 <code>ceil</code> 表示向上取整。</p><p>因此，我们可以先通过 <code>len(sequence) // len(word)</code> 求得初始理论上最大的 <code>k</code>，然后循环递减 <code>k</code>，直到 <code>word</code> 重复 <code>k</code> 次后形成的字符串为 <code>sequence</code> 的子字符串</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python3">class Solution:<br>    def maxRepeating(self, sequence: str, word: str) -&gt; int:<br>        s_len, w_len = len(sequence), len(word)<br>        cnt = s_len // w_len<br>        while cnt:<br>            if sequence.find(word * cnt) != -1:<br>                return cnt<br>            cnt -= 1<br>        return 0<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxRepeating</span><span class="hljs-params">(String sequence, String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sLen</span> <span class="hljs-operator">=</span> sequence.length(), wLen = word.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> sLen / wLen;<br>        <span class="hljs-keyword">while</span>(cnt &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">repeatWord</span> <span class="hljs-operator">=</span> repeatK(word, cnt);<br>            <span class="hljs-keyword">if</span>(sequence.indexOf(repeatWord) != -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> cnt;<br>            &#125;<br>            cnt--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">repeatK</span><span class="hljs-params">(String word, <span class="hljs-type">int</span> cnt)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cnt; i++) &#123;<br>            sb.append(word);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxRepeating</span><span class="hljs-params">(sequence <span class="hljs-type">string</span>, word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sLen, wLen := <span class="hljs-built_in">len</span>(sequence), <span class="hljs-built_in">len</span>(word)<br>    cnt := sLen / wLen<br>    <span class="hljs-keyword">for</span> cnt &gt; <span class="hljs-number">0</span> &#123;<br>        repeatWord := repeatK(word, cnt)<br>        <span class="hljs-keyword">if</span> strings.Contains(sequence, repeatWord) &#123;<br>            <span class="hljs-keyword">return</span> cnt<br>        &#125;<br>        cnt--<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">repeatK</span><span class="hljs-params">(word <span class="hljs-type">string</span>, cnt <span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; cnt; i++ &#123;<br>        ans += word<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第34篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC Solution 1620. Coordinate With Maximum Network Quality</title>
    <link href="/2022/11/02/LC-Solution-1620-Coordinate-With-Maximum-Network-Quality/"/>
    <url>/2022/11/02/LC-Solution-1620-Coordinate-With-Maximum-Network-Quality/</url>
    
    <content type="html"><![CDATA[<h1 id="1620-网络信号最好的坐标"><a href="#1620-网络信号最好的坐标" class="headerlink" title="1620. 网络信号最好的坐标"></a><a href="https://leetcode.cn/problems/coordinate-with-maximum-network-quality/">1620. 网络信号最好的坐标</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个数组 <code>towers</code> 和一个整数 <code>radius</code> 。</p><p>数组 <code>towers</code> 中包含一些网络信号塔，其中 <code>towers[i] = [xi, yi, qi]</code> 表示第 <code>i</code> 个网络信号塔的坐标是 <code>(xi, yi)</code> 且信号强度参数为 <code>qi</code> 。所有坐标都是在 X-Y 坐标系内的 <strong>整数</strong> 坐标。两个坐标之间的距离用 <strong>欧几里得距离</strong> 计算。</p><p>整数 <code>radius</code> 表示一个塔 <strong>能到达</strong> 的 <strong>最远距离</strong> 。如果一个坐标跟塔的距离在 <code>radius</code> 以内，那么该塔的信号可以到达该坐标。在这个范围以外信号会很微弱，所以 <code>radius</code> 以外的距离该塔是 <strong>不能到达的</strong> 。</p><p>如果第 <code>i</code> 个塔能到达 <code>(x, y)</code> ，那么该塔在此处的信号为 <code>⌊qi / (1 + d)⌋</code> ，其中 <code>d</code> 是塔跟此坐标的距离。一个坐标的 <strong>信号强度</strong> 是所有 <strong>能到达</strong> 该坐标的塔的信号强度之和。</p><p>请你返回数组 <code>[cx, cy]</code> ，表示 <strong>信号强度</strong> 最大的 <strong>整数</strong> 坐标点 <code>(cx, cy)</code> 。如果有多个坐标网络信号一样大，请你返回字典序最小的 <strong>非负</strong> 坐标。</p><p><strong>注意：</strong></p><ul><li>坐标 <code>(x1, y1)</code> 字典序比另一个坐标 <code>(x2, y2)</code> 小，需满足以下条件之一：<ul><li>要么 <code>x1 &lt; x2</code> ，</li><li>要么 <code>x1 == x2</code> 且 <code>y1 &lt; y2</code> 。</li></ul></li><li><code>⌊val⌋</code> 表示小于等于 <code>val</code> 的最大整数（向下取整函数）。</li></ul><p>示例 1：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：towers = <span class="hljs-string">[[1,2,5],[2,1,7],[3,1,9]]</span>, radius = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>解释：<br>坐标 (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) 信号强度之和为 <span class="hljs-number">13</span><br>- 塔 (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) 强度参数为 <span class="hljs-number">7</span> ，在该点强度为 ⌊<span class="hljs-number">7</span> / (<span class="hljs-number">1</span> + <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">0</span>)⌋ = ⌊<span class="hljs-number">7</span>⌋ = <span class="hljs-number">7</span><br>- 塔 (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) 强度参数为 <span class="hljs-number">5</span> ，在该点强度为 ⌊<span class="hljs-number">5</span> / (<span class="hljs-number">1</span> + <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>)⌋ = ⌊<span class="hljs-number">2.07</span>⌋ = <span class="hljs-number">2</span><br>- 塔 (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>) 强度参数为 <span class="hljs-number">9</span> ，在该点强度为 ⌊<span class="hljs-number">9</span> / (<span class="hljs-number">1</span> + <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span>)⌋ = ⌊<span class="hljs-number">4.5</span>⌋ = <span class="hljs-number">4</span><br>没有别的坐标有更大的信号强度。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：towers = <span class="hljs-string">[[23,11,21]]</span>, radius = <span class="hljs-number">9</span><br>输出：[<span class="hljs-number">23</span>,<span class="hljs-number">11</span>]<br>解释：由于仅存在一座信号塔，所以塔的位置信号强度最大。<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：towers = <span class="hljs-comment">[<span class="hljs-comment">[1,2,13]</span>,<span class="hljs-comment">[2,1,7]</span>,<span class="hljs-comment">[0,1,9]</span>]</span>, radius = 2<br>输出：<span class="hljs-comment">[1,2]</span><br>解释：坐标 (1, 2) 的信号强度最大。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= towers.length &lt;= 50</code></li><li><code>towers[i].length == 3</code></li><li><code>0 &lt;= xi, yi, qi &lt;= 50</code></li><li><code>1 &lt;= radius &lt;= 50</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：枚举"><a href="#方法一：枚举" class="headerlink" title="方法一：枚举"></a>方法一：枚举</h3><p>题目要求找到一个坐标，使得该点到所有信号塔的信号强度之和最大。</p><p>题目给出的坐标范围最小为 <code>(0, 0)</code>，最大为 <code>(50, 50)</code>，而灯塔数量最多为50。即使采用三重 <code>for</code> 循环去遍历求解，计算次数也不会超过10e8，不存在TLE问题。因此选择枚举求解。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python3">class Solution:<br>    def bestCoordinate(self, towers: List[List[int]], radius: int) -&gt; List[int]:<br>        max_v = 0<br>        ans = [0, 0]<br>        for i in range(51):<br>            for j in range(51):<br>                cur = 0<br>                for x, y, q in towers:<br>                    d = ((x - i) ** 2 + (y - j) ** 2) ** 0.5<br>                    if d &lt;= radius:<br>                        cur += floor(q / (1 + d))<br>                if cur &gt; max_v:<br>                    ans = [i, j]<br>                    max_v = cur<br>        return ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] bestCoordinate(<span class="hljs-type">int</span>[][] towers, <span class="hljs-type">int</span> radius) &#123;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">50</span>; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] v : towers) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> v[<span class="hljs-number">0</span>], y = v[<span class="hljs-number">1</span>], q = v[<span class="hljs-number">2</span>];<br>                    <span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Math.sqrt((x - i) * (x - i) + (y - j) * (y - j));<br>                    <span class="hljs-keyword">if</span>(d &lt;= radius) &#123;<br>                        cur += (<span class="hljs-type">int</span>)(q / (<span class="hljs-number">1</span> + d));<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(max &lt; cur) &#123;<br>                    ans[<span class="hljs-number">0</span>] = i; ans[<span class="hljs-number">1</span>] = j;<br>                    max = cur;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bestCoordinate</span><span class="hljs-params">(towers [][]<span class="hljs-type">int</span>, radius <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    ans := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br>    max := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">50</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">50</span>; j++ &#123;<br>            cur := <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> towers &#123;<br>                x, y, q := v[<span class="hljs-number">0</span>], v[<span class="hljs-number">1</span>], v[<span class="hljs-number">2</span>]<br>                d := math.Sqrt(<span class="hljs-type">float64</span>((x - i) * (x - i) + (y - j) * (y - j)))<br>                <span class="hljs-keyword">if</span> d &lt;= <span class="hljs-type">float64</span>(radius) &#123;<br>                    cur += <span class="hljs-type">int</span>(<span class="hljs-type">float64</span>(q) / (<span class="hljs-number">1</span> + d))<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> cur &gt; max &#123;<br>                max = cur<br>                ans[<span class="hljs-number">0</span>] = i<br>                ans[<span class="hljs-number">1</span>] = j<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第33篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC Solution 784. Letter Case Permutation</title>
    <link href="/2022/10/30/LC-Solution-784-Letter-Case-Permutation/"/>
    <url>/2022/10/30/LC-Solution-784-Letter-Case-Permutation/</url>
    
    <content type="html"><![CDATA[<h1 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a><a href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 <code>s</code> ，通过将字符串 <code>s</code> 中的每个字母转变大小写，我们可以获得一个新的字符串。</p><p>返回 <em>所有可能得到的字符串集合</em> 。以 <strong>任意顺序</strong> 返回输出。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;a1b2&quot;</span><br>输出：[<span class="hljs-string">&quot;a1b2&quot;</span>, <span class="hljs-string">&quot;a1B2&quot;</span>, <span class="hljs-string">&quot;A1b2&quot;</span>, <span class="hljs-string">&quot;A1B2&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: s = <span class="hljs-string">&quot;3z4&quot;</span><br>输出: [<span class="hljs-string">&quot;3z4&quot;</span>,<span class="hljs-string">&quot;3Z4&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 12</code></li><li><code>s</code> 由小写英文字母、大写英文字母和数字组成</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h3><p>遇到全排列问题时，第一反应便是回溯解决。</p><p>题目要求遇到字母时，将其转换为大写或者小写字母，从而得到新的字符串。</p><p>从中可以想到，可以构造一个二叉树，二叉树的深度便是字符串 <code> s</code> 中字母的数量。每个父节点是当前的字母，其两个子节点对应下一个字母的大小写。</p><p>构造回溯方法，其包含三个参数，第一个参数为题目给定的字符串 <code>s</code>， 第二个参数为当前正在构造的字符串 <code>cur</code>，第三个参数记录下标位置。遍历到的字符若为数字，则跳到下一位置；若为字母，则分别对字母的大小写进行递归遍历。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCasePermutation</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">s, cur, begin</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cur) == <span class="hljs-built_in">len</span>(s):<br>                ans.append(cur)<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">if</span> s[begin].isalpha():<br>                traverse(s, cur + s[begin].swapcase(), begin + <span class="hljs-number">1</span>)<br>            traverse(s, cur + s[begin], begin + <span class="hljs-number">1</span>)<br>        ans = []<br>        traverse(s, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; ans;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCasePermutation</span><span class="hljs-params">(String s)</span> &#123;<br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        traverse(s, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(String s, String cur, <span class="hljs-type">int</span> begin)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s.length() == cur.length()) &#123;<br>            ans.add(cur);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        traverse(s, cur + s.charAt(begin), begin + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(Character.isLetter(s.charAt(begin))) &#123;<br>            traverse(s, cur + (<span class="hljs-type">char</span>)(s.charAt(begin) ^ <span class="hljs-number">32</span>), begin + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">letterCasePermutation</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(<span class="hljs-type">string</span>, <span class="hljs-type">string</span>, <span class="hljs-type">int</span>)</span></span><br>    f = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>, cur <span class="hljs-type">string</span>, begin <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-built_in">len</span>(cur) &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, cur)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        f(s, cur + <span class="hljs-type">string</span>(s[begin]), begin + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> unicode.IsLetter(<span class="hljs-type">rune</span>(s[begin])) &#123;<br>            f(s, cur + <span class="hljs-type">string</span>(s[begin] ^ <span class="hljs-number">32</span>), begin + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    f(s, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第32篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC Solution 915. Partition Array into Disjoint Intervals</title>
    <link href="/2022/10/24/LC-Solution-915-Partition-Array-into-Disjoint-Intervals/"/>
    <url>/2022/10/24/LC-Solution-915-Partition-Array-into-Disjoint-Intervals/</url>
    
    <content type="html"><![CDATA[<h1 id="915-分割数组"><a href="#915-分割数组" class="headerlink" title="915. 分割数组"></a><a href="https://leetcode.cn/problems/partition-array-into-disjoint-intervals/">915. 分割数组</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 <code>nums</code> ，将其划分为两个连续子数组 <code>left</code> 和 <code>right</code>， 使得：</p><ul><li><code>left</code> 中的每个元素都小于或等于 <code>right</code> 中的每个元素。</li><li><code>left</code> 和 <code>right</code> 都是非空的。</li><li><code>left</code> 的长度要尽可能小。</li></ul><p><em>在完成这样的分组后返回 <code>left</code> 的 <strong>长度</strong></em> 。</p><p>用例可以保证存在这样的划分方法。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,0,3,8,6]</span><br>输出：3<br>解释：left = <span class="hljs-comment">[5,0,3]</span>，right = <span class="hljs-comment">[8,6]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,1,0,6,12]</span><br>输出：4<br>解释：left = <span class="hljs-comment">[1,1,1,0]</span>，right = <span class="hljs-comment">[6,12]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 106</code></li><li>可以保证至少有一种方法能够按题目所描述的那样对 <code>nums</code> 进行划分。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案一：前缀与后缀"><a href="#方案一：前缀与后缀" class="headerlink" title="方案一：前缀与后缀"></a>方案一：前缀与后缀</h3><p>分析题意，核心思想就是找出分界点，且该分界点满足：<strong>左侧子数组的最大值</strong> 小于等于 <strong>右侧子数组的最小值</strong></p><p>而且根据题目数据量 <code>10e5</code> 可知，无法使用O(n2)复杂度的算法即暴力解法。</p><p>据此便想到：两次遍历统计前缀子数组的最大值与后缀子数组的最小值，分别记录在两个数组中。最后再遍历一次统计好的数组，找出分界点。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partitionDisjoint</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:    <br>        n = <span class="hljs-built_in">len</span>(nums)<br>        min_nums, max_nums = [<span class="hljs-number">0</span>] * n, [<span class="hljs-number">0</span>] * n <span class="hljs-comment"># 初始化前后缀数组</span><br>        min_num, max_num = <span class="hljs-number">10</span> ** <span class="hljs-number">7</span>, -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            max_num = <span class="hljs-built_in">max</span>(nums[i], max_num)<br>            max_nums[i] = max_num<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            min_num = <span class="hljs-built_in">min</span>(nums[i], min_num)<br>            min_nums[i] = min_num<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># 小于等于的情况下，找到第一个满足的分界点，题目要求left尽可能小，于是直接返回</span><br>            <span class="hljs-keyword">if</span> max_nums[i] &lt;= min_nums[i + <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partitionDisjoint</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] minNums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], maxNums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minNum</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE, maxNum = Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            maxNum = Math.max(nums[i], maxNum);<br>            maxNums[i] = maxNum;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            minNum = Math.min(nums[i], minNum);<br>            minNums[i] = minNum;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(maxNums[i] &lt;= minNums[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partitionDisjoint</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    minNums, maxNums := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n), <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    minNum, maxNum := math.MaxInt32, <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] &gt; maxNum &#123;<br>            maxNum = nums[i]<br>        &#125;<br>        maxNums[i] = maxNum<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> nums[i] &lt; minNum &#123;<br>            minNum = nums[i]<br>        &#125;<br>        minNums[i] = minNum<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> maxNums[i] &lt;= minNums[i + <span class="hljs-number">1</span>] &#123;<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方案二：优化前缀与后缀"><a href="#方案二：优化前缀与后缀" class="headerlink" title="方案二：优化前缀与后缀"></a>方案二：优化前缀与后缀</h3><p>我们可以在第一次遍历的时候，统计后缀子数组的最小值，将其保存在一个数组中。</p><p>第二次从前向后遍历，一边保存当前前缀子数组的最大值，一边判断并寻找分界点。</p><p>优化之后，时间效率上可以提升25%左右。</p><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partitionDisjoint</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:    <br>        n = <span class="hljs-built_in">len</span>(nums)<br>        min_nums = [<span class="hljs-number">0</span>] * n<br>        min_num, max_num = <span class="hljs-number">10</span> ** <span class="hljs-number">7</span>, -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            min_num = <span class="hljs-built_in">min</span>(nums[i], min_num)<br>            min_nums[i] = min_num<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>            max_num = <span class="hljs-built_in">max</span>(nums[i], max_num)<br>            <span class="hljs-keyword">if</span> max_num &lt;= min_nums[i + <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partitionDisjoint</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] minNums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minNum</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE, maxNum = Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            minNum = Math.min(nums[i], minNum);<br>            minNums[i] = minNum;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            maxNum = Math.max(nums[i], maxNum);<br>            <span class="hljs-keyword">if</span>(maxNum &lt;= minNums[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partitionDisjoint</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    minNums := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    minNum, maxNum := math.MaxInt32, <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> nums[i] &lt; minNum &#123;<br>            minNum = nums[i]<br>        &#125;<br>        minNums[i] = minNum<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] &gt; maxNum &#123;<br>            maxNum = nums[i]<br>        &#125;<br>        <span class="hljs-keyword">if</span> maxNum &lt;= minNums[i + <span class="hljs-number">1</span>] &#123;<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第31篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC Solution 1768. Merge Strings Alternately</title>
    <link href="/2022/10/23/LC-Solution-1768-Merge-Strings-Alternately/"/>
    <url>/2022/10/23/LC-Solution-1768-Merge-Strings-Alternately/</url>
    
    <content type="html"><![CDATA[<h1 id="1768-交替合并字符串"><a href="#1768-交替合并字符串" class="headerlink" title="1768. 交替合并字符串"></a><a href="https://leetcode.cn/problems/merge-strings-alternately/">1768. 交替合并字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个字符串 <code>word1</code> 和 <code>word2</code> 。请你从 <code>word1</code> 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。</p><p>返回 <strong>合并后的字符串</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：word1 = <span class="hljs-string">&quot;abc&quot;</span>, word2 = <span class="hljs-string">&quot;pqr&quot;</span><br>输出：<span class="hljs-string">&quot;apbqcr&quot;</span><br>解释：字符串合并情况如下所示：<br>word1：  <span class="hljs-selector-tag">a</span>   <span class="hljs-selector-tag">b</span>   c<br>word2：    <span class="hljs-selector-tag">p</span>   <span class="hljs-selector-tag">q</span>   r<br>合并后：  <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">q</span> c r<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：word1 = <span class="hljs-string">&quot;ab&quot;</span>, word2 = <span class="hljs-string">&quot;pqrs&quot;</span><br>输出：<span class="hljs-string">&quot;apbqrs&quot;</span><br>解释：注意，word2 比 word1 长，<span class="hljs-string">&quot;rs&quot;</span> 需要追加到合并后字符串的末尾。<br>word1：  <span class="hljs-selector-tag">a</span>   <span class="hljs-selector-tag">b</span> <br>word2：    <span class="hljs-selector-tag">p</span>   <span class="hljs-selector-tag">q</span>   r   s<br>合并后：  <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">q</span>   r   s<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：word1 = <span class="hljs-string">&quot;abcd&quot;</span>, word2 = <span class="hljs-string">&quot;pq&quot;</span><br>输出：<span class="hljs-string">&quot;apbqcd&quot;</span><br>解释：注意，word1 比 word2 长，<span class="hljs-string">&quot;cd&quot;</span> 需要追加到合并后字符串的末尾。<br>word1：  <span class="hljs-selector-tag">a</span>   <span class="hljs-selector-tag">b</span>   c   d<br>word2：    <span class="hljs-selector-tag">p</span>   <span class="hljs-selector-tag">q</span> <br>合并后：  <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">q</span> c   d<br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：简单模拟"><a href="#方法一：简单模拟" class="headerlink" title="方法一：简单模拟"></a>方法一：简单模拟</h3><p>根据题意，从 <code>word1</code> 与 <code>word2</code> 中获取每一位字符，拼接到结果字符串中。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><p>普通解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeAlternately</span>(<span class="hljs-params">self, word1: <span class="hljs-built_in">str</span>, word2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        ans = []<br>        n = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">len</span>(word1), <span class="hljs-built_in">len</span>(word2))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            ans.append(word1[i])<br>            ans.append(word2[i])<br>        ans = <span class="hljs-string">&quot;&quot;</span>.join(ans)<br>        <span class="hljs-keyword">return</span> ans + word1[n:] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(word1) &gt; <span class="hljs-built_in">len</span>(word2) <span class="hljs-keyword">else</span> ans + word2[n:]<br></code></pre></td></tr></table></figure><p>一行解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeAlternately</span>(<span class="hljs-params">self, word1: <span class="hljs-built_in">str</span>, word2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(a + b <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> zip_longest(word1, word2, fillvalue=<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">mergeAlternately</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> word1.length(), n2 = word2.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n1 || i &lt; n2; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i &lt; n1) ans.append(word1.charAt(i));<br>            <span class="hljs-keyword">if</span>(i &lt; n2) ans.append(word2.charAt(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeAlternately</span><span class="hljs-params">(word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">0</span>)<br>    n1, n2 := <span class="hljs-built_in">len</span>(word1), <span class="hljs-built_in">len</span>(word2)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n1 || i &lt; n2; i++ &#123;<br>        <span class="hljs-keyword">if</span> i &lt; n1 &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, word1[i])<br>        &#125;<br>        <span class="hljs-keyword">if</span> i &lt; n2 &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, word2[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(ans)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第30篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解JDK锁02:AQS</title>
    <link href="/2022/10/21/%E8%AF%A6%E8%A7%A3JDK%E9%94%8102%EF%BC%9AAQS/"/>
    <url>/2022/10/21/%E8%AF%A6%E8%A7%A3JDK%E9%94%8102%EF%BC%9AAQS/</url>
    
    <content type="html"><![CDATA[<h1 id="详解JDK锁02：AQS"><a href="#详解JDK锁02：AQS" class="headerlink" title="详解JDK锁02：AQS"></a>详解JDK锁02：AQS</h1><h2 id="1-AQS简述"><a href="#1-AQS简述" class="headerlink" title="1.  AQS简述"></a>1.  AQS简述</h2><p>这一部分，我将从是什么、干什么、怎么用三个角度简单讲述一下AQS</p><h3 id="1-1-是什么？"><a href="#1-1-是什么？" class="headerlink" title="1.1 是什么？"></a>1.1 是什么？</h3><p>AQS全称为AbstractQueuedSynchronizer，中文名称为队列同步器。</p><p>拆分一下中文就可知，一定离不开 <strong>队列</strong> 与 <strong>同步</strong> 这两个概念，下面进一步讲解其作用。</p><h3 id="1-2-干什么？"><a href="#1-2-干什么？" class="headerlink" title="1.2 干什么？"></a>1.2 干什么？</h3><p>AQS是用来构建锁或者其他同步组件的基础框架。</p><p>学Java并发的话就重点关住于AQS是如何构建锁的，因为同步器是实现锁的关键！</p><ol><li><p>AQS用一个 <code>int</code> 成员变量来表示同步状态。通过修改同步状态，以此达到获取锁与释放锁的目的。</p><p>比如说一个线程获取到了锁，那么就相当于它此时获取到了同步状态。</p><p>一个线程执行完了它的任务，它去释放锁，就相当于释放同步状态。</p></li><li><p>AQS通过内置的 <code>FIFO队列</code> 完成线程的排队工作。</p><p>这一点其实并不难理解。当一个线程获取锁失败之后，可以选择陷入阻塞状态，也可以进行非阻塞地自旋重试；当有多个线程独占式地去获取锁时，只有一个线程可以获取成功，其它均会失败。那么应当如何管理这些竞争失败的锁呢？这便是队列的作用。</p><ul><li>线程获取锁失败时，便进行入队列操作，成为队列的尾结点，进入等待状态</li></ul></li></ol><h3 id="1-3-怎么用？"><a href="#1-3-怎么用？" class="headerlink" title="1.3 怎么用？"></a>1.3 怎么用？</h3><p>AQS的实现方式是继承：子类通过继承同步器并实现它的抽象方法来管理同步状态。</p><p>AQS支持独占式地获取同步状态与共享式地获取同步状态</p><p>其实AQS的精髓就在于它简化了锁的实现方式，我们不需要关心同步状态管理、线程排队、等待与唤醒等底层操作逻辑，我们只需要将精力放在锁的核心功能：加锁与解锁。</p><p>可以这样理解：</p><ul><li>锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节</li><li>AQS是面向锁的实现者，它定义了锁的实现者与同步器交互的接口，隐藏了实现细节</li></ul><p>之后会写一个实战案例去用AQS实现一个锁。</p><h2 id="2-AQS方法简述"><a href="#2-AQS方法简述" class="headerlink" title="2. AQS方法简述"></a>2. AQS方法简述</h2><p>下面三个方法是用于管理同步状态</p><ol><li><code>getState()</code>：用于获取同步状态</li><li><code>setState(int newState)</code>：用于设置同步状态</li><li><code>compareAndSetState(int expect, int update)</code>：使用CAS设置同步状态，保证原子性</li></ol><p>之前第一部分提到：AQS已经帮我们实现了队列的维护逻辑，我们实现锁时只需要重写获取锁的方法</p><ol><li><code>tryAcquire(int arg)</code>：独占式地获取同步状态，返回值为布尔类型，true为获取成功，false为获取失败。</li><li><code>tryRelease(int arg)</code>：独占式地释放同步状态，返回值为布尔类型，true为释放成功，false为释放失败。</li><li><code>tryAcquireShared(int arg)</code>：共享式地获取同步状态，返回值为int类型。<ul><li>返回0表示成功，且没有剩余资源</li><li>返回大于0的值表示成功，仍有剩余资源</li><li>返回负数代表获取失败</li></ul></li><li><code>tryReleaseShared(int arg)</code>：共享式地释放同步状态，返回值为布尔类型。<ul><li>如果释放后允许唤醒后续等待节点时，返回true；否则返回false</li></ul></li><li><code>isHeldExclusively()</code>：当前同步器是否被线程独占</li></ol><p>通过对于这些方法进行简单理解，便能初步体会到：</p><ul><li><p>当同步状态state为0时，其他线程才有可能获取到同步状态，即获取到锁。</p></li><li><p>对于可重入锁，当线程独占锁之后，会将同步状态state进行自增。如果该线程一直重复地获取该锁，则state会一直累加；该线程去释放该锁时，必须将state自减到0，才算是完全释放成功。</p></li></ul><h2 id="3-AQS实战案例"><a href="#3-AQS实战案例" class="headerlink" title="3. AQS实战案例"></a>3. AQS实战案例</h2><p>通过使用AQS，简单地实现一个独占不可重入锁，也就是说该锁的state只有0与1两种状态。</p><p>重点关注继承自AQS的Sync内部类，这里面自定义了获取同步状态与释放同步状态的核心逻辑。</p><p>这个案例印证了这句话：AQS是面向锁的实现者，它定义了锁的实现者与同步器交互的接口，隐藏了实现细节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExclusiveLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            <span class="hljs-comment">// 当通过CAS设置state为1时，代表加锁成功</span><br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span> ,<span class="hljs-number">1</span>)) &#123;<br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            <span class="hljs-comment">// 释放锁时如果发现该锁已被释放，说明有异常</span><br>            <span class="hljs-keyword">if</span> (getState() == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            setState(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 当state==1时表示处于占用状态</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.newCondition();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-AQS源码详解"><a href="#4-AQS源码详解" class="headerlink" title="4. AQS源码详解"></a>4. AQS源码详解</h2><h3 id="4-1-同步队列"><a href="#4-1-同步队列" class="headerlink" title="4.1 同步队列"></a>4.1 同步队列</h3><p>之前提到，同步器通过同步队列实现了对于线程与同步状态的管理。</p><p>进一步解释：</p><ol><li>当当前线程获取同步状态（锁）失败时，同步器会将当前线程构造为一个节点Node，并加入到同步队列中，阻塞当前线程</li><li>当同步状态（锁）被释放后，会将队列首节点线程唤醒，然后使该线程再次去尝试获取同步状态</li></ol><p>如下图所示：<code>head</code> 指向当前队列的头节点，其已获取到同步状态（锁）。</p><p>获取同步状态失败的节点，会将其依次添加到队列中，<code>tail</code> 维护尾节点。</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221017231708935.png" alt="image-20221017231708935"></p><p>队列节点状态：</p><ol><li>CANCELLED(1)：值为1，表示当前节点由于等待超时或被中断，需要取消等待，节点进入该状态后将不会再变化。</li><li>SIGNAL(-1)：值为-1，表示后继节点线程处于等待状态，等待当前节点唤醒。</li><li>CONDITION(-2)：值为-2，表示节点等待在Condition上，如果其他线程对Condition调用了signal方法后，CONDITION状态的节点会从等待队列转移到同步队列中。</li><li>PROPAGATE(-3)：值为-3，共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li><li>INITIAL(0)：值为0，代表初始状态</li></ol><p>观察节点状态发现：负值表示处于有效等待状态，而正值表示节点已被取消。</p><h3 id="4-2-独占式获取"><a href="#4-2-独占式获取" class="headerlink" title="4.2 独占式获取"></a>4.2 独占式获取</h3><p>核心方法为 <code>acquire()</code> ，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>而该方法又由 <code>tryAcquire</code> 、 <code>acquireQueued</code> 与 <code>addWaiter</code>  三个方法组成。</p><p>这里先给出该方法的执行流程：</p><ol><li>调用 <code>tryAcquire</code> 方法尝试去获取同步状态，其返回值为boolean类型：<ul><li>若返回True，代表获取同步状态成功。而其取反后，为False，该方法便到此为止了，直接返回</li><li>若返回False，代表获取同步状态失败，取反后为True，则需要进一步执行之后的方法</li></ul></li><li><code>tryAcquire</code> 返回False之后，继续执行 <code>addWaiter</code> 方法，构造同步节点，并通过该方法，将构造好的Node节点以独占模式加入到队列的尾部</li><li><code>acquireQueued</code> 方法使得该节点以死循环方式获取同步状态，一直到获取到才返回<ul><li>如果在死循环的过程中被中断过，则返回True，否则返回False</li></ul></li><li>如果线程节点在等待过程中被中断，是不会响应的。只有等到获取到同步状态后，才会执行 <code>selfInterrupt</code> 方法</li></ol><p>接着，一起来看一看这三个核心方法的源码</p><ul><li><p><code>tryAcquire</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个核心方法竟然只有一行代码，而且是抛出异常的代码。如果只看源码，确实很让人疑惑。</p><p>但是结合之前第一部分的内容以及实战案例：我们在实现一个锁时，需要在锁的内部创建一个内部类，并让其继承AQS，重写AQS中的核心方法。而这些核心方法中就包括 <code>tryAcquire</code>。这个获取同步状态（锁）的逻辑需要我们自己实现。</p><p>这也就进一步解释了：AQS简化了锁的实现方式，我们不需要关心同步状态管理、线程排队、等待与唤醒等底层操作逻辑，我们只需要将精力放在锁的核心功能加锁与解锁。</p></li><li><p><code>addWaiter</code>：直接看注释</p><p>其中if块中执行的内容就是将当前节点添加队列尾部</p><ul><li><p>注意需要使用 <code>compareAndSetTail</code> 方法来确保节点以线程安全的方式被添加到尾部。</p><p>如果仅使用简单的LinkedList来处理节点关系，则会导致多个线程并发地被添加到链表中，造成节点数量和顺序混乱。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">// 将当前线程构造为同步队列中的节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// 获取尾结点，tail为AQS类的成员变量</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-comment">// 若尾节点不为空</span><br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 将当前节点的prev设为尾结点</span><br>        node.prev = pred;<br>        <span class="hljs-comment">// 将当前节点设置为新的尾结点</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            <span class="hljs-comment">// 将旧的尾结点的next设为当前节点</span><br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 若尾节点为空，则调用enq自旋进行入队列操作</span><br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>enq</code>：直接看注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-comment">// 这是一种自旋方式。一直自旋，直到Node被添加到队尾</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 获取当前队列的尾结点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果tail为空，表示队列为空，需要新创建一个空节点作为head与tail节点</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果tail不为空，说明队列中存在线程节点，进行入队列操作</span><br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是：当 <code>addWaiter</code> 中尾结点为空时，又调用了 <code>enq</code> 方法以自旋方式添加节点，这样可以保证节点被添加成功</p></li></ul></li><li><p><code>acquireQueued</code>：直接看注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// failed表示是否获取同步状态（锁）失败</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// interrupted表示在获取过程中是否被打断</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 通过node.predecessor()拿到其前驱节点</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// 如果前驱节点为头节点head，代表当前节点可以尝试去获取同步状态（锁）</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">// 如果获取成功，则当前节点成为新的头节点head</span><br>            <span class="hljs-comment">// setHead方法会将当前节点的prev设置为null</span><br>                setHead(node);<br>                <span class="hljs-comment">// 将旧的头节点的next设置为null，有助于gc回收旧的head节点</span><br>                p.next = <span class="hljs-literal">null</span>; <br>                <span class="hljs-comment">// 代表成功获取到同步状态（锁）</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">// 返回是否被中断</span><br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 如果当前线程节点可以休息，那就进入等待状态，直至被unpark</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-comment">// 如果等待过程被中断，则标记为true</span><br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 如果等待过程中没有成功获取到同步状态（被中断或超时），则将该线程节点设置为CANCELLED状态</span><br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>shouldParkAfterFailedAcquire：该方法用于检查状态，判断当前线程节点的前驱节点是否仍然有效。看注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>    <span class="hljs-comment">// 前驱节点状态有效，返回true，当前线程节点便可进入等待状态，等待唤醒</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 前驱节点状态大于0，说明无效。</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// while循环继续寻找前驱节点之前的有效节点</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 将当前线程节点排到有效节点的后面</span><br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果前驱节点有效，将其状态以CAS方式设置为SIGNAL，以便于释放同步状态后通知当前线程节点</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-comment">// 返回false，在acquireQueued方法内继续自旋检查状态</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>parkAndCheckInterrupt：该方法用于进入等待状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4-3-独占式释放"><a href="#4-3-独占式释放" class="headerlink" title="4.3 独占式释放"></a>4.3 独占式释放</h3><p>release方法用于释放同步状态，并且会唤醒当前线程节点的后继节点，使得后继节点尝试去获取同步状态。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 唤醒后继节点</span><br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>其中tryRelease的设计模式与tryAcquire一样，均需要我们自己去实现</p></li><li><p>unparkSuccessor：唤醒后继节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// node为当前线程节点，获取其状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-comment">// 如果状态小于0，需要将其置为0（从有效到无效），该过程允许失败</span><br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 获取当前节点的后继节点，一般节点不为空且有效</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-comment">// 但如果该节点为空或无效（处于CANCELLED状态），则需要找到有效节点</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-4-共享式获取"><a href="#4-4-共享式获取" class="headerlink" title="4.4 共享式获取"></a>4.4 共享式获取</h3><p>先来看看共享式与独占式地获取同步状态的区别：</p><ul><li>在同一时刻，共享式获取允许多个线程同时获取到同步状态，而独占式则只有一个线程可以获取到，其他线程均阻塞</li></ul><p>共享式获取的一个经典应用便是Semaphore，其作用为控制同时访问某一特定资源的线程数量。</p><p>因此，在接下来的解释中，用 <code>资源</code> 代替 <code>同步状态</code>。</p><p>调用acquireShared方法共享式地获取资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中tryAcquireShared需要我们自己去手动实现，但是返回结果类型已经被定义好了：</p><ul><li>返回负数时，代表获取失败，剩余资源不足</li><li>返回非负数时，代表获取成功。如果为0，说明已没有剩余资源了；如果为正数，则代表还有剩余资源。</li></ul><p>当为负数时，需要调用doAcquireShared方法，进入等待队列，直到获取到资源时才返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 将当前线程节点添加到队列尾部</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 自旋重复尝试获取资源</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// 当前线程节点的前驱节点为头节点时</span><br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-comment">// 再次尝试获取资源</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-comment">// 资源数大于等于0，说明获取成功</span><br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 设置头节点，若r &gt; 0即还有剩余资源，则唤醒之后的线程节点</span><br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt();<br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-共享式释放"><a href="#4-5-共享式释放" class="headerlink" title="4.5 共享式释放"></a>4.5 共享式释放</h3><p>共享式释放会调用releaseShared方法，释放指定数量的资源。其中tryReleaseShared方法仍然需要我们自己去实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中doReleaseShared方法主要用于释放完资源后，去唤醒后续处于等待状态的各个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 通过循环与CAS操作确保资源被线程安全地释放</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-写在后面"><a href="#5-写在后面" class="headerlink" title="5. 写在后面"></a>5. 写在后面</h2><p>参考文献：</p><blockquote><ol><li><p>JDK5.0源码</p></li><li><p>《Java并发编程的艺术》</p></li><li><p><a href="https://www.bilibili.com/video/BV16J411h7Rd/?spm_id_from=333.337.search-card.all.click&vd_source=4e7654633e4719c03a8fb6c6b524ddc2">黑马Java并发编程教程</a></p></li></ol></blockquote><p>这个系列大概会有5篇左右的样子，我尽可能把自己对于JUC的理解通俗易懂地写出来</p><p>但如果有错误的地方，请大家指出来，我会及时去学习与改进~</p><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
      <tag>Java</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 901. Online Stock Span</title>
    <link href="/2022/10/21/LC-Solution-901-Online-Stock-Span/"/>
    <url>/2022/10/21/LC-Solution-901-Online-Stock-Span/</url>
    
    <content type="html"><![CDATA[<h1 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901. 股票价格跨度"></a><a href="https://leetcode.cn/problems/online-stock-span/">901. 股票价格跨度</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个 <code>StockSpanner</code> 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。</p><p>今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p><p>例如，如果未来7天股票的价格是 <code>[100, 80, 60, 70, 60, 75, 85]</code>，那么股票跨度将是 <code>[1, 1, 1, 2, 1, 4, 6]</code>。</p><p><strong>示例：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;StockSpanner&quot;</span>,<span class="hljs-string">&quot;next&quot;</span>,<span class="hljs-string">&quot;next&quot;</span>,<span class="hljs-string">&quot;next&quot;</span>,<span class="hljs-string">&quot;next&quot;</span>,<span class="hljs-string">&quot;next&quot;</span>,<span class="hljs-string">&quot;next&quot;</span>,<span class="hljs-string">&quot;next&quot;</span>]</span>, <span class="hljs-selector-attr">[[]</span>,<span class="hljs-selector-attr">[100]</span>,<span class="hljs-selector-attr">[80]</span>,<span class="hljs-selector-attr">[60]</span>,<span class="hljs-selector-attr">[70]</span>,<span class="hljs-selector-attr">[60]</span>,<span class="hljs-selector-attr">[75]</span>,<span class="hljs-selector-attr">[85]</span>]<br>输出：<span class="hljs-selector-attr">[null,1,1,1,2,1,4,6]</span><br>解释：<br>首先，初始化 S = <span class="hljs-built_in">StockSpanner</span>()，然后：<br>S<span class="hljs-selector-class">.next</span>(<span class="hljs-number">100</span>) 被调用并返回 <span class="hljs-number">1</span>，<br>S<span class="hljs-selector-class">.next</span>(<span class="hljs-number">80</span>) 被调用并返回 <span class="hljs-number">1</span>，<br>S<span class="hljs-selector-class">.next</span>(<span class="hljs-number">60</span>) 被调用并返回 <span class="hljs-number">1</span>，<br>S<span class="hljs-selector-class">.next</span>(<span class="hljs-number">70</span>) 被调用并返回 <span class="hljs-number">2</span>，<br>S<span class="hljs-selector-class">.next</span>(<span class="hljs-number">60</span>) 被调用并返回 <span class="hljs-number">1</span>，<br>S<span class="hljs-selector-class">.next</span>(<span class="hljs-number">75</span>) 被调用并返回 <span class="hljs-number">4</span>，<br>S<span class="hljs-selector-class">.next</span>(<span class="hljs-number">85</span>) 被调用并返回 <span class="hljs-number">6</span>。<br><br>注意 (例如) S<span class="hljs-selector-class">.next</span>(<span class="hljs-number">75</span>) 返回 <span class="hljs-number">4</span>，因为截至今天的最后 <span class="hljs-number">4</span> 个价格<br>(包括今天的价格 <span class="hljs-number">75</span>) 小于或等于今天的价格。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>调用 <code>StockSpanner.next(int price)</code> 时，将有 <code>1 &lt;= price &lt;= 10^5</code>。</li><li>每个测试用例最多可以调用 <code>10000</code> 次 <code>StockSpanner.next</code>。</li><li>在所有测试用例中，最多调用 <code>150000</code> 次 <code>StockSpanner.next</code>。</li><li>此问题的总时间限制减少了 50%。</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：单调栈"><a href="#方法一：单调栈" class="headerlink" title="方法一：单调栈"></a>方法一：单调栈</h3><p>题目要求我们返回比不超过当前股票价格的最大连续天数：进一步分析可知，我们只要找到之前第一个大于当前股票价格的下标，两个天数对应的下标相减，便是答案。</p><p>因此我们可以运用单调栈，按照股票的价格以降序入栈。</p><p>每个单调栈中存放形如 <code>[prices, days]</code>这样的数组：</p><ul><li>prices：当前股票的价格</li><li>days：股票价格的跨度（即在此之前，不超过当前股票价格的最大连续天数）</li></ul><p>next方法被调用时，我们便进行入栈操作。在入栈之前，我们需要循环判断当前栈顶元素的 <code>price</code> 是否小于等于当前股票的 <code>price</code>:</p><ul><li>若小于等于，则对栈顶元素进行出栈，并且将栈顶元素的 <code>days</code> 累加到当前股票的 <code>days</code> 上</li></ul><p>循环判断完毕后，当前股票的 <code>price</code> 为最小股票价格，满足单调递减，即可入栈。并将当前股票对应的 <code>days</code> 返回。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python3">class StockSpanner:<br>    def __init__(self):<br>        self.stack = []<br><br>    def next(self, price: int) -&gt; int:<br>        stack = self.stack<br>        days = 1 # days要初始化为1，因为最大连续天数中包含其自身<br>        while stack and stack[-1][0] &lt;= price:<br>            days += stack[-1][1]<br>            stack.pop(-1)<br>        stack.append([price, days])<br>        return days<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StockSpanner</span> &#123;<br>    Deque&lt;<span class="hljs-type">int</span>[]&gt; d;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StockSpanner</span><span class="hljs-params">()</span> &#123;<br>        d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">(<span class="hljs-type">int</span> price)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">days</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// days要初始化为1，因为最大连续天数中包含其自身</span><br>        <span class="hljs-keyword">while</span> (!d.isEmpty() &amp;&amp; d.peekLast()[<span class="hljs-number">0</span>] &lt;= price) &#123;<br>            days += d.pollLast()[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;price, days&#125;;<br>        d.addLast(arr);<br>        <span class="hljs-keyword">return</span> days;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StockSpanner <span class="hljs-keyword">struct</span> &#123;<br>    stack [][<span class="hljs-number">2</span>] <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> StockSpanner &#123;<br>    <span class="hljs-keyword">return</span> StockSpanner&#123;[][<span class="hljs-number">2</span>] <span class="hljs-type">int</span> &#123;&#125;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *StockSpanner)</span></span> Next(price <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    days := <span class="hljs-number">1</span> <span class="hljs-comment">// days要初始化为1，因为最大连续天数中包含其自身</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.stack) &gt; <span class="hljs-number">0</span> &amp;&amp; price &gt;= this.stack[<span class="hljs-built_in">len</span>(this.stack) - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &#123;<br>        days += this.stack[<span class="hljs-built_in">len</span>(this.stack) - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<br>        this.stack = this.stack[:<span class="hljs-built_in">len</span>(this.stack) - <span class="hljs-number">1</span>]<br>    &#125;<br>    this.stack = <span class="hljs-built_in">append</span>(this.stack, [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;price, days&#125;)<br>    <span class="hljs-keyword">return</span> days<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第29篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 779. K-th Symbol in Grammar</title>
    <link href="/2022/10/20/LC-Solution-779-K-th-Symbol-in-Grammar/"/>
    <url>/2022/10/20/LC-Solution-779-K-th-Symbol-in-Grammar/</url>
    
    <content type="html"><![CDATA[<h1 id="779-K-th-Symbol-in-Grammar"><a href="#779-K-th-Symbol-in-Grammar" class="headerlink" title="779. K-th Symbol in Grammar"></a><a href="https://leetcode.cn/problems/k-th-symbol-in-grammar/">779. K-th Symbol in Grammar</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们构建了一个包含 <code>n</code> 行( <strong>索引从 1 开始</strong> )的表。首先在第一行我们写上一个 <code>0</code>。接下来的每一行，将前一行中的<code>0</code>替换为<code>01</code>，<code>1</code>替换为<code>10</code>。</p><ul><li>例如，对于 <code>n = 3</code> ，第 <code>1</code> 行是 <code>0</code> ，第 <code>2</code> 行是 <code>01</code> ，第3行是 <code>0110</code> 。</li></ul><p>给定行数 <code>n</code> 和序数 <code>k</code>，返回第 <code>n</code> 行中第 <code>k</code> 个字符。（ <code>k</code> <strong>从索引 1 开始</strong>）</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 1, k = 1</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 第一行：0</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 2, k = 1</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: </span><br><span class="hljs-section">第一行: 0 </span><br><span class="hljs-section">第二行: 01</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 2, k = 2</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释:</span><br><span class="hljs-section">第一行: 0</span><br><span class="hljs-section">第二行: 01</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= n &lt;= 30</code></li><li><code>1 &lt;= k &lt;= 2n - 1</code></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方法一：找规律-二分迭代"><a href="#方法一：找规律-二分迭代" class="headerlink" title="方法一：找规律 + 二分迭代"></a>方法一：找规律 + 二分迭代</h4><p>以n&#x3D;5，k&#x3D;10为例</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">n</span> = <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span><br><span class="hljs-attribute">n</span> = <span class="hljs-number">2</span> -&gt; <span class="hljs-number">01</span><br><span class="hljs-attribute">n</span> = <span class="hljs-number">3</span> -&gt; <span class="hljs-number">0110</span><br><span class="hljs-attribute">n</span> = <span class="hljs-number">4</span> -&gt; <span class="hljs-number">0110</span> <span class="hljs-number">1001</span><br><span class="hljs-attribute">n</span> = <span class="hljs-number">5</span> -&gt; <span class="hljs-number">0110</span> <span class="hljs-number">1001</span> <span class="hljs-number">1001</span> <span class="hljs-number">0110</span><br></code></pre></td></tr></table></figure><p>从中我们很容易发现，每一个 <code>n</code> 对应的长度为：<code>len = 2 ^ (n-1)</code>，用 <code>s</code> 表示每个 <code>n</code> 对应的字符串</p><p>因此我们发现这样一个规律：</p><ul><li>如果 <code>k &gt; len / 2</code>，那么 <code>s[k] = !s[k - len / 2]</code>。换句话说如果 <code>s[k]</code> 为1，那么 <code>s[k - len / 2]</code>为0，互为取反。</li></ul><p>借助此规律，我们可以首先计算出对应的长度，用 <code>flag</code> 表示当前位置是否取反（很容易得知取反次数为偶数次时，保持不变）</p><p>循环迭代：</p><ul><li>通过长度 <code>len</code> 判断是当前位置 <code>k</code> 是在左半边还是在右半边，以此决定是否取反。<ul><li>若 <code>k</code> 在右半边，则取反 <code>flag = !flag</code>，并将 <code>k -= len / 2</code></li></ul></li><li>每次对当前字符串进行二分，即长度 <code>len</code> 进行折半</li><li>每次对 <code>n</code> 进行自减</li></ul><p>最终当 <code>n = 2</code> 时，停止迭代。此时 <code>k = 1</code>或 <code>k = 2</code>，便可根据 <code>flag</code> 得出最终答案</p><h5 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthGrammar</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        length = <span class="hljs-number">2</span> ** (n - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> length &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> k - <span class="hljs-number">1</span><br>        flag = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">if</span> k &gt; length // <span class="hljs-number">2</span>:<br>                k -= length // <span class="hljs-number">2</span><br>                flag = <span class="hljs-keyword">not</span> flag<br>            n -= <span class="hljs-number">1</span><br>            length //= <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> flag:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthGrammar</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">2</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(len &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> k - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span>(k &gt; len / <span class="hljs-number">2</span>) &#123;<br>                k -= len / <span class="hljs-number">2</span>;<br>                flag = !flag;<br>            &#125;<br>            n--;<br>            len /= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) &#123;<br>            <span class="hljs-keyword">return</span> k == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> k == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">kthGrammar</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-built_in">len</span> := <span class="hljs-type">int</span>(math.Pow(<span class="hljs-number">2</span>, <span class="hljs-type">float64</span>(n - <span class="hljs-number">1</span>)))<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span> &lt;= <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> k - <span class="hljs-number">1</span><br>    &#125;<br>    flag := <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">if</span> k &gt; <span class="hljs-built_in">len</span> / <span class="hljs-number">2</span> &#123;<br>            k -= <span class="hljs-built_in">len</span> / <span class="hljs-number">2</span><br>            flag = !flag<br>        &#125;<br>        n--<br>        <span class="hljs-built_in">len</span> /= <span class="hljs-number">2</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> flag &#123;<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125; <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第28篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1700. Number of Students Unable to Eat Lunch</title>
    <link href="/2022/10/19/LC-Solution-1700-Number-of-Students-Unable-to-Eat-Lunch/"/>
    <url>/2022/10/19/LC-Solution-1700-Number-of-Students-Unable-to-Eat-Lunch/</url>
    
    <content type="html"><![CDATA[<h1 id="1700-无法吃午餐的学生数量"><a href="#1700-无法吃午餐的学生数量" class="headerlink" title="1700. 无法吃午餐的学生数量"></a><a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/">1700. 无法吃午餐的学生数量</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>学校的自助午餐提供圆形和方形的三明治，分别用数字 <code>0</code> 和 <code>1</code> 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。</p><p>餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 <strong>栈</strong> 里，每一轮：</p><ul><li>如果队列最前面的学生 <strong>喜欢</strong> 栈顶的三明治，那么会 <strong>拿走它</strong> 并离开队列。</li><li>否则，这名学生会 <strong>放弃这个三明治</strong> 并回到队列的尾部。</li></ul><p>这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。</p><p>给你两个整数数组 <code>students</code> 和 <code>sandwiches</code> ，其中 <code>sandwiches[i]</code> 是栈里面第 <code>i</code> 个三明治的类型（<code>i = 0</code> 是栈的顶部）， <code>students[j]</code> 是初始队列里第 <code>j</code> 名学生对三明治的喜好（<code>j = 0</code> 是队列的最开始位置）。请你返回无法吃午餐的学生数量。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：students = [<span class="hljs-number">1,1,0,0</span>], sandwiches = [<span class="hljs-number">0,1,0,1</span>]<br>输出：<span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：students = <span class="hljs-string">[1,1,1,0,0,1]</span>, sandwiches = <span class="hljs-string">[1,0,0,0,1,1]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= students.length, sandwiches.length &lt;= 100</code></li><li><code>students.length == sandwiches.length</code></li><li><code>sandwiches[i]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li><li><code>students[i]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：队列-栈模拟"><a href="#方法一：队列-栈模拟" class="headerlink" title="方法一：队列 + 栈模拟"></a>方法一：队列 + 栈模拟</h3><ol><li>学生以队列形式取三明治<ul><li>如果队列头的学生喜欢当前三明治，则取走三明治之后出队列</li><li>否则，该学生返回队列尾，继续排队取三明治</li></ul></li><li>三明治以栈的形式被取走<ul><li>如果栈顶三明治被学生喜欢，则出栈</li><li>否则，保持不变</li></ul></li></ol><p>如此分析不难得出，如果队列中没有一个学生喜欢栈顶的三明治，那么循环将终止，当前队列中的所有学生将无法吃到三明治。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countStudents</span>(<span class="hljs-params">self, sts: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], sas: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">while</span> sts <span class="hljs-keyword">and</span> sas <span class="hljs-keyword">and</span> sas[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> sts:<br>            <span class="hljs-keyword">if</span> sts[<span class="hljs-number">0</span>] == sas[<span class="hljs-number">0</span>]:<br>                sts.pop(<span class="hljs-number">0</span>)<br>                sas.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">else</span>:<br>                st = sts.pop(<span class="hljs-number">0</span>)<br>                sts.append(st)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(sts)<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countStudents</span><span class="hljs-params">(<span class="hljs-type">int</span>[] sts, <span class="hljs-type">int</span>[] sas)</span> &#123;<br>        Deque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : sts) queue.addLast(v);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : sas) stack.addLast(v);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty() &amp;&amp; !stack.isEmpty() &amp;&amp; queue.contains(stack.peekFirst())) &#123;<br>            <span class="hljs-keyword">if</span>(queue.peekFirst() == stack.peekFirst()) &#123;<br>                queue.pollFirst();<br>                stack.pollFirst();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> queue.pollFirst();<br>                queue.addLast(v);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：计数"><a href="#方法二：计数" class="headerlink" title="方法二：计数"></a>方法二：计数</h3><p>根据之前方法一中的分析，发现关键在于栈顶的三明治是否被队列中的学生所喜欢，如果没有一个学生喜欢，则可以得出最终答案</p><p>于是可以采用计数方式，用 <code>cnt</code> 统计喜欢两种三明治的学生人数。</p><p>遍历三明治数组，递减 <code>cnt[v]</code>，当 <code>cnt[v] == -1</code>，也就是没有学生喜欢当前三明治，则直接返回剩余学生数量即可。</p><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countStudents</span>(<span class="hljs-params">self, sts: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], sas: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        cnt = Counter(sts)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(sas)):<br>            cnt[sas[i]] -= <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 这里是先减后判断，所以是-1</span><br>            <span class="hljs-keyword">if</span> cnt[sas[i]] == -<span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> cnt[sas[i] ^ <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countStudents</span><span class="hljs-params">(<span class="hljs-type">int</span>[] sts, <span class="hljs-type">int</span>[] sas)</span> &#123;<br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : sts) cnt[v]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sas.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(--cnt[sas[i]] == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> sas.length - i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countStudents</span><span class="hljs-params">(sts []<span class="hljs-type">int</span>, sas []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    cnt := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> sts &#123;<br>        cnt[v]++<br>    &#125;<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> sas &#123;<br>        cnt[v]--<br>        <span class="hljs-keyword">if</span> cnt[v] == <span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(sas) - i<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第27篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 904. Fruit Into Baskets</title>
    <link href="/2022/10/17/LC-Solution-904-Fruit-Into-Baskets/"/>
    <url>/2022/10/17/LC-Solution-904-Fruit-Into-Baskets/</url>
    
    <content type="html"><![CDATA[<h1 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><ul><li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ul><p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：fruits </span>=<span class="hljs-string"> [1,2,1]</span><br><span class="hljs-string">输出：3</span><br><span class="hljs-string">解释：可以采摘全部 3 棵树。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：fruits = <span class="hljs-comment">[0,1,2,2]</span><br>输出：3<br>解释：可以采摘 <span class="hljs-comment">[1,2,2]</span> 这三棵树。<br>如果从第一棵树开始采摘，则只能采摘 <span class="hljs-comment">[0,1]</span> 这两棵树。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：fruits = <span class="hljs-comment">[1,2,3,2,2]</span><br>输出：4<br>解释：可以采摘 <span class="hljs-comment">[2,3,2,2]</span> 这四棵树。<br>如果从第一棵树开始采摘，则只能采摘 <span class="hljs-comment">[1,2]</span> 这两棵树。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：fruits = [<span class="hljs-number">3,3,3,1</span>,<span class="hljs-number">2,1,1,2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">5</span><br>解释：可以采摘 [<span class="hljs-number">1,2,1,1</span>,<span class="hljs-number">2</span>] 这五棵树。<br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：滑动窗口"><a href="#方法一：滑动窗口" class="headerlink" title="方法一：滑动窗口"></a>方法一：滑动窗口</h3><p>题目意思就是用两个篮子摘水果，每个篮子一旦确定好水果类型之后就不能更改，如果碰到了水果种类与两个篮子里的水果种类不同的树，就停止，此时摘到水果的数量等于开始位置到终止位置的长度。</p><p>采用滑动窗口：设 <code>i</code> 为滑动窗口的终止位置，<code>j</code> 为滑动窗口的起始位置，<code>i</code> 与 <code>j</code> 之间的水果种类只有两种。</p><p>使用哈希表记录某个种类水果对应的采摘数量。当哈希表长度超过2时，说明此时有3个水果种类，需要剔除掉其中一个。也就是说，此时需要滑动左端点 <code>j</code> 并减少 <code>j</code> 所对应水果的数量，直到哈希表长度为2，也就是剩余2个水果种类。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python3">class Solution:<br>    def totalFruit(self, fruits: List[int]) -&gt; int:<br>        dic = defaultdict(int)<br>        j, ans = 0, 0<br>        for i, v in enumerate(fruits):<br>            dic[v] += 1<br>            while len(dic) &gt; 2:<br>                dic[fruits[j]] -= 1<br>                if dic[fruits[j]] == 0:<br>                    dic.pop(fruits[j])<br>                j += 1<br>            ans = max(ans, i - j + 1)<br>        return ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">totalFruit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] fruits)</span> &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fruits.length; i++) &#123;<br>            map.put(fruits[i], map.getOrDefault(fruits[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span>(map.size() &gt; <span class="hljs-number">2</span>) &#123;<br>                map.put(fruits[j], map.get(fruits[j]) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(map.get(fruits[j]) == <span class="hljs-number">0</span>) &#123;<br>                    map.remove(fruits[j]);<br>                &#125;<br>                j++;<br>            &#125;<br>            ans = Math.max(ans, i - j + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(fruits []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    cnt := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    ans, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> fruits &#123;<br>        cnt[x] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> ; <span class="hljs-built_in">len</span>(cnt) &gt; <span class="hljs-number">2</span>; j++ &#123;<br>            cnt[fruits[j]] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cnt[fruits[j]] == <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-built_in">delete</span>(cnt, fruits[j])<br>            &#125;<br>        &#125;<br>        ans = max(ans, i - j + <span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a <br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第26篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo从0到1搭建博客系列04：图床的最佳实践</title>
    <link href="/2022/10/15/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9704%EF%BC%9A%E5%9B%BE%E5%BA%8A%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/10/15/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9704%EF%BC%9A%E5%9B%BE%E5%BA%8A%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo从0到1搭建博客系列04：图床的最佳实践"><a href="#Hexo从0到1搭建博客系列04：图床的最佳实践" class="headerlink" title="Hexo从0到1搭建博客系列04：图床的最佳实践"></a>Hexo从0到1搭建博客系列04：图床的最佳实践</h1><h2 id="1-前言：为什么要使用图床？"><a href="#1-前言：为什么要使用图床？" class="headerlink" title="1. 前言：为什么要使用图床？"></a>1. 前言：为什么要使用图床？</h2><p>之前我们已经讲过如何用Hexo发表文章。但是，一篇优秀的知识分享与技术博客，怎么能少得了图片呢？</p><p>但是，文章中的图片存储在哪里？</p><ol><li>当我们在本地写博客做笔记（用Typora或MarkText）时，我们一般会把图片存在当前文章的路径下</li><li>当我们在CSDN、掘金或知乎等平台上写博客时，我们的图片会被存储到这些网站对应的服务器中</li><li>而当我们的博客发布在Hexo上时，图片的加载路径有以下两种方式：<ol><li>参照我们本地写博客的方式，将图片存储到Hexo下的public资源文件夹下</li><li>参照在技术论坛写博客的方式，将图片存储到服务器上</li></ol></li></ol><p>如果将图片资源都存储到Hexo的文件中，会变得很臃肿，所以不采用该方案。</p><p>我们这里所要说的就是将图片存储到服务器上，即图床这种方式。</p><p>但这时候你会想，本来使用Hexo做博客就是为了省事省钱、不买服务器，而为了存图片，再买服务器吗？</p><p>不必担心，各大云服务商平台都提供了图片存储，也是对象存储的云服务器！而且价格远低于服务器！</p><p>接下来进入正题！</p><h2 id="2-方案选择"><a href="#2-方案选择" class="headerlink" title="2. 方案选择"></a>2. 方案选择</h2><p>以下几种方案都极其简单，原理都很类似</p><h3 id="方案一：Github仓库-Picgo-jsDelivr-CDN"><a href="#方案一：Github仓库-Picgo-jsDelivr-CDN" class="headerlink" title="方案一：Github仓库 + Picgo + jsDelivr CDN"></a>方案一：Github仓库 + Picgo + jsDelivr CDN</h3><p>这一种方案我在实操之后，发现国内用户无法访问，是因为最近国内将jsDelivrCDN给墙了，无法通过其对Github进行加速</p><p>但是我还是简单介绍一下，</p><ol><li><p>创建Github公共仓库，名字随便，注意一定要是公共的，否则别人无法访问到图片资源。</p></li><li><p>下载 <a href="https://github.com/Molunerfinn/PicGo/releases">Picgo</a></p><blockquote><p>  <strong>PicGo: 一个用于快速上传图片并获取图片 URL 链接的工具</strong></p></blockquote></li><li><p>将Github创建仓库信息配置到Picgo中。打开Picgo，点击图床设置，选择Github图床，填写如下信息。</p><p>仓库名就写你之前创建好的仓库名</p><p>分支填现有的分支就可以</p><p>其中的Token可以在Github - Settings - Personal access tokens 中生成，只选择repo选项就可以</p><ul><li>如果不知道如何生成的话，可以查看现成的相关<a href="https://www.cnblogs.com/leon-2016/p/9284837.html">攻略</a></li></ul><p>指定存储路径可填可不填</p><p>自定义域名这里填写：<code>https://cdn.jsdelivr.net/gh/用户名/仓库名</code>，因为我们采用了jsDelivr CDN进行加速，虽然现在没有任何卵用</p><p>最后保存为默认图床即可</p></li></ol><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015200744589.png" alt="image-20221015200744589"></p><h3 id="方案二：Gitee仓库-Picgo"><a href="#方案二：Gitee仓库-Picgo" class="headerlink" title="方案二：Gitee仓库 + Picgo"></a>方案二：Gitee仓库 + Picgo</h3><p>Gitee虽然说是国内平台，访问是没问题的。但是听说它经常崩，我有点担心，就没有去尝试。</p><p>其方法和Github几乎一模一样，只是选择了用Gitee创建仓库。</p><p>在这里我也不推荐使用这种方案</p><h3 id="方案三：阿里云对象存储-Picgo"><a href="#方案三：阿里云对象存储-Picgo" class="headerlink" title="方案三：阿里云对象存储 + Picgo"></a>方案三：阿里云对象存储 + Picgo</h3><p>之前没有使用过阿里云的小伙伴可以仔细学一学啦，</p><p>以后搭建个人网站都需要用到服务器，网站上的图片视频资源也肯定需要用到云存储，所以不可避免要和各类云服务商打交道。</p><p>而阿里云应该是国内最知名的几家云服务商之一了</p><ol><li>登录阿里云网站，进入工作台页面，搜索对象存储，进入该页面，然后点击bucket列表</li></ol><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015202120960.png" alt="image-20221015202120960"></p><ol start="2"><li><p>进入页面，点击创建bucket.</p><ul><li>Bucket名称和地域必填。地域选择一个距离自己近一些的地方。</li><li>读写权限选择为公共读，其余均默认</li></ul><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015202336953.png" alt="image-20221015202336953"></p></li><li><p>点击网页右上角的头像，再点击AccessKey管理，进入该页面</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015202601913.png" alt="image-20221015202601913"></p></li><li><p>点击创建AccessKey，将创建号的key复制保存下来，之后在Picgo上需要用到</p></li><li><p>打开Picgo，点击图床设置，选择阿里云OSS，填写如下信息。</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015202826913.png" alt="image-20221015202826913"></p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>结合历史经验，为了网站图片存储的稳定，我们还是选择方案三作为我们图床实践的最佳选择</p><p>可能后期图片访问量大的话，需要充一点钱，但是也很便宜，大概一年40GB只需要9块钱，相当划算啦</p><h2 id="3-结合Typora使用"><a href="#3-结合Typora使用" class="headerlink" title="3. 结合Typora使用"></a>3. 结合Typora使用</h2><p>当我们成功搭建好图床之后，每次写Markdown文档时，都需要先截图，再保存，然后手动打开Picgo完成上传，最后将图片地址复制到Markdown文档中。</p><p>如何做到更加高效地上传图片到图床呢？</p><p>用Typora写笔记，只需要先截图，再粘贴到Markdown文档，即可直接跳过上传操作，Typora帮我们自动完成。</p><p>操作为：打开Typora的设置，点击图像，按照我给的图片进行设置</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015203547504.png" alt="image-20221015203547504"></p><p>之后，我们便可以愉快地用Hexo写图文并茂的博客啦~</p><h2 id="4-后记"><a href="#4-后记" class="headerlink" title="4. 后记"></a>4. 后记</h2><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>Hexo搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1441. Build an Array With Stack Operations</title>
    <link href="/2022/10/15/LC-Solution-1441-Build-an-Array-With-Stack-Operations/"/>
    <url>/2022/10/15/LC-Solution-1441-Build-an-Array-With-Stack-Operations/</url>
    
    <content type="html"><![CDATA[<h1 id="1441-用栈操作构建数组"><a href="#1441-用栈操作构建数组" class="headerlink" title="1441. 用栈操作构建数组"></a><a href="https://leetcode.cn/problems/build-an-array-with-stack-operations/">1441. 用栈操作构建数组</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个数组 <code>target</code> 和一个整数 <code>n</code>。每次迭代，需要从 <code>list = &#123; 1 , 2 , 3 ..., n &#125;</code> 中依次读取一个数字。</p><p>请使用下述操作来构建目标数组 <code>target</code> ：</p><ul><li><code>&quot;Push&quot;</code>：从 <code>list</code> 中读取一个新元素， 并将其推入数组中。</li><li><code>&quot;Pop&quot;</code>：删除数组中的最后一个元素。</li><li>如果目标数组构建完成，就停止读取更多元素。</li></ul><p>题目数据保证目标数组严格递增，并且只包含 <code>1</code> 到 <code>n</code> 之间的数字。</p><p>请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：target = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], n = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;Push&quot;</span>,<span class="hljs-string">&quot;Push&quot;</span>,<span class="hljs-string">&quot;Pop&quot;</span>,<span class="hljs-string">&quot;Push&quot;</span>]<br>解释： <br>读取 <span class="hljs-number">1</span> 并自动推入数组 -&gt; [<span class="hljs-number">1</span>]<br>读取 <span class="hljs-number">2</span> 并自动推入数组，然后删除它 -&gt; [<span class="hljs-number">1</span>]<br>读取 <span class="hljs-number">3</span> 并自动推入数组 -&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：target = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], n = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;Push&quot;</span>,<span class="hljs-string">&quot;Push&quot;</span>,<span class="hljs-string">&quot;Push&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：target = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], n = <span class="hljs-number">4</span><br>输出：[<span class="hljs-string">&quot;Push&quot;</span>,<span class="hljs-string">&quot;Push&quot;</span>]<br>解释：只需要读取前 <span class="hljs-number">2</span> 个数字就可以停止。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target.length &lt;= 100</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= target[i] &lt;= n</code></li><li><code>target</code> 严格递增</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：简单模拟"><a href="#方法一：简单模拟" class="headerlink" title="方法一：简单模拟"></a>方法一：简单模拟</h3><p>题目给定的条件：<code>target</code> 数组严格递增升序且只包含1~n之间的数字</p><ol><li>对于 <code>target</code> 中缺少的数字，分类讨论<ol><li>该数字小于 <code>target[-1]</code>（数组最后一个元素），需要进行 ‘Push’ + ‘Pop’ 操作</li><li>该数字大于 <code>target[-1]</code>（数组最后一个元素），无需进行操作，因为该数已经不在 <code>target</code> 内了</li></ol></li><li>对于 <code>target</code> 中存在的数字，我只需要进行 ‘Push’ 操作</li></ol><p>根据上述分析可知，我们根本不需要用到题目给定的 n，因为 n 中大于 <code>target[-1]</code> 的数不需要处理，而小于 <code>target[-1]</code> 的数只需要遍历 <code>target</code> 数组即可</p><p>因此，遍历 <code>target</code> 数组，找出 <code>target</code> 缺少的数字。通过初始化 <code>j = 1</code>，判断当前遍历的数是否等于 <code>j</code> 来判断是否缺少该数。</p><p>直接看代码更好理解！</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python3">class Solution:<br>    def buildArray(self, target: List[int], n: int) -&gt; List[str]:<br>        ans = []<br>        j = 1<br>        for i in range(len(target)):<br>            while target[i] != j:<br>                ans.append(&#x27;Push&#x27;)<br>                ans.append(&#x27;Pop&#x27;)<br>                j += 1<br>            ans.append(&#x27;Push&#x27;)<br>            j += 1 # 当target[i] == j时，处理完之后还需要在自增一次j<br>        return ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">buildArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] target, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> target.length;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">while</span>(target[i] != j) &#123;<br>                ans.add(<span class="hljs-string">&quot;Push&quot;</span>);<br>                ans.add(<span class="hljs-string">&quot;Pop&quot;</span>);<br>                j++;<br>            &#125;<br>            ans.add(<span class="hljs-string">&quot;Push&quot;</span>)<br>            j++; <span class="hljs-comment">// 当target[i] == j时，处理完之后还需要在自增一次j</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第25篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 5. Longest Palindromic Substring</title>
    <link href="/2022/10/14/LC-Solution-5-Longest-Palindromic-Substring/"/>
    <url>/2022/10/14/LC-Solution-5-Longest-Palindromic-Substring/</url>
    
    <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;babad&quot;</span><br>输出：<span class="hljs-string">&quot;bab&quot;</span><br>解释：<span class="hljs-string">&quot;aba&quot;</span> 同样是符合题意的答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cbbd&quot;</span><br>输出：<span class="hljs-string">&quot;bb&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：中心扩散法-双指针"><a href="#方法一：中心扩散法-双指针" class="headerlink" title="方法一：中心扩散法 + 双指针"></a>方法一：中心扩散法 + 双指针</h3><p>思路为：从 <code>s</code> 中选取一个位置作为中心，从该中心位置向两边扩散，如果两边元素不相等的时候停止。</p><p>举个🌰：如 <code>abbac</code>，假设选取第一个’b’作为中心位置，<code>i = 2</code>。设左指针 <code>l == i - 1</code> ，右指针<code>r == i + 1</code> </p><ol><li>先向左扩散。<code>l</code> 一直自减，直到遇到与中心位置不相等的字符。此时 <code>s[l] = &#39;a&#39;</code> <code>l = 1</code> </li><li>再向右扩散。<code>r</code> 一直自增，直到遇到与中心位置不相等的字符。此时 <code>s[r] = &#39;a&#39;</code> <code>r = 3</code></li><li>左指针与右指针同时开始双向扩散，直到左和右不相等</li></ol><p>一开始之所以要执行第1步和第2步，就是要进一步确定中心块。因为定义的中心可能只有一个元素，但可能由多个相同元素组成。</p><p>遍历 <code>s</code>， 执行完上述流程后，需要更新最长回文子串的左端点与长度，以便于最后返回结果</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        maxLen, maxLeft = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            l, r = i - <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span><br>            curLen = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> l &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[l] == s[i]:<br>                curLen, l = curLen + <span class="hljs-number">1</span>, l - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> r &lt; n <span class="hljs-keyword">and</span> s[r] == s[i]:<br>                curLen, r = curLen + <span class="hljs-number">1</span>, r + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> l &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> r &lt; n <span class="hljs-keyword">and</span> s[l] == s[r]:<br>                curLen += <span class="hljs-number">2</span><br>                l, r = l - <span class="hljs-number">1</span>, r + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> curLen &gt;= maxLen:<br>                maxLen = curLen<br>                maxLeft = l<br>        <span class="hljs-keyword">return</span> s[maxLeft + <span class="hljs-number">1</span>: maxLeft + maxLen + <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxLeft = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>, r = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(l &gt;= <span class="hljs-number">0</span> &amp;&amp; cs[l] == cs[i]) &#123;<br>                curLen++;<br>                l--;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(r &lt; n &amp;&amp; cs[r] == cs[i]) &#123;<br>                curLen++;<br>                r++;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; n &amp;&amp; cs[l] == cs[r]) &#123;<br>                l--;<br>                r++;<br>                curLen += <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(curLen &gt; maxLen) &#123;<br>                maxLen = curLen;<br>                maxLeft = l;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(maxLeft + <span class="hljs-number">1</span>, maxLeft + <span class="hljs-number">1</span> + maxLen);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p>中心扩散法做了很多重复的计算。其实可以在计算的过程中将这些值存储起来，即记忆化搜索。可以采用动态规划实现。</p><p>设 <code>dp[i][j]</code>，其为<code>True</code> 代表 <code>[i, j]</code> 区间字符串为回文字符串</p><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        maxLen, maxLeft, maxRight = <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        dp = [[<span class="hljs-literal">False</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r):<br>                <span class="hljs-keyword">if</span> s[l] == s[r] <span class="hljs-keyword">and</span> (r - l &lt;= <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> dp[l+<span class="hljs-number">1</span>][r-<span class="hljs-number">1</span>]):<br>                    dp[l][r] = <span class="hljs-literal">True</span><br>                    <span class="hljs-keyword">if</span> r - l + <span class="hljs-number">1</span> &gt; maxLen:<br>                        maxLen = r - l + <span class="hljs-number">1</span><br>                        maxLeft, maxRight = l, r<br>        <span class="hljs-keyword">return</span> s[maxLeft: maxRight + <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxLeft = <span class="hljs-number">0</span>, maxRight = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; r &lt; n; r++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l &lt; r; l++) &#123;<br>                <span class="hljs-keyword">if</span>(cs[l] == cs[r] &amp;&amp; (r - l &lt;= <span class="hljs-number">2</span> || dp[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>])) &#123;<br>                    dp[l][r] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span>(r - l + <span class="hljs-number">1</span>&gt; maxLen) &#123;<br>                        maxLen = r - l + <span class="hljs-number">1</span>;<br>                        maxLeft = l;<br>                        maxRight = r;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(maxLeft, maxRight + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第24篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 817. Linked List Components</title>
    <link href="/2022/10/12/LC-Solution-817-Linked-List-Components/"/>
    <url>/2022/10/12/LC-Solution-817-Linked-List-Components/</url>
    
    <content type="html"><![CDATA[<h1 id="817-链表组件"><a href="#817-链表组件" class="headerlink" title="817. 链表组件"></a><a href="https://leetcode.cn/problems/linked-list-components/">817. 链表组件</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定链表头结点 <code>head</code>，该链表上的每个结点都有一个 <strong>唯一的整型值</strong> 。同时给定列表 <code>nums</code>，该列表是上述链表中整型值的一个子集。</p><p>返回列表 <code>nums</code> 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 <code>nums</code> 中）构成的集合。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: head = <span class="hljs-comment">[0,1,2,3]</span>, nums = <span class="hljs-comment">[0,1,3]</span><br>输出: 2<br>解释: 链表中,0 和 1 是相连接的，且 nums 中不包含 2，所以 <span class="hljs-comment">[0, 1]</span> 是 nums 的一个组件，同理 <span class="hljs-comment">[3]</span> 也是一个组件，故返回 2。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: head = <span class="hljs-comment">[0,1,2,3,4]</span>, nums = <span class="hljs-comment">[0,3,1,4]</span><br>输出: 2<br>解释: 链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 <span class="hljs-comment">[0, 1]</span> 和 <span class="hljs-comment">[3, 4]</span> 是两个组件，故返回 2。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数为<code>n</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>0 &lt;= Node.val &lt; n</code></li><li><code>Node.val</code> 中所有值 <strong>不同</strong></li><li><code>1 &lt;= nums.length &lt;= n</code></li><li><code>0 &lt;= nums[i] &lt; n</code></li><li><code>nums</code> 中所有值 <strong>不同</strong></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：模拟-哈希表-链表遍历"><a href="#方法一：模拟-哈希表-链表遍历" class="headerlink" title="方法一：模拟 + 哈希表 + 链表遍历"></a>方法一：模拟 + 哈希表 + 链表遍历</h3><p>分析题意可知，需要返回链表中连通量的个数（连通量中的值必须在 <code>nums</code> 中）</p><p>因此我们可以通过遍历列表，判断当前节点 <code>cur.val</code> 以及其前驱节点 <code>pre.val</code> 是否存在于 <code>nums</code> 中，如下分类讨论：</p><ol><li>若 <code>cur.val</code> 在 <code>nums</code> 中，但 <code>pre.val</code> 不在 <code>nums</code> 中：</li></ol><p>  说明此时产生了新的连通分量，需要进行计数</p><ol start="2"><li><p>若 <code>cur.val</code> 不在 <code>nums</code> 中，<code>pre.val</code> 也不在 <code>nums</code> 中：没有新的连通分量产生</p></li><li><p>若 <code>cur.val</code> 不在 <code>nums</code> 中，但<code>pre.val</code> 在 <code>nums</code> 中：没有新的连通分量产生</p></li><li><p>若 <code>cur.val</code> 在 <code>nums</code> 中，<code>pre.val</code> 也在 <code>nums</code> 中：</p></li></ol><p>  没有新的连通分量产生，<code>cur</code> 归属于前一个连通分量集合中</p><p>因此，只有第一种情况下，我们需要进行计数，其他情况不用体现在代码中。</p><p>为了提高判断链表节点值是否在 <code>nums</code> 中，我们将其转换为 <code>set</code> 集合，更加高效。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numComponents</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        cur = head<br>        ans, pre = <span class="hljs-number">0</span>, ListNode(-<span class="hljs-number">1</span>)<br>        s = <span class="hljs-built_in">set</span>(nums)<br>        <span class="hljs-keyword">while</span> cur:<br>            <span class="hljs-keyword">if</span> cur.val <span class="hljs-keyword">in</span> s <span class="hljs-keyword">and</span> pre.val <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s:<br>                    ans += <span class="hljs-number">1</span><br>            pre, cur = cur, cur.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numComponents</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : nums) set.add(n);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head, pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(set.contains(cur.val) &amp;&amp; !set.contains(pre.val)) &#123;<br>                ans++;<br>            &#125;<br>            pre = cur;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第23篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解JDK锁01:Lock接口</title>
    <link href="/2022/10/12/%E8%AF%A6%E8%A7%A3JDK%E9%94%8101-Lock%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/10/12/%E8%AF%A6%E8%A7%A3JDK%E9%94%8101-Lock%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="详解JDK锁01：Lock接口"><a href="#详解JDK锁01：Lock接口" class="headerlink" title="详解JDK锁01：Lock接口"></a>详解JDK锁01：Lock接口</h1><h2 id="1-Lock简介"><a href="#1-Lock简介" class="headerlink" title="1. Lock简介"></a>1. Lock简介</h2><p>先引用Lock接口源码中作者贴的一段话</p><blockquote><p>Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more <code>flexible structuring</code>, may have quite <code>different properties</code>, and may support <code>multiple associated Condition objects</code>.</p></blockquote><p>其实这段话就简单概括了Lock的三大优点：</p><ol><li><p>灵活的结构：可以显式地获取与释放锁</p></li><li><p>多种不同的属性与方法</p></li><li><p>引入了 <code>Condition</code> 对象</p></li></ol><p>接下来的部分将着重介绍这几点</p><h2 id="2-Lock锁的灵活性"><a href="#2-Lock锁的灵活性" class="headerlink" title="2. Lock锁的灵活性"></a>2. Lock锁的灵活性</h2><h3 id="2-1-Lock接口方法"><a href="#2-1-Lock接口方法" class="headerlink" title="2.1 Lock接口方法"></a>2.1 Lock接口方法</h3><p>在 JDK5.0 之前，Java是借助于 <code>Synchronized</code> 关键字实现加锁功能，而这个功能是通过JVM实现的。而在 JDK5.0 之后，JUC包中新增了Lock接口实现锁功能。</p><p>虽然该Lock接口不具备 <code>Synchronized</code> 关键字隐式获取锁的便捷性，但是其提供了一系列手动操作锁的方法：</p><ol><li>阻塞式地获取锁</li></ol><p>  该方法有一定的缺陷：如果当前锁被占用，那么当前线程将被禁用，进入阻塞状态，直到获取到锁为止。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li>阻塞式地可打断地获取锁</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><p>  虽然是阻塞式地获取锁，但是如果该线程被中断后，会抛出异常，停止继续阻塞。</p><ol start="3"><li>非阻塞式地获取锁</li></ol><p>  尝试非阻塞地获取锁，调用该方法后立即返回</p><ul><li><p>若能够获取到锁，则返回 true</p></li><li><p>若锁已被占用，则返回 false</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>  该方法的典型使用场景为：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 伪代码</span><br><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ...;<br><span class="hljs-keyword">if</span> (lock.tryLock() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 操作共享资源</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 未获取到锁，执行其余操作</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>带有超时时间地获取锁</li></ol><p>  尝试在指定的一段时间内获取锁</p><ul><li><p>若在指定时间 <code>time</code> 内能够获取到锁，且未被中断，则返回 true</p></li><li><p>若指定时间 <code>time</code> 结束后仍未获取到锁，则返回 false</p></li><li><p>若在指定时间 <code>time</code> 内被打断，则抛出 <code>InterruptedException</code></p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><p>  其中 <code>time</code> 代表指定的超时时间，<code>unit</code> 代表时间单位</p><ol start="5"><li>释放锁</li></ol>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span>()</span>;<br></code></pre></td></tr></table></figure><h3 id="2-2-灵活性体现"><a href="#2-2-灵活性体现" class="headerlink" title="2.2 灵活性体现"></a>2.2 灵活性体现</h3><p>使用 <code>Synchronized</code> 关键字进行获取锁与释放锁操作时：</p><p>当嵌套式地获取锁之后，其释放锁的顺序必须与获取锁的顺序相反</p><p>如下获取锁顺序为：lock1 -&gt; lock2 -&gt; lock3</p><p>释放锁顺序为：lock3 -&gt; lock2 -&gt; lock1</p><p>从外到内获取锁，从内到外释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">lock3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>    System.out.println(<span class="hljs-string">&quot;获取到lock1锁&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>        System.out.println(<span class="hljs-string">&quot;获取到lock2锁&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (lock3) &#123;<br>            System.out.println(<span class="hljs-string">&quot;获取到lock3锁&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是我们假设存在这一业务需求：</p><p>先获取锁A，再获取锁B，再释放锁A，再获取锁C，再释放锁B，再获取锁D。</p><p>这种获取锁的顺序与释放锁的顺序是不固定的，此时无法用 <code>Synchronized</code> 解决。</p><p>而采用Lock接口实现锁则可以完美解决这一问题，因为它提供了手动的加锁解锁方法！</p><h2 id="3-Lock锁的多种功能"><a href="#3-Lock锁的多种功能" class="headerlink" title="3. Lock锁的多种功能"></a>3. Lock锁的多种功能</h2><p>Lock接口中虽然只提供了简单的获取锁与释放锁的基本方法，但是其实现类ReentrantLock中实现了多种方法，提供了不同的功能。</p><blockquote><p>这一篇文章只对Lock接口进行详细介绍，所以以下只做简单的文字介绍。</p><p>后续文章会通过源码解读 <code>ReentrantLock</code></p></blockquote><ol><li>实现公平锁与非公平锁。实例化ReentrantLock时，其有参构造方法中传入的值为boolean类型。若传入值为true，为公平锁；否则为非公平锁</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>判断锁是否已经被持有</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> sync.isLocked();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>判断锁是否为公平锁</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFair</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> sync <span class="hljs-keyword">instanceof</span> FairSync;  <br>&#125;<br></code></pre></td></tr></table></figure><p>相较于Lock接口，<code>Synchronized</code> 只实现了非公平锁。</p><h2 id="4-Condition基本使用"><a href="#4-Condition基本使用" class="headerlink" title="4. Condition基本使用"></a>4. Condition基本使用</h2><p>回顾 <code>Synchronized</code> 关键字，其实现 <code>等待/通知</code> 的模式是通过 <code>Object</code> 类内部的 <code>wait</code>、<code>notify</code> 以及 <code>notifyAll</code> 实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            lock.wait();  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);  <br>        &#125;  <br>        System.out.println(<span class="hljs-string">&quot;Thread1已被唤醒&quot;</span>);  <br>    &#125;  <br>&#125;);  <br>thread1.start();  <br>Thread.sleep(<span class="hljs-number">2000</span>);  <br><span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>    System.out.println(<span class="hljs-string">&quot;唤醒Thread1&quot;</span>);  <br>    lock.notify();  <br>    <span class="hljs-comment">// lock.notifyAll();  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>notify</code> 方法是唤醒 <code>lock</code> 锁上的其中一个线程，<code>notifyAll</code> 方法是唤醒 <code>lock</code> 锁上的全部线程。</p><p>然而，这两种方法均不能指定想要唤醒的线程。</p><p>Condition的出现很好地解决了这一问题，可以分组唤醒想要唤醒的线程。</p><p>如下为Condition的基本实现方式：需要使用 <code>ReentrantLock</code> 实现 <code>Lock</code> 接口</p><blockquote><p>后续文章会详细解读 <code>Condition</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br><span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();  <br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;Thread1进入等待&quot;</span>);  <br>            condition.await();  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);  <br>        &#125;  <br>        System.out.println(<span class="hljs-string">&quot;Thread1已被唤醒&quot;</span>);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;).start();  <br><br>Thread.sleep(<span class="hljs-number">3000</span>);  <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;唤醒Thread1&quot;</span>);  <br>        condition.signal();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;).start();<br></code></pre></td></tr></table></figure><h2 id="5-Lock与Synchronized-对比"><a href="#5-Lock与Synchronized-对比" class="headerlink" title="5. Lock与Synchronized 对比"></a>5. Lock与Synchronized 对比</h2><ol><li><p><code>Lock</code> 所处的层面是JDK，是人为通过Java代码而实现的；而 <code>Synchronized</code> 是Java的关键字，是底层C++语言实现，处于JVM层面。</p></li><li><p><code>Lock</code> 获取和释放锁的顺序不固定，因为其内置了手动操作锁的方法；而 <code>Synchronized</code> 必须按照获取锁的相反顺序去释放锁。</p></li><li><p><code>Lock</code> 可以非阻塞式地获取锁（ <code>tryLock</code> 方法）；而 <code>Synchronized</code> 只能通过阻塞式地获取锁，若当前锁已被其他线程获取，那么该线程只能阻塞等待。</p></li><li><p><code>Lock</code> 既可实现公平锁，也可实现非公平锁；而 <code>Synchronized</code>只能实现非公平锁。</p></li><li><p><code>lock</code> 等待锁过程中可以用 <code>lockInterruptibly</code> 来中断等待，而synchronized只能等待锁的释放，不能响应中断；</p></li></ol><h2 id="6-写在后面"><a href="#6-写在后面" class="headerlink" title="6. 写在后面"></a>6. 写在后面</h2><p>参考文献：</p><blockquote><ol><li><p>JDK5.0源码</p></li><li><p>《Java并发编程的艺术》</p></li><li><p><a href="https://www.bilibili.com/video/BV16J411h7Rd/?spm_id_from=333.337.search-card.all.click&vd_source=4e7654633e4719c03a8fb6c6b524ddc2">黑马Java并发编程教程</a></p></li></ol></blockquote><p>这个系列大概会有5篇左右的样子，我尽可能把自己对于JUC的理解通俗易懂地写出来</p><p>但如果有错误的地方，请大家指出来，我会及时去学习与改进~</p><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
      <tag>Java</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1877. Minimize Maximum Pair Sum in Array</title>
    <link href="/2022/10/11/LC-Solution-1877-Minimize-Maximum-Pair-Sum-in-Array/"/>
    <url>/2022/10/11/LC-Solution-1877-Minimize-Maximum-Pair-Sum-in-Array/</url>
    
    <content type="html"><![CDATA[<h1 id="1877-数组中最大数对和的最小值"><a href="#1877-数组中最大数对和的最小值" class="headerlink" title="1877. 数组中最大数对和的最小值"></a><a href="https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array/">1877. 数组中最大数对和的最小值</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个数对 <code>(a,b)</code> 的 <strong>数对和</strong> 等于 <code>a + b</code> 。<strong>最大数对和</strong> 是一个数对数组中最大的 <strong>数对和</strong> 。</p><ul><li>比方说，如果我们有数对 <code>(1,5)</code> ，<code>(2,3)</code> 和 <code>(4,4)</code>，<strong>最大数对和</strong> 为 <code>max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8</code> 。</li></ul><p>给你一个长度为 <strong>偶数</strong> <code>n</code> 的数组 <code>nums</code> ，请你将 <code>nums</code> 中的元素分成 <code>n / 2</code> 个数对，使得：</p><ul><li><code>nums</code> 中每个元素 <strong>恰好</strong> 在 <strong>一个</strong> 数对中，且</li><li><strong>最大数对和</strong> 的值 <strong>最小</strong> 。</li></ul><p>请你在最优数对划分的方案下，返回最小的 <strong>最大数对和</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[3,5,2,3]</span><br>输出：<span class="hljs-number">7</span><br>解释：数组中的元素可以分为数对 (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>) 和 (<span class="hljs-number">5</span>,<span class="hljs-number">2</span>) 。<br>最大数对和为 <span class="hljs-built_in">max</span>(<span class="hljs-number">3</span>+<span class="hljs-number">3</span>, <span class="hljs-number">5</span>+<span class="hljs-number">2</span>) = <span class="hljs-built_in">max</span>(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>) = <span class="hljs-number">7</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[3,5,4,2,4,6]</span><br>输出：<span class="hljs-number">8</span><br>解释：数组中的元素可以分为数对 (<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)，(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>) 和 (<span class="hljs-number">6</span>,<span class="hljs-number">2</span>) 。<br>最大数对和为 <span class="hljs-built_in">max</span>(<span class="hljs-number">3</span>+<span class="hljs-number">5</span>, <span class="hljs-number">4</span>+<span class="hljs-number">4</span>, <span class="hljs-number">6</span>+<span class="hljs-number">2</span>) = <span class="hljs-built_in">max</span>(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>) = <span class="hljs-number">8</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>n</code> 是 <strong>偶数</strong> 。</li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：贪心-双指针"><a href="#方法一：贪心-双指针" class="headerlink" title="方法一：贪心 + 双指针"></a>方法一：贪心 + 双指针</h3><p>分析题意可知：题目给定了一个偶数长度的 <code>nums</code> 数组，将其两两分组组成数对，使得最终构成的数对数组中的最大数对和尽可能的小。</p><p>数对和意思是：一个数对中的两个数之和</p><p>为了使得最大的数对和尽可能地小，直观判断便是采用贪心思想，使得数组中的最小值与最大值组队，第二小值与第二大值组队 … 依次类推。最终得到的数对数组便可符合这一条件。</p><p>于是根据这一贪心思想，很容易想到算法实现方案 -&gt; 排序双指针，遍历数组</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPairSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        nums.sort()<br>        i, j = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; j:<br>            ans = <span class="hljs-built_in">max</span>(ans, nums[i] + nums[j])<br>            i, j = i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>采用推导式进一步简化代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPairSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        nums.sort()<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[i] + nums[<span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span> - i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)) <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(nums) // <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPairSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>            ans = Math.max(ans, nums[l] + nums[r]);<br>            l++;<br>            r--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第22篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1846. Maximum Element After Decreasing and Rearranging</title>
    <link href="/2022/10/11/LC-Solution-1846-Maximum-Element-After-Decreasing-and-Rearranging/"/>
    <url>/2022/10/11/LC-Solution-1846-Maximum-Element-After-Decreasing-and-Rearranging/</url>
    
    <content type="html"><![CDATA[<h1 id="1846-减小和重新排列数组后的最大元素"><a href="#1846-减小和重新排列数组后的最大元素" class="headerlink" title="1846. 减小和重新排列数组后的最大元素"></a><a href="https://leetcode.cn/problems/maximum-element-after-decreasing-and-rearranging/">1846. 减小和重新排列数组后的最大元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数数组 <code>arr</code> 。请你对 <code>arr</code> 执行一些操作（也可以不进行任何操作），使得数组满足以下条件：</p><ul><li><p><code>arr</code> 中 <strong>第一个</strong> 元素必须为 <code>1</code></p></li><li><p>任意相邻两个元素的差的绝对值 <strong>小于等于</strong> <code>1</code> ，也就是说，对于任意的 <code>1 &lt;= i &lt; arr.length</code> （<strong>数组下标从 0 开始</strong>），都满足 <code>abs(arr[i] - arr[i - 1]) &lt;= 1</code> 。<code>abs(x)</code> 为 <code>x</code> 的绝对值。</p></li></ul><p>你可以执行以下 2 种操作任意次：</p><ul><li><strong>减小</strong> <code>arr</code> 中任意元素的值，使其变为一个 <strong>更小的正整数</strong> 。</li><li><strong>重新排列</strong> <code>arr</code> 中的元素，你可以以任意顺序重新排列。</li></ul><p>请你返回执行以上操作后，在满足前文所述的条件下，<code>arr</code> 中可能的 <strong>最大值</strong> 。</p><p><strong>示例1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[2,2,1,2,1]</span><br>输出：<span class="hljs-number">2</span><br>解释：<br>我们可以重新排列 arr 得到 <span class="hljs-string">[1,2,2,2,1]</span> ，该数组满足所有条件。<br>arr 中最大元素为 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">输入：arr = [100,1,1000]<br>输出：3<br>解释：<br>一个可行的方案如下：<br><span class="hljs-bullet">1.</span> 重新排列 arr 得到 [1,100,1000] 。<br><span class="hljs-bullet">2.</span> 将第二个元素减小为 2 。<br><span class="hljs-bullet">3.</span> 将第三个元素减小为 3 。<br>现在 arr = [1,2,3] ，满足所有条件。<br>arr 中最大元素为 3 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-number">5</span><br>解释：数组已经满足所有条件，最大元素为 <span class="hljs-number">5</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 105</code></li><li><code>1 &lt;= arr[i] &lt;= 109</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：贪心"><a href="#方法一：贪心" class="headerlink" title="方法一：贪心"></a>方法一：贪心</h3><p>分析题意：题目要求通过 <code>减法运算</code> 或 <code>重排序</code> 两种方法，使得数组的两两元素之差的绝对值小于等于1（<code>abs(arr[i] - arr[i - 1]) &lt;= 1</code>），且 <code>arr[0] = 1</code></p><p>于是很容易想到用贪心思想解决本题</p><ol><li><p>允许重排序且题目最终要求返回数组最大值：最终返回结果与数组顺序无关，所以我们可以直接对数组 <code>arr</code> 进行排序。</p></li><li><p><code>arr[0] = 1</code>：从此可以确定对 <code>arr</code> 进行升序排序</p></li><li><p>可以做减法运算：从此条件可以进一步简化题目。既然我们之前已经确定了采用升序排序，那么可以得知此条件始终成立 <code>arr[i] &gt;= arr[i - 1]</code>。</p></li></ol><p>  所以我们遍历 <code>arr</code> 数组时：</p><ol><li><p>无需计算元素之差的绝对值</p></li><li><p>当不满足元素之差小于等于1的条件（ <code>arr[i] &gt; arr[i] + 1</code> ）时，只需 <code>arr[i] = arr[i -1] + 1</code>，使较大的值等于较小的值加1，相当于对较大的值做减法运算</p></li></ol><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumElementAfterDecrementingAndRearranging</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        arr.sort()<br>        arr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(arr)):<br>            <span class="hljs-keyword">if</span> arr[i] - arr[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span>:<br>                arr[i] = arr[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> arr[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumElementAfterDecrementingAndRearranging</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        Arrays.sort(arr);<br>        arr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[i] - arr[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span>) &#123;<br>               arr[i] = arr[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[arr.length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第21篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1833. Maximum Ice Cream Bars</title>
    <link href="/2022/10/11/LC-Solution-1833-Maximum-Ice-Cream-Bars/"/>
    <url>/2022/10/11/LC-Solution-1833-Maximum-Ice-Cream-Bars/</url>
    
    <content type="html"><![CDATA[<h1 id="1833-雪糕的最大数量"><a href="#1833-雪糕的最大数量" class="headerlink" title="1833. 雪糕的最大数量"></a><a href="https://leetcode.cn/problems/maximum-ice-cream-bars/">1833. 雪糕的最大数量</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。</p><p>商店中新到 <code>n</code> 支雪糕，用长度为 <code>n</code> 的数组 <code>costs</code> 表示雪糕的定价，其中 <code>costs[i]</code> 表示第 <code>i</code> 支雪糕的现金价格。Tony 一共有 <code>coins</code> 现金可以用于消费，他想要买尽可能多的雪糕。</p><p>给你价格数组 <code>costs</code> 和现金量 <code>coins</code> ，请你计算并返回 Tony 用 <code>coins</code> 现金能够买到的雪糕的 <strong>最大数量</strong> 。</p><p><strong>注意：</strong> Tony 可以按任意顺序购买雪糕。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：costs = [1,3,2,4,1], coins = 7<br>输出：4<br>解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>= 7<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：costs = <span class="hljs-string">[10,6,8,7,7,8]</span>, coins = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">0</span><br>解释：Tony 没有足够的钱买任何一支雪糕。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：costs = [1,6,3,1,2,5], coins = 20<br>输出：6<br>解释：Tony 可以买下所有的雪糕，总价为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 18 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>costs.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= costs[i] &lt;= 105</code></li><li><code>1 &lt;= coins &lt;= 108</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：贪心"><a href="#方法一：贪心" class="headerlink" title="方法一：贪心"></a>方法一：贪心</h3><p>用有限的钱，买到最多的雪糕。</p><p>从此很容易可以想到，对于价格便宜的雪糕，购买优先级高。</p><p>因此，对雪糕的价格数组 <code>costs</code> 进行排序。</p><p>每个雪糕只能买一次，因此遍历 <code>costs</code> 数组，用 <code>cnt</code> 计数买到雪糕的数量。</p><p>当将 <code>coins</code> 花完的时候，便可以得到可以购买的最大数量。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxIceCream</span>(<span class="hljs-params">self, costs: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], coins: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        costs.sort()<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> costs:<br>            <span class="hljs-keyword">if</span> coins - c &gt;= <span class="hljs-number">0</span>:<br>                coins -= c<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxIceCream</span><span class="hljs-params">(<span class="hljs-type">int</span>[] costs, <span class="hljs-type">int</span> coins)</span> &#123;<br>        Arrays.sort(costs);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c : costs) &#123;<br>            <span class="hljs-keyword">if</span>(coins - c &gt;= <span class="hljs-number">0</span>) &#123;<br>                coins -= c;<br>                cnt++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第20篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1790. Check if One String Swap Can Make Strings Equal</title>
    <link href="/2022/10/11/LC-Solution-1790-Check-if-One-String-Swap-Can-Make-Strings-Equal/"/>
    <url>/2022/10/11/LC-Solution-1790-Check-if-One-String-Swap-Can-Make-Strings-Equal/</url>
    
    <content type="html"><![CDATA[<h1 id="1790-仅执行一次字符串交换能否使两个字符串相等"><a href="#1790-仅执行一次字符串交换能否使两个字符串相等" class="headerlink" title="1790. 仅执行一次字符串交换能否使两个字符串相等"></a><a href="https://leetcode.cn/problems/check-if-one-string-swap-can-make-strings-equal/">1790. 仅执行一次字符串交换能否使两个字符串相等</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你长度相等的两个字符串 <code>s1</code> 和 <code>s2</code> 。一次 <strong>字符串交换</strong> 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。</p><p>如果对 <strong>其中一个字符串</strong> 执行 <strong>最多一次字符串交换</strong> 就可以使两个字符串相等，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;bank&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;kanb&quot;</span><br>输出：true<br>解释：例如，交换 <span class="hljs-built_in">s2</span> 中的第一个和最后一个字符可以得到 <span class="hljs-string">&quot;bank&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;attack&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;defend&quot;</span><br>输出：false<br>解释：一次字符串交换无法使两个字符串相等<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;kelb&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;kelb&quot;</span><br>输出：true<br>解释：两个字符串已经相等，所以不需要进行字符串交换<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;dcba&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li><code>1 &lt;= s1.length, s2.length &lt;= 100</code></li><li><code>s1.length == s2.length</code></li><li><code>s1</code> 和 <code>s2</code> 仅由小写英文字母组成</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：哈希表-计数"><a href="#方法一：哈希表-计数" class="headerlink" title="方法一：哈希表 + 计数"></a>方法一：哈希表 + 计数</h3><p>思路：</p><ul><li><p>先用哈希表统计字符串 <code>s1</code> 与 <code>s2</code> 的词频，只有词频相同的情况下，才可能满足题目要求的交换一次便得到相同字符串。</p></li><li><p>计数：遍历，对两个字符串逐个判断，得到不同字符数量 <code>cnt</code> 。</p><ul><li>若 <code>s1[i] != s2[i]</code>，<code>cnt += 1</code></li></ul></li><li><p>最终，当 <code>cnt == 0</code> 或 <code>cnt == 2</code>，分别对应着交换次数为0和交换次数为1的情况。（前提是两字符串词频相同）</p></li></ul><p>该方法缺点在于空间复杂度为O(n)</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">areAlmostEqual</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        dic1, dic2 = Counter(s1), Counter(s2)<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s1)):<br>            <span class="hljs-keyword">if</span> s1[i] != s2[i]:<br>                cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> (cnt == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt == <span class="hljs-number">2</span>) <span class="hljs-keyword">and</span> dic1 == dic2<br></code></pre></td></tr></table></figure><h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">areAlmostEqual</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray();<br>        Map&lt;Character, Integer&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(), map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs1.length; i++) &#123;<br>            map1.put(cs1[i], map1.getOrDefault(cs1[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            map2.put(cs2[i], map2.getOrDefault(cs2[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(cs1[i] != cs2[i]) cnt++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (cnt == <span class="hljs-number">0</span> || cnt == <span class="hljs-number">2</span>) &amp;&amp; map1.equals(map2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：纯计数"><a href="#方法二：纯计数" class="headerlink" title="方法二：纯计数"></a>方法二：纯计数</h3><p>思路：</p><p>仍然是同时遍历两字符串 <code>s1</code> 与 <code>s2</code>，用 <code>cnt</code> 统计相同下标不同字符的数量。</p><p>但不采用哈希表统计词频，而是用两个变量 <code>c1</code> 与 <code>c2</code> 记录上一次相同下标的情况下 <code>s1</code> 与 <code>s2</code> 不相同的字符。</p><p>若 <code>cnt == 2</code>时，当前 <code>s1[i] != c2</code> 或 <code>s2[i] != c1</code>，此时可能出现如下情况</p><ul><li><p><code>bank</code> 与 <code>canb</code>，隐含的意思就是两字符串词频不同，只不过这个方法咱们没有用哈希表进行统计。</p><p>因为题目中说只可交换一次，所以只需判断 <code>cnt == 2</code> 这种情况下词频是否相同。</p></li></ul><p>最终遍历完成之后，还需要判断 cnt 是否等于 1，防止出现如下情况</p><ul><li><code>bank</code> 与 <code>cank</code>，只有一个下标的字符不相同，隐含意思是词频不相同，无法交换。</li></ul><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">areAlmostEqual</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        cnt = <span class="hljs-number">0</span><br>        c1, c2 = <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s1)):<br>            <span class="hljs-keyword">if</span> s1[i] != s2[i]:<br>                cnt += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> cnt &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> (cnt == <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> (s1[i] != c2 <span class="hljs-keyword">or</span> s2[i] != c1)):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                c1, c2 = s1[i], s2[i]<br>        <span class="hljs-keyword">return</span> cnt != <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">areAlmostEqual</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, c2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs1.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(cs1[i] != cs2[i]) &#123;<br>                <span class="hljs-keyword">if</span>(++cnt &gt; <span class="hljs-number">2</span> || (cnt == <span class="hljs-number">2</span> &amp;&amp; (cs1[i] != c2 || cs2[i] != c1))) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                c1 = cs1[i];<br>                c2 = cs2[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt != <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第19篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1249. Minimum Remove to Make Valid Parentheses</title>
    <link href="/2022/10/09/LC-Solution-1249-Minimum-Remove-to-Make-Valid-Parentheses/"/>
    <url>/2022/10/09/LC-Solution-1249-Minimum-Remove-to-Make-Valid-Parentheses/</url>
    
    <content type="html"><![CDATA[<h1 id="1249-移除无效的括号"><a href="#1249-移除无效的括号" class="headerlink" title="1249. 移除无效的括号"></a><a href="https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/">1249. 移除无效的括号</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个由 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 和小写字母组成的字符串 <code>s</code>。</p><p>你需要从字符串中删除最少数目的 <code>&#39;(&#39;</code> 或者 <code>&#39;)&#39;</code> （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p><p>请返回任意一个合法字符串。</p><p>有效「括号字符串」应当符合以下 <strong>任意一条</strong> 要求：</p><ul><li>空字符串或只包含小写字母的字符串</li><li>可以被写作 <code>AB</code>（<code>A</code> 连接 <code>B</code>）的字符串，其中 <code>A</code> 和 <code>B</code> 都是有效「括号字符串」</li><li>可以被写作 <code>(A)</code> 的字符串，其中 <code>A</code> 是一个有效的「括号字符串」</li></ul><p><strong>示例1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;lee(t(c)o)de)&quot;</span><br>输出：<span class="hljs-string">&quot;lee(t(c)o)de&quot;</span><br>解释：<span class="hljs-string">&quot;lee(t(co)de)&quot;</span> , <span class="hljs-string">&quot;lee(t(c)ode)&quot;</span> 也是一个可行答案。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a)b(c)d&quot;</span><br>输出：<span class="hljs-string">&quot;ab(c)d&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;))((&quot;</span><br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：空字符串也是有效的<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 可能是 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 或英文小写字母</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：栈"><a href="#方法一：栈" class="headerlink" title="方法一：栈"></a>方法一：栈</h3><p>一看到合法括号题，第一反应首先想到用栈解决。</p><p>题目要求删掉字符串 <code>s</code> 中的无效括号，使得剩余的所有括号构成有效括号，要求删除次数尽可能的少。</p><p>简单直接地理解题目：对 <code>s</code> 做减法，删除左右括号中数量较多的一方以达成有效括号</p><p>但是应思考如何尽可能地优雅且简单地从字符串中删除对应的字符</p><p>如果直接对字符串动手脚，下标会产生变化。</p><p><strong>思路转化：</strong></p><p>选择将字符串 <code>s</code> 转为数组，将需要删除的括号置为空即代表删除。</p><p>栈用于存储 <code>&#39;(&#39;</code> 的下标，便于通过下标对字符串数组进行操作。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minRemoveToMakeValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        stack, s = [], <span class="hljs-built_in">list</span>(s)<br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                stack.append(i)<br>            <span class="hljs-keyword">elif</span> x == <span class="hljs-string">&#x27;)&#x27;</span>:<br>                <span class="hljs-keyword">if</span> stack:<br>                    stack.pop()<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 此时没有&#x27;(&#x27;与&#x27;)&#x27;配对，删除</span><br>                    s[i] = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-comment"># 栈中剩余的均为&#x27;(&#x27;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> stack:<br>            <span class="hljs-comment"># 此时没有&#x27;)&#x27;与&#x27;(&#x27;配对，删除</span><br>            s[i] = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(s)<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>Java无法直接对字符赋空值，先填一个占位字符，之后利用replace方法将其替换为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minRemoveToMakeValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(cs[i] == <span class="hljs-string">&#x27;(&#x27;</span>) stack.addLast(i);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cs[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span>(!stack.isEmpty()) stack.pollLast();<br>                <span class="hljs-keyword">else</span> cs[i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : stack) cs[i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(cs).replace(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第18篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 678. Valid Parenthesis String</title>
    <link href="/2022/10/09/LC-Solution-678-Valid-Parenthesis-String/"/>
    <url>/2022/10/09/LC-Solution-678-Valid-Parenthesis-String/</url>
    
    <content type="html"><![CDATA[<h1 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a href="https://leetcode.cn/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包含三种字符的字符串：<code>（</code> ，<code>）</code> 和 <code>*</code>，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p><ol><li>任何左括号 <code>(</code> 必须有相应的右括号 <code>)</code>。</li><li>任何右括号 <code>)</code> 必须有相应的左括号 <code>(</code> 。</li><li>左括号 <code>(</code> 必须在对应的右括号之前 <code>)</code>。</li><li><code>*</code> 可以被视为单个右括号 <code>)</code> ，或单个左括号 <code>(</code> ，或一个空字符串。</li><li>一个空字符串也被视为有效字符串。</li></ol><p><strong>示例1：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;()&quot;</span><br>输出: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;(*)&quot;</span><br>输出: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;(*))&quot;</span><br>输出: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>字符串大小将在 [1，100] 范围内。</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：双栈"><a href="#方法一：双栈" class="headerlink" title="方法一：双栈"></a>方法一：双栈</h3><p>遇到括号题，第一反应便是栈。因为栈的先进后出的特性与括号之间嵌套的特性相一致。</p><p>栈内总是存储左括号 <code>&#39;(&#39;</code>，通过右括号 <code>&#39;)&#39;</code> 与左括号 <code>&#39;(&#39;</code> 配对，使左括号出栈。</p><p>本题思路：</p><p><code>&#39;*&#39;</code> 可以表示三种字符：<code>&#39;&#39;</code> 、 <code>&#39;(&#39;</code> 、<code>&#39;)&#39;</code>，优先将 <code>&#39;*&#39;</code> 当作左括号使用。</p><p>因此使用两个栈分别存储 <code>&#39;*&#39;</code> 与 <code>&#39;(&#39;</code> 对应于 <code>s</code> 的下标。</p><ul><li><p>存储下标的意义在于：由于我们是优先将 <code>&#39;*&#39;</code> 当作左括号使用，当右括号 <code>&#39;)&#39;</code> 全部消耗完。这时候多余的 <code>&#39;*&#39;</code> 将要作为右括号 <code>&#39;)&#39;</code> 与剩余的 <code>&#39;(&#39;</code> 进行配对。右括号必须在左括号之后。因此存储下标可以帮助我们判断 <code>&#39;*&#39;</code> 与 <code>&#39;(&#39;</code> 的先后顺序是否符合合法括号的要求。</p><p><code>&#39;(&#39;</code> 使用优先级 <strong>大于</strong> <code>&#39;*&#39;</code></p></li></ul><ol><li>遍历字符串 <code>s</code> ：</li></ol><p>  . 若 <code>s[i] == &#39;(&#39;</code>， 将其添加到 <code>&#39;(&#39;</code> 栈中</p><p>  . 若 <code>s[i] == &#39;*&#39;</code>， 将其添加到 <code>&#39;*&#39;</code> 栈中</p><p>  . 若 <code>s[i] == &#39;*&#39;</code>：</p><p>  . <code>&#39;(&#39;</code> 栈 或 <code>&#39;*&#39;</code> 栈不为空时，优先使用 <code>&#39;(&#39;</code> 栈进行出栈</p><p>  . 否则，没有字符与 <code>&#39;(&#39;</code> 进行配对，返回 <code>False</code></p><ol start="2"><li>遍历 <code>&#39;(&#39;</code> 与 <code>&#39;*&#39;</code> 栈，将 <code>&#39;*&#39;</code> 当作 <code>&#39;)&#39;</code> 与 剩余 <code>&#39;(&#39;</code> 进行匹配</li></ol><p>  . 若弹出的 <code>&#39;*&#39;</code> 下标 <strong>小于</strong> 弹出的 <code>&#39;(&#39;</code>， 返回False</p><ol start="3"><li>最终判断是否仍然有剩余的 <code>&#39;(&#39;</code></li></ol><p>  . 若仍然有，返回False；否则，返回True</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkValidString</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        stack1, stack2 = [], []<br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                stack1.append(i)<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                stack2.append(i)<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;)&#x27;</span>:<br>                <span class="hljs-keyword">if</span> stack1:<br>                    stack1.pop()<br>                <span class="hljs-keyword">elif</span> stack2:<br>                    stack2.pop()<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">while</span> stack1 <span class="hljs-keyword">and</span> stack2:<br>            idx1, idx2 = stack1.pop(), stack2.pop()<br>            <span class="hljs-keyword">if</span> idx1 &gt; idx2:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> stack1<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkValidString</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        Deque&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(cs[i] == <span class="hljs-string">&#x27;(&#x27;</span>) stack1.addLast(i);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cs[i] == <span class="hljs-string">&#x27;*&#x27;</span>) stack2.addLast(i);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(!stack1.isEmpty()) stack1.pollLast();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!stack2.isEmpty()) stack2.pollLast();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!stack1.isEmpty() &amp;&amp; !stack2.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx1</span> <span class="hljs-operator">=</span> stack1.pollLast(), idx2 = stack2.pollLast();<br>            <span class="hljs-keyword">if</span>(idx1 &gt; idx2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack1.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第17篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 856. Score of Parentheses</title>
    <link href="/2022/10/09/LC-Solution-856-Score-of-Parentheses/"/>
    <url>/2022/10/09/LC-Solution-856-Score-of-Parentheses/</url>
    
    <content type="html"><![CDATA[<h1 id="856-Score-of-Parentheses"><a href="#856-Score-of-Parentheses" class="headerlink" title="856. Score of Parentheses"></a><a href="https://leetcode.cn/problems/score-of-parentheses/">856. Score of Parentheses</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个平衡括号字符串 <code>S</code>，按下述规则计算该字符串的分数：</p><ul><li><code>()</code> 得 1 分。</li><li><code>AB</code> 得 <code>A + B</code> 分，其中 A 和 B 是平衡括号字符串。</li><li><code>(A)</code> 得 <code>2 * A</code> 分，其中 A 是平衡括号字符串。</li></ul><p><strong>示例1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入： <span class="hljs-string">&quot;()&quot;</span><br>输出： <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入： <span class="hljs-string">&quot;(())&quot;</span><br>输出： <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">输入： &quot;()()&quot;<br>输出： <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">输入： &quot;(()(()))&quot;<br>输出： <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>S</code> 是平衡括号字符串，且只含有 <code>(</code> 和 <code>)</code> 。</li><li><code>2 &lt;= S.length &lt;= 50</code></li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：根据-计数"><a href="#方法一：根据-计数" class="headerlink" title="方法一：根据()计数"></a>方法一：根据()计数</h3><p>分析题意可知，外层括号所累加的分数都与最里括号 <code>&#39;()&#39;</code> 有关。</p><ul><li><p>假设当前括号深度为 <code>d</code>，每一个 <code>&#39;()&#39;</code> 的得分为 <code>2 ** d</code> 或者 <code>1 &lt;&lt; d</code></p></li><li><p>最后的总分数与 <code>&#39;()&#39;</code> 的数量有关。</p></li></ul><p>举例说明：<code>&#39;(()(()))&#39;</code>，利用乘法分配律可表示为 <code>&#39;(()) + ((()))&#39;</code></p><p>共有两个 <code>&#39;()&#39;</code>，其分数为 <code>2 ** 1 + 2 ** 2 = 6</code></p><p>所以，我们只需要找到 <code>s</code> 中的每一个 <code>&#39;()&#39;</code> 即可</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">scoreOfParentheses</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans, d = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            d += <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> v == <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> v == <span class="hljs-string">&#x27;)&#x27;</span> <span class="hljs-keyword">and</span> s[i - <span class="hljs-number">1</span>] ==<span class="hljs-string">&#x27;(&#x27;</span>:<br>                ans += <span class="hljs-number">1</span> &lt;&lt; d<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">scoreOfParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, d = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            d += s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                ans += <span class="hljs-number">1</span> &lt;&lt; d;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：栈"><a href="#方法二：栈" class="headerlink" title="方法二：栈"></a>方法二：栈</h3><p>采用栈记录字符串 <code>s</code> 对应的分数。初始栈顶部的分数为0。</p><p>遍历字符串：</p><ol><li><p>若 <code>s[i] == &#39;(&#39;</code>，先将分数0压入栈顶占位</p></li><li><p>若 <code>s[i] == &#39;)&#39;</code>，此时有两种情况：</p></li></ol><ul><li><p><code>s[i - 1] == &#39;(&#39;</code>，这是一个 <code>&#39;()&#39;</code>， 此时栈顶值 <code>v</code> 为0，该分数为1</p></li><li><p><code>s[i - 1] != &#39;(&#39;</code>，这是一个外层括号，该分数为栈顶值 <code>v</code> × 2</p></li></ul><p>  两种情况综合为 <code>max(v * 2, 1)</code></p><p>  将栈顶值出栈计算完成之后，再将计算结果累加到当前的栈顶值。</p><p>最终返回结果为栈顶值。</p><p>这是因为一开始还未遍历字符串 <code>s</code> 时，就已经初始化了栈顶值。而且该字符串 <code>s</code> 为平衡括号字符串，说明 <code>&#39;(&#39; </code>与 <code>&#39;)&#39;</code> 数量一致，所以最后栈中一个值，即为最终分数。</p><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">scoreOfParentheses</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        stack = [<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                stack.append(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">else</span>:<br>                v = stack.pop()<br>                stack[-<span class="hljs-number">1</span>] += <span class="hljs-built_in">max</span>(v * <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> stack[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">scoreOfParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        stack.addLast(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span>) stack.addLast(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> stack.pollLast();<br>                stack.addLast(stack.pollLast() + Math.max(v * <span class="hljs-number">2</span>, <span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.pollLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第16篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式锁学习笔记</title>
    <link href="/2022/10/09/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/09/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式锁学习笔记"><a href="#分布式锁学习笔记" class="headerlink" title="分布式锁学习笔记"></a>分布式锁学习笔记</h1><p>分布式锁学习笔记持续更新中，预计10月下旬更完~ </p><p>该笔记中除了视频中核心的笔记、代码，还额外补充了视频中老师讲解过的但官方笔记中没有提到的重要内容。 </p><p>有错误或者遗漏的地方请大家提出来呀，有不懂的地方留言我尽量回答（毕竟我也很菜~</p><p>2022.10.14:更换图床解决了图片加载问题</p><p>2022.10.16:基于Redis的分布式锁笔记已更完…（p51之前）</p><p>2022.10.17:zookeeper基础已更完…（p62之前）</p><p>2022.10.21:完结撒花~，笔记全部做完啦（Curator底层原理加锁部分待完善…</p><h2 id="1-传统锁-减库存案例"><a href="#1-传统锁-减库存案例" class="headerlink" title="1. 传统锁 - 减库存案例"></a>1. 传统锁 - 减库存案例</h2><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/stock.png"></p><p>多线程同时操纵同一个服务的共享资源，必然会造成线程安全问题。</p><p>解决方案：采用JVM提供的 <code>Reentrantlock</code> 或者 <code>Synchronized</code> 锁</p><h3 id="1-1-初始化工程"><a href="#1-1-初始化工程" class="headerlink" title="1.1 初始化工程"></a>1.1 初始化工程</h3><p>这一部分跟着视频完成，以下内容省略了未连接数据库之前的部分（个人认为之前未连接数据库的部分仅演示了并发流程，与实际业务关联性不大，也较为容易，可自行实现）。</p><ol><li><p>创建SpringBoot工程，选择 <code>JDK8</code> 版本，引入 <code>Spring Web</code></p></li><li><p>在 <code>pom.xml</code>引入如下依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>创建数据库 <code>distributed_lock</code>，在数据库内创建表 <code>db_stock</code>，创建如下字段。</p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008221626.png"></p><p> 新建一条数据记录</p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008221728.png"></p></li><li><p>修改application.properties文件，规定Web启动端口号</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">10010</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/distributed_lock</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">your password</span><br></code></pre></td></tr></table></figure></li><li><p>在目录下创建 <code>pojo</code> 包，用于存放实体类 <code>Stock</code> 对象</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;db_stock&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span> &#123;<br><br><span class="hljs-keyword">private</span> Long id;<br><span class="hljs-keyword">private</span> String productCode;<br><span class="hljs-keyword">private</span> String warehouse;<br><span class="hljs-keyword">private</span> Integer count;<br>&#125;<br></code></pre></td></tr></table></figure><p> 创建 <code>mapper</code> 包，创建 <code>StockMapper</code> 类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StockMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Stock&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p> 更改 <code>SpringBoot</code> 启动类，添加如下注解</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.ltyzzz.distributedlock.mapper&quot;)</span><br></code></pre></td></tr></table></figure><p> 创建 <code>service</code> 包，创建 <code>StockService</code> 类</p><p> try-finally块之后用于加锁</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockService</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StockMapper stockMapper;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stockMapper.selectOne(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;product_code&quot;</span>, <span class="hljs-string">&quot;1001&quot;</span>));<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>            stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">this</span>.stockMapper.updateById(stock);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 创建 <code>controller</code> 包，创建 <code>StockController</code> 类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    StockService stockService;<br><br>    <span class="hljs-meta">@GetMapping(&quot;stock/deduct&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>        stockService.deduct();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello stock deduct!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-2-JVM本地锁"><a href="#1-2-JVM本地锁" class="headerlink" title="1.2 JVM本地锁"></a>1.2 JVM本地锁</h3><h4 id="1-2-1-使用JMeter进行并发测试"><a href="#1-2-1-使用JMeter进行并发测试" class="headerlink" title="1.2.1 使用JMeter进行并发测试"></a>1.2.1 使用JMeter进行并发测试</h4><p>首先启动 SpringBoot 库存项目</p><p>利用 <code>JMeter</code> 进行压力测试</p><ol><li><p>创建 <code>Thread Group</code></p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/thread-group.png"></p></li><li><p>设置 <code>Thread Properties</code></p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/thread-proper.png"></p></li><li><p>设置 <code>request</code> </p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/reque.png"></p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008224501.png"></p></li><li><p>添加 <code>Aggregate Report</code></p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008224122.png"></p></li><li><p>运行压力测试，正常执行情况最终库存应该为0</p></li></ol><p>最终数据库结果如下</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/data%20stcok.png"></p><p>此时产生了并发操作</p><p>有两种极限情况</p><ul><li><p>所有并发请求都完美的交错执行，正确地完成了数据库更新，最终库存为0</p></li><li><p>所有并发请求同一时间并发，同时执行了数据库更新操作，并发线程数为100，循环次数为50，最终库存为4950</p></li></ul><h4 id="1-2-2-加入JVM本地锁解决并发问题"><a href="#1-2-2-加入JVM本地锁解决并发问题" class="headerlink" title="1.2.2 加入JVM本地锁解决并发问题"></a>1.2.2 加入JVM本地锁解决并发问题</h4><p>修改 <code>StockService</code>。使用 <code>ReentrantLock</code> 或 <code>Synchronized</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StockMapper stockMapper;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stockMapper.selectOne(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;product_code&quot;</span>, <span class="hljs-string">&quot;1001&quot;</span>));<br>            <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>                stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">this</span>.stockMapper.updateById(stock);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动 <code>SpringBoot</code> 工程，继续进行压力测试，最终库存为0。</p><h4 id="1-2-3-JVM本地锁失效的情况"><a href="#1-2-3-JVM本地锁失效的情况" class="headerlink" title="1.2.3 JVM本地锁失效的情况"></a>1.2.3 JVM本地锁失效的情况</h4><p>共有三种情况</p><h5 id="多例模式"><a href="#多例模式" class="headerlink" title="多例模式"></a>多例模式</h5><p>修改 <code>StockService</code>，设置多例模式</p><p>添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scope(value = &quot;prototype&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br></code></pre></td></tr></table></figure><p>JDK动态代理使用 <code>INTERFACES</code>，CGLIB代理使用 <code>TARGET_CLASS</code></p><p>默认情况下使用JDK动态代理，原生Spring默认是JDK动态代理</p><p>而SpringBoot在2.0版本之后默认使用CGLIB代理</p><p>启动 <code>SpringBoot</code> 工程，继续进行压力测试，最终库存不为0，说明本地锁失效</p><h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>在 <code>service</code> 方法上添加事务注解 <code>@Transactional</code></p><p>启动 <code>SpringBoot</code> 工程，继续进行压力测试，最终库存不为0，说明本地锁失效</p><p>事务采用AOP思想实现：</p><ol><li><p>在AOP的前置方法内开启事务</p></li><li><p>进入service方法，获取锁</p></li><li><p>进行查询库存、更新库存操作</p></li><li><p>释放锁</p></li><li><p>在AOP的后置方法内提交或回滚事务</p></li></ol><p>在并发情况下，如图所示</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/tab.png" title="" alt="" width="236"><p>b用户在a用户还未提交事务之前，就获取到了a用户释放的锁，读取到了库存，但该库存为旧的库存（因为a用户还未提交事务），所以b用户是在旧库存的基础上进行修改，因此产生了并发问题。</p><p>解决方案：设置事务隔离级别</p><p>将注解改为：<code>@Transactional(isolation = Isolation.READ_UNCOMMITTED)</code></p><p>即此时b用户可以读取到a用户未提交的数据，即该数据为最新数据，可以解决此问题。</p><p>但实际业务中不能这样去使用，采用事务就是为了保证原子性，要么全部成功，要么全部失败。假设b用户在这种方式下读取到了最新数据，虽然可以解决超卖问题，但是如果a回滚了事务，那么b用户读取到的数据就是错误的，又会产生新的混乱。</p><h5 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h5><p>多个服务器部署</p><p>去掉 <code>@Transactional</code> 注解，保证在单机模式下锁生效，无并发问题。</p><p>这部分看视频做</p><ol><li><p>设置两个SpringBoot启动类，设置不同的端口号，并启动</p></li><li><p>更改 <code>nginx</code> 配置文件</p> <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> distributedLock &#123;<br>    <span class="hljs-attribute">server</span> localhost:<span class="hljs-number">10086</span>;<br>    <span class="hljs-attribute">server</span> localhost:<span class="hljs-number">10010</span>;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://distributedLock;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启动nginx</p></li></ol><p>任务管理器中出现两个nginx即代表启动成功，一个工作进程，一个主进程</p><p>以默认端口80进行访问：<code>localhost:80/stock/deduct</code></p><p>之后，使用JMeter进行压力测试，5000个请求成功发出，但最终库存不为0，锁失效。</p><h3 id="1-3-单SQL语句解决并发问题"><a href="#1-3-单SQL语句解决并发问题" class="headerlink" title="1.3 单SQL语句解决并发问题"></a>1.3 单SQL语句解决并发问题</h3><h4 id="1-3-1-实现过程"><a href="#1-3-1-实现过程" class="headerlink" title="1.3.1 实现过程"></a>1.3.1 实现过程</h4><p>原 <code>Service</code> 代码流程</p><ol><li><p>查询库存</p></li><li><p>判断库存是否充足</p></li><li><p>更新库存到数据库</p></li></ol><p>该流程可以使用一个SQL语句实现</p><p>为 <code>StockMapper</code> 添加方法 updateStock，</p><p>参数为商品编号 <code>productCode</code> 与减库存数量<code>count</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StockMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Stock&gt; &#123;<br>    <span class="hljs-meta">@Update(&quot;update db_stock set count = count - #&#123;count&#125; where product_code = #&#123;productCode&#125; and count &gt;= #&#123;count&#125;&quot;)</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateStock</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;productCode&quot;)</span> String productCode, <span class="hljs-meta">@Param(&quot;count&quot;)</span> Integer count)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>SQL语句如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">update</span> db_stock <span class="hljs-keyword">set</span> <span class="hljs-built_in">count</span> = <span class="hljs-built_in">count</span> - #&#123;<span class="hljs-built_in">count</span>&#125; <span class="hljs-keyword">where</span> product_code = #&#123;productCode&#125; <span class="hljs-keyword">and</span> <span class="hljs-built_in">count</span> &gt;= #&#123;<span class="hljs-built_in">count</span>&#125;<br></code></pre></td></tr></table></figure><p>在MySQL中，更新、新增、删除写操作，会加悲观锁，具有原子性，可以解决并发问题。</p><p>在 <code>StockService</code> 中调用该Mapper方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockMapper.updateStock(<span class="hljs-string">&quot;1001&quot;</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在集群部署情况下，使用JMeter进行压力测试，5000个请求成功发出，最终库存为0。</p><h4 id="1-3-2-优缺点"><a href="#1-3-2-优缺点" class="headerlink" title="1.3.2 优缺点"></a>1.3.2 优缺点</h4><p>优点：</p><ol><li>可以解决多例模式、事务、集群部署下的并发问题</li></ol><p>缺点：</p><ol><li><p>锁范围问题</p></li><li><p>同一个商品有多条库存记录（多仓库）</p><ul><li><p>如果仍然使用该方法，则会对所有仓库库存数进行自减</p></li><li><p>正常情况应灵活从各个仓库进行减库存发货</p></li></ul></li><li><p>无法记录库存变化前后的状态</p><ul><li>原因：单条SQL语句</li></ul></li></ol><h5 id="锁范围问题"><a href="#锁范围问题" class="headerlink" title="锁范围问题"></a>锁范围问题</h5><p>表级锁 VS 行级锁</p><ul><li><p>未添加索引之前为 <code>表级锁</code></p><ul><li><p>在用户a中，先开启事务，再去更新 <code>productCode = 1001</code> 记录，但不提交事务</p></li><li><p>这导致：在用户b中，更新 <code>productCode = 1002</code> 记录，但进入了阻塞</p></li><li><p>用户a提交了事务之后，用户b才能提交成功，证明为表级锁</p></li></ul></li><li><p>添加索引之后为 <code>行级锁</code></p><ol><li><p>锁的查询或更新条件必须为索引字段</p><p> e.g.：根据 <code>productCode</code> 进行查询或更新，为其添加索引</p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/iShot2022-10-08%2023.44.31.png"></p></li><li><p>再次进行之前的操作，用户b不会进入阻塞，即变为了行级锁</p></li><li><p>使用行级锁的条件：</p><p> . 查询或者更新条件必须为索引字段</p><p> . 查询或者更新条件必须为具体值</p><p>   . SQL语句中where条件有索引时，不能为 <code>&#39;like&#39;</code> 或者 <code>&#39;!=&#39;</code>，否则为表级锁</p></li></ol></li></ul><h3 id="1-4-悲观锁"><a href="#1-4-悲观锁" class="headerlink" title="1.4 悲观锁"></a>1.4 悲观锁</h3><p>select … for update</p><h4 id="1-4-1-情景引入"><a href="#1-4-1-情景引入" class="headerlink" title="1.4.1 情景引入"></a>1.4.1 情景引入</h4><p>用户a与b并发执行</p><ol><li><p>用户a开启事务，并使用如下SQL语句查询库存</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> db_stock <span class="hljs-keyword">where</span> product_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1001&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>用户b使用如下SQL语句</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> db_stock <span class="hljs-keyword">set</span> count <span class="hljs-operator">=</span> count <span class="hljs-operator">-</span> <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li></ol><p>这时库存已经发生变化，而用户a不知情，仍会已它查出来的库存数作为标准进行下一步操作</p><p>解决方案：用户a采用如下SQL语句，进行加锁操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> db_stock <span class="hljs-keyword">where</span> product_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1001&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>加锁范围：此时满足行级锁条件，因此该悲观锁为行级锁，只锁对应的记录</p><h4 id="1-4-2-代码实现"><a href="#1-4-2-代码实现" class="headerlink" title="1.4.2 代码实现"></a>1.4.2 代码实现</h4><ol><li><p>在StockMapper中添加查询库存方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from db_stock where product_code=#&#123;productCode&#125; for update&quot;)</span><br>List&lt;Stock&gt; <span class="hljs-title function_">queryStock</span><span class="hljs-params">(String productCode)</span>;<br></code></pre></td></tr></table></figure></li><li><p>更新StockService方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询库存信息并锁定</span><br>    List&lt;Stock&gt; stocks = <span class="hljs-built_in">this</span>.stockMapper.queryStock(<span class="hljs-string">&quot;1001&quot;</span>);<br>    <span class="hljs-comment">// 取第一个库存</span><br>    <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> stocks.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 扣减库存</span><br>        stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">this</span>.stockMapper.updateById(stock);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用压力测试工具进行测试，库存数量减为0，解决了并发问题</p></li></ol><h4 id="1-4-3-优缺点"><a href="#1-4-3-优缺点" class="headerlink" title="1.4.3 优缺点"></a>1.4.3 优缺点</h4><p>优点：更加灵活</p><ol><li><p>解决同一个商品有多条库存记录的问题</p><p> 可以先根据商品编号查询库存记录，查询到之后再根据现有技术分析。</p></li><li><p>解决无法记录库存变化前后状态的问题</p></li></ol><p>缺点：</p><ol><li><p>性能问题：效率比JVM本地锁稍高一些，但比单SQL语句低</p></li><li><p>死锁问题：对多条数据加锁时，加锁顺序必须一致</p><p> e.g.：用户a与b执行如下顺序操作</p><ol><li><p>用户a对 <code>id=1</code> 商品加锁 </p></li><li><p>用户b对 <code>id=2</code> 商品加锁</p></li><li><p>用户a想对 <code>id=2</code> 商品加锁，但陷入阻塞</p></li><li><p>用户b想对 <code>id=1</code> 商品加锁，报错 Deadlock</p></li></ol></li><li><p>库存操作需要统一</p></li></ol><h3 id="1-5-乐观锁"><a href="#1-5-乐观锁" class="headerlink" title="1.5 乐观锁"></a>1.5 乐观锁</h3><p>借助时间戳、version版本号实现，利用 <code>CAS</code> 机制</p><p>CAS：Compare and Swap 比较并交换</p><p>关于CAS，可以看看这篇博客：<a href="https://www.cnblogs.com/myopensource/p/8177074.html">漫画：什么是CAS机制</a></p><ul><li><p>如果变量 <code>X</code> 等于旧值 <code>A</code>，则更新将 <code>X</code> 更新为 <code>B</code> </p></li><li><p>若不等于，则放弃更新</p></li></ul><h4 id="1-5-1-实现思路"><a href="#1-5-1-实现思路" class="headerlink" title="1.5.1 实现思路"></a>1.5.1 实现思路</h4><ol><li><p>在 <code>db_stock</code> 表中添加 <code>version</code> 字段</p><p> 类型为int，长度11，Not Null</p></li><li><p>查询对应的商品库存以及 <code>version</code> 号</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> db_stock <span class="hljs-keyword">where</span> product_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1001&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>执行更新库存操作时，where条件中需要确认当前 <code>version</code> 是否等于之前查出来的</p><p> . 若等于，则更新库存操作成功</p><p> . 否则，则说明存在并发操作，该条库存数据已被修改。继续查询重试</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> db_stock <span class="hljs-keyword">SET</span> count<span class="hljs-operator">=</span><span class="hljs-number">4999</span>, version<span class="hljs-operator">=</span>version<span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> version<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li></ol><h4 id="1-5-2-代码实现"><a href="#1-5-2-代码实现" class="headerlink" title="1.5.2 代码实现"></a>1.5.2 代码实现</h4><p>在 Stock 实体类中添加 <code>version</code> 属性，类型为Integer</p><p>修改 StcokService 中的deduct()方法</p><h5 id="第一版代码"><a href="#第一版代码" class="headerlink" title="第一版代码"></a>第一版代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询库存信息并锁定</span><br>    List&lt;Stock&gt; stocks = <span class="hljs-built_in">this</span>.stockMapper.selectList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;product_code&quot;</span>, <span class="hljs-string">&quot;1001&quot;</span>));<br>    <span class="hljs-comment">// 取第一个库存</span><br>    <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> stocks.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 扣减库存</span><br>        stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> stock.getVersion();<br>        stock.setVersion(version + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stockMapper.update(stock, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;id&quot;</span>, stock.getId()).eq(<span class="hljs-string">&quot;version&quot;</span>, version));<br>        <span class="hljs-keyword">if</span> (update == <span class="hljs-number">0</span>) &#123;<br>            deduct();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>采用JMeter压力测试工具测试时，报错</p><p>错误分析：</p><ol><li><p>stack over flow：栈溢出</p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/stackoverflow.png"></p><p> 这是由于高并发的情况下，更新失败率很高，就会不断地递归调用deduct方法，导致栈溢出。</p><p> 解决方案：调用线程类中的sleep方法，暂时睡眠，避开并发高峰</p></li><li><p>连接超时错误</p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/timeout.png"></p><p> 这是由于开启了事务注解，为手动事务。</p><p> 当执行到更新操作时，会对数据进行加锁。而当前请求无法更新，就会一直调用deduct方法，并一直持有锁。其他请求进入代码，会进入阻塞状态，直至连接超时。</p><p> 而关闭了事务注解，为自动事务。若更新操作执行失败，会放弃锁。</p></li></ol><h5 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询库存信息并锁定</span><br>    List&lt;Stock&gt; stocks = <span class="hljs-built_in">this</span>.stockMapper.selectList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;product_code&quot;</span>, <span class="hljs-string">&quot;1001&quot;</span>));<br>    <span class="hljs-comment">// 取第一个库存</span><br>    <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> stocks.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 扣减库存</span><br>        stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> stock.getVersion();<br>        stock.setVersion(version + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stockMapper.update(stock, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;id&quot;</span>, stock.getId()).eq(<span class="hljs-string">&quot;version&quot;</span>, version));<br>        <span class="hljs-keyword">if</span> (update == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">20</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            deduct();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过JMeter测试，最终库存减为0</p><h4 id="1-5-3-优缺点"><a href="#1-5-3-优缺点" class="headerlink" title="1.5.3 优缺点"></a>1.5.3 优缺点</h4><p>推荐阅读：<a href="https://www.cnblogs.com/qjjazry/p/6581568.html">Java并发问题–乐观锁与悲观锁以及乐观锁的一种实现方式-CAS</a></p><p>优点：</p><ol><li>乐观锁在竞争不激烈时，较悲观锁更具有优势，因为悲观锁会锁住代码块，并且加锁、释放锁、线程上下文均占用额外资源。</li></ol><p>缺点：</p><ol><li><p>在高并发情况下，乐观锁的性能不如悲观锁，因为重试次数过多。</p></li><li><p>乐观锁存在ABA问题</p><p> . 在查询与更新的中间，<code>X</code> 值被多次更改，但最终又回到了查询时的值</p></li><li><p>读写分离情况下，乐观锁不可靠</p><p> 从数据库与主数据库进行网络传输，具有较大时延，可能主数据库内是新数据，而从数据库内是旧数据，乐观锁下会造成从数据库不断地重试，</p></li></ol><h3 id="1-6-MySQL锁总结"><a href="#1-6-MySQL锁总结" class="headerlink" title="1.6 MySQL锁总结"></a>1.6 MySQL锁总结</h3><p>性能：单SQL语句 &gt; 悲观锁 &gt; JVM锁 &gt; 乐观锁</p><ul><li><p>追求极致性能、业务场景简单、无需记录数据更新前后变化的情况下 -&gt; 单SQL语句</p></li><li><p>并发量低、读多于写、竞争不激烈的情况下 -&gt; 乐观锁</p></li><li><p>并发量高、冲突激烈 -&gt; 悲观锁</p></li><li><p>不推荐JVM锁</p></li></ul><h3 id="1-7-Redis锁"><a href="#1-7-Redis锁" class="headerlink" title="1.7 Redis锁"></a>1.7 Redis锁</h3><h4 id="1-7-1-并发问题引入"><a href="#1-7-1-并发问题引入" class="headerlink" title="1.7.1 并发问题引入"></a>1.7.1 并发问题引入</h4><ol><li><p>在Maven工程pom.xml文件中加入依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在application.properties文件中配置redis</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.redis.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure></li><li><p>更改 StockService类中的deduct方法</p><p> 采用StringRedisTemplate更加方便</p><p> 而RedisTemplate需要手动设置序列化器</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询库存信息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>);<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>        <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 扣减库存</span><br>            <span class="hljs-built_in">this</span>.redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在redis-cli命令窗口中，设置库存：<code>set stock 5000</code></p></li></ol><p>启动SpringBoot与压力测试工具JMeter，最终库存不为0，出现并发问题。</p><h4 id="1-7-2-解决方案"><a href="#1-7-2-解决方案" class="headerlink" title="1.7.2 解决方案"></a>1.7.2 解决方案</h4><ol><li><p>JVM本地锁机制（较简单不做演示）</p></li><li><p>Redis乐观锁：<code>watch</code> <code>multi</code> <code>exec</code></p><ol><li><p>watch：监控一个或多个key的值，如果exec执行之前，如果key的值发生变化，则取消事务执行。</p></li><li><p>multi：开启事务</p></li><li><p>exec：执行事务</p></li></ol></li></ol><h4 id="1-7-3-代码实现"><a href="#1-7-3-代码实现" class="headerlink" title="1.7.3 代码实现"></a>1.7.3 代码实现</h4><p>修改StockService中的deduct方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionCallback</span>&lt;Object&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">execute</span><span class="hljs-params">(RedisOperations operations)</span> <span class="hljs-keyword">throws</span> DataAccessException &#123;<br>            operations.watch(<span class="hljs-string">&quot;stock&quot;</span>);<br>            <span class="hljs-comment">// 查询库存信息</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> operations.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>            <span class="hljs-comment">// 判断库存是否充足</span><br>            <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>                <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// multi</span><br>                    operations.multi();<br>                    <span class="hljs-comment">// 扣减库存</span><br>                    operations.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>                    <span class="hljs-comment">// exec 执行事务</span><br>                    <span class="hljs-type">List</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> operations.exec();<br>                    <span class="hljs-comment">// 如果事务执行结果为空，代表操作失败，重试</span><br>                    <span class="hljs-keyword">if</span> (exec == <span class="hljs-literal">null</span> || exec.size() == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            Thread.sleep(<span class="hljs-number">40</span>);<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                        &#125;<br>                        deduct();<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> exec;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>采用JMeter进行并发测试后，库存减为0，解决了并发问题</p><p>但是吞吐量性能较低，甚至可能由于电脑性能问题，出现连接不够用的情况。</p><h2 id="2-Redis分布式锁"><a href="#2-Redis分布式锁" class="headerlink" title="2. Redis分布式锁"></a>2. Redis分布式锁</h2><h3 id="2-1-实现思路"><a href="#2-1-实现思路" class="headerlink" title="2.1 实现思路"></a>2.1 实现思路</h3><p>借助于redis中的命令 <code>setnx(key, value)</code></p><p>设置 <code>key</code> 为lock</p><ul><li>若 <code>lock</code> 存在，则说明有其他请求已经获取到锁，则当前请求重复重试</li><li>若 <code>lock</code> 不存在，则说明当前锁未被获取，当前请求获取锁成功，继续执行业务操作</li><li>设置 <code>lock</code> 之后，只有一个请求可以获取到锁并执行成功，其他请求只能等待</li></ul><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/1606626611922.png"></p><h3 id="2-2-基本代码实现"><a href="#2-2-基本代码实现" class="headerlink" title="2.2 基本代码实现"></a>2.2 基本代码实现</h3><h4 id="2-2-1-递归版本"><a href="#2-2-1-递归版本" class="headerlink" title="2.2.1 递归版本"></a>2.2.1 递归版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 加锁setnx</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);<br>    <span class="hljs-comment">// 递归调用</span><br>    <span class="hljs-keyword">if</span> (!lock) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        deduct();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 查询库存信息</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>            <span class="hljs-comment">// 判断库存是否充足</span><br>            <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>                <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 扣减库存</span><br>                    redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 解锁</span><br>            <span class="hljs-built_in">this</span>.redisTemplate.delete(<span class="hljs-string">&quot;lock&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-循环版本"><a href="#2-2-2-循环版本" class="headerlink" title="2.2.2 循环版本"></a>2.2.2 循环版本</h4><p>注意：即使不采用递归版本，在重试获取锁的过程中，也可以使用线程睡眠，这样可以减小锁的竞争压力，提升性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 加锁setnx</span><br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>)) &#123;<br>        <span class="hljs-comment">// 循环重试</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 查询库存信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-comment">// 判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 解锁</span><br>        <span class="hljs-built_in">this</span>.redisTemplate.delete(<span class="hljs-string">&quot;lock&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-问题解决"><a href="#2-3-问题解决" class="headerlink" title="2.3 问题解决"></a>2.3 问题解决</h3><h4 id="2-3-1-死锁与原子性"><a href="#2-3-1-死锁与原子性" class="headerlink" title="2.3.1 死锁与原子性"></a>2.3.1 死锁与原子性</h4><p>在某一请求获取到lock锁之后，当前服务器突然宕机，造成该锁无法得到释放，此时其他请求仍然处于不断地递归或循环重试获取锁，造成死循环。</p><p>解决方案：获取到lock之后，为lock设置过期时间，<code>expire</code> 指令</p><p>但是：可能在 获取lock 与 为lock设置过期时间 之间，服务器发生宕机。</p><p>因此，需要确保两个操作的原子性：采用如下指令，将多个操作复合到一个指令中</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set</span> lock <span class="hljs-number">123</span> ex <span class="hljs-number">20</span> nx<br></code></pre></td></tr></table></figure><p>修改加锁部分的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;<br>    <span class="hljs-comment">// 循环重试</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">50</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-防误删"><a href="#2-3-2-防误删" class="headerlink" title="2.3.2 防误删"></a>2.3.2 防误删</h4><p>假设处理请求的时长大于锁的有效时间，当某一请求还未执行完当前操作时，Redis锁便会自动释放掉（删除lock），等到该请求执行完当前操作后，还会手动地将Redis锁释放掉。此时，可能别的请求已经获取到了锁，那么该锁很有可能被该请求误删掉。</p><p><strong>解决方案：</strong></p><p>为了防止出现这一情况，需要为当前锁设置唯一标识UUID，作为锁的值。</p><p>在删除锁之前，先判断当前锁是否属于自己，然后再进行删除。</p><p>修改 StockService 的 deduct方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>    <span class="hljs-comment">// 加锁setnx</span><br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, uuid, <span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;<br>        <span class="hljs-comment">// 循环重试</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 查询库存信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-comment">// 判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 先判断，再解锁</span><br>        <span class="hljs-keyword">if</span> (StringUtils.equals(<span class="hljs-built_in">this</span>.redisTemplate.opsForValue().get(<span class="hljs-string">&quot;lock&quot;</span>), uuid)) &#123;<br>            <span class="hljs-built_in">this</span>.redisTemplate.delete(<span class="hljs-string">&quot;lock&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断与删除操作需要保证原子性，否则还会出现并发问题</p><ul><li>刚判断完该锁是自己的，还没进行删除，锁就到期自动释放且被其他请求获取，此时会造成误删操作</li></ul><p>借助 <code>lua</code> 脚本实现原子性操作：<a href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程 | 菜鸟教程</a></p><p>redis-cli支持lua脚本，可以一次性给redis发送多个指令。</p><ul><li>redis为单线程，执行指令遵守 <code>one-by-one</code> 规则</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">EVAL script numkeys <span class="hljs-comment">[key <span class="hljs-comment">[key ...]</span>]</span> <span class="hljs-comment">[arg <span class="hljs-comment">[arg ...]</span>]</span><br></code></pre></td></tr></table></figure><p>删除LUA脚本：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>更改代码中finally部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先判断，再解锁</span><br><span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] &quot;</span> +<br>        <span class="hljs-string">&quot;then return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +<br>        <span class="hljs-string">&quot;else return 0 &quot;</span> +<br>        <span class="hljs-string">&quot;end&quot;</span>;<br><span class="hljs-built_in">this</span>.redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(<span class="hljs-string">&quot;lock&quot;</span>), uuid);<br></code></pre></td></tr></table></figure><h4 id="2-3-3-可重入性"><a href="#2-3-3-可重入性" class="headerlink" title="2.3.3 可重入性"></a>2.3.3 可重入性</h4><p>之前的加锁指令采用的是Redis中的 <code>setnx</code> 指令，即锁的名字固定为lock（键值固定），一旦加锁成功（键设置成功），该线程便无法继续加锁。如下即为具体情景代码：</p><p>某线程执行a方法，获取到锁之后，其又需要继续执行b方法，需要继续获取锁。但此时锁已经被自己占有，相当于自己和自己产生了死锁，这是不可重入锁带来的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>    b();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解决方案：可重入锁</strong></p><p>可重入锁可：当某一线程获得锁之后，需要再次执行加锁方法时（锁对象为同一个），将加锁次数加1即可。执行完毕之后，释放锁时对加锁次数减1。当加锁次数等于0时，说明该锁已经被完全释放。</p><p>当可重入锁需要在分布式环境实现时，需要统计加锁次数。</p><p><strong>实现方案：Redis Hash + lua脚本</strong></p><p>加锁 -&gt; 判断锁是否存在：<code>exists</code></p><ul><li><p>若不存在，则直接创建锁并获取：<code>hset key field value</code></p></li><li><p>若存在，则判断当前锁是否属于自己：<code>hexists</code></p><ul><li><p>若属于，则重入：<code>hincrby key field increment</code></p></li><li><p>若不属于，递归或循环自旋重试</p></li></ul></li></ul><p><strong>加锁脚本</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span> <br><span class="hljs-keyword">then</span><br>    redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>)<br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>解锁 -&gt; 判断锁是否属于自己：<code>hexists</code></p><ul><li><p>若不属于，说明正在恶意释放锁，返回 <code>nil</code></p></li><li><p>若属于，对加锁次数减1，并判断当前加锁次数是否为0</p><ul><li><p>若为0，则返回1，代表完全解锁成功</p></li><li><p>若不为0，则返回0</p></li></ul></li></ul><p><strong>解锁脚本</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span><br><span class="hljs-keyword">then</span> <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">elseif</span> redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>], <span class="hljs-number">-1</span>) == <span class="hljs-number">0</span><br><span class="hljs-keyword">then</span> <br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><strong>代码实现</strong></p><ol><li><p>创建分布式锁的工厂类方法。通过一个工厂类方法，可以获得不同的分布式锁（基于Redis、基于Zookeeper、基于MySQL）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributedLockClient</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br>    <span class="hljs-keyword">private</span> String uuid;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistributedLockClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.uuid = UUID.randomUUID().toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> DistributedRedisLock <span class="hljs-title function_">getRedisLock</span><span class="hljs-params">(String lockName)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistributedRedisLock</span>(redisTemplate, lockName, uuid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建分布式Redis锁的实现类，其实现了Lock接口。通过之前编写好的加锁、解锁脚本，实现了可重入锁。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributedRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br>    <span class="hljs-keyword">public</span> String lockName;<br><br>    <span class="hljs-keyword">private</span> String uuid;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">expire</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistributedRedisLock</span><span class="hljs-params">(StringRedisTemplate redisTemplate, String lockName, String uuid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>        <span class="hljs-built_in">this</span>.lockName = lockName;<br>        <span class="hljs-built_in">this</span>.uuid = uuid;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.tryLock();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.tryLock(-<span class="hljs-number">1L</span>, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-built_in">this</span>.expire = time != -<span class="hljs-number">1</span> ? unit.toSeconds(time) : expire;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;exists&#x27;, KEYS[1]) == 0 or redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 \n&quot;</span> +<br>                        <span class="hljs-string">&quot;then\n&quot;</span> +<br>                        <span class="hljs-string">&quot;    redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1)\n&quot;</span> +<br>                        <span class="hljs-string">&quot;    redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2])\n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return 1\n&quot;</span> +<br>                        <span class="hljs-string">&quot;else\n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return 0\n&quot;</span> +<br>                        <span class="hljs-string">&quot;end&quot;</span>;<br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), getId(), String.valueOf(expire))) &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0\n&quot;</span> +<br>                        <span class="hljs-string">&quot;then \n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return nil\n&quot;</span> +<br>                        <span class="hljs-string">&quot;elseif redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1) == 0\n&quot;</span> +<br>                        <span class="hljs-string">&quot;then \n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return redis.call(&#x27;del&#x27;, KEYS[1])\n&quot;</span> +<br>                        <span class="hljs-string">&quot;else \n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return 0\n&quot;</span> +<br>                        <span class="hljs-string">&quot;end&quot;</span>;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script, Long.class), Arrays.asList(lockName), getId());<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(<span class="hljs-string">&quot;this lock does not belong to you&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> uuid + <span class="hljs-string">&quot;:&quot;</span> + Thread.currentThread().getId();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改StockService中的deduct方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">DistributedRedisLock</span> <span class="hljs-variable">redisLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.distributedLockClient.getRedisLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>    redisLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 查询库存信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-comment">// 判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.test();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        redisLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>需要注意的一点是：如何去标识每一个服务中的每一个线程的锁的uuid？</p><p>这里的解决方案是：通过服务生成的uuid与每个线程的线程id拼接得到唯一标识uuid</p><ol><li><p>每一个服务是通过DistributedLockClient这一工厂类获得锁，由于该类交给Spring容器管理，是单例对象。即每一个服务只有一个唯一的DistributedLockClient对象。</p><p> 因此可以在该类构造方法上生成一个uuid，作为当前服务的唯一标识</p></li><li><p>每一个线程也会有一个唯一的id</p></li><li><p>将两者拼接起来（getId方法），即可唯一标识每一个服务的每一个线程。若需要进行重入操作，同一线程重复获取锁，可通过此唯一标识进行判断。</p></li></ol><p>反之，如果每次通过DistributedLockClient获取Redis分布式锁，均重新创建一个新的uuid，那么便永远无法实现可重入锁。</p><ul><li>因为在同一线程进行可重入操作获取锁时，会出现内层锁与外层锁uuid不匹配的错误情况，与理论事实相矛盾。</li></ul><h4 id="2-3-4-自动续期"><a href="#2-3-4-自动续期" class="headerlink" title="2.3.4 自动续期"></a>2.3.4 自动续期</h4><p>假设处理请求的时长大于锁的有效时间，会出现请求还未处理完，锁就被释放了，此时可能引起并发问题。</p><p><strong>解决方案：</strong></p><ul><li><p>采用Timer定时任务，每隔一段时间为锁续期</p></li><li><p>配合lua脚本执行最后的续期操作</p><p>  先判断锁是否存在。若存在则重置过期时间</p>  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span>) <br><span class="hljs-keyword">then</span> <br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renewExpire</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if(redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) \n&quot;</span> +<br>                    <span class="hljs-string">&quot;then \n&quot;</span> +<br>                    <span class="hljs-string">&quot;    redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2])\n&quot;</span> +<br>                    <span class="hljs-string">&quot;    return 1\n&quot;</span> +<br>                    <span class="hljs-string">&quot;else \n&quot;</span> +<br>                    <span class="hljs-string">&quot;    return 0\n&quot;</span> +<br>                    <span class="hljs-string">&quot;end&quot;</span>;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>().schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), uuid, String.valueOf(expire))) &#123;<br>                renewExpire();<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-built_in">this</span>.expire * <span class="hljs-number">1000</span> / <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中需要注意的点是：</p><ul><li><p>之前是通过 <code>getId()</code> 方法，将当前服务的uuid与当前线程的id拼接到一起，组成唯一标识。</p><p>  而现在的问题为：Timer定时任务是子线程，它的本意是监测主线程的锁的过期时间并为其续期，但是在其内部调用getId方法，得到的锁唯一标识是拼接的Timer定时任务子线程的id。</p></li><li><p>因此，需要对代码进行进一步修改与优化，删去getId方法，修改DistributedRedisLock的构造方法，在创建该类时便生成唯一的uuid。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">DistributedRedisLock</span><span class="hljs-params">(StringRedisTemplate redisTemplate, String lockName, String uuid)</span> &#123;<br>    <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>    <span class="hljs-built_in">this</span>.lockName = lockName;<br>    <span class="hljs-built_in">this</span>.uuid = uuid + <span class="hljs-string">&quot;:&quot;</span> + Thread.currentThread().getId();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-4-RedLock红锁算法"><a href="#2-4-RedLock红锁算法" class="headerlink" title="2.4 RedLock红锁算法"></a>2.4 RedLock红锁算法</h3><p>我结合老师的讲解，单独写了一篇<a href="">图文详解RedLock（结合官方文档）</a></p><p>其中一些内容参照了官方文档以及其他大佬的博客</p><p>这一部分均为理论内容，没有实际代码</p><h3 id="2-5-Redisson"><a href="#2-5-Redisson" class="headerlink" title="2.5 Redisson"></a>2.5 Redisson</h3><h4 id="2-5-1-环境搭建"><a href="#2-5-1-环境搭建" class="headerlink" title="2.5.1 环境搭建"></a>2.5.1 环境搭建</h4><p>参考 <a href="https://github.com/redisson/redisson/wiki">Redisson文档</a></p><ol><li><p>引入依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.17.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>由于Redisson不能使用yml进行配置，因此需要编写额外的配置类</p><p> 新建 <code>config</code> 包，创建 <code>RedissonConfig</code> 类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://127.0.0.1:6379&quot;</span>).setPassword(<span class="hljs-string">&quot;123456&quot;</span>).setDatabase(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改 <code>StockService</code> 中的 <code>deduct</code> 方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>  <br><span class="hljs-keyword">private</span> RedissonClient redissonClient;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);  <br>    lock.lock();  <br>    <span class="hljs-comment">// 查询库存信息  </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();  <br>    <span class="hljs-comment">// 判断库存是否充足  </span><br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);  <br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;  <br>                <span class="hljs-comment">// 扣减库存  </span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p> 也可以设置lock的过期时间，到时间时自动释放锁</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">lock.lock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure></li></ol><p>常用的Redisson配置</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/iShot2022-10-12%2017.07.13.png"></p><h4 id="2-5-2-可重入锁"><a href="#2-5-2-可重入锁" class="headerlink" title="2.5.2 可重入锁"></a>2.5.2 可重入锁</h4><h5 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h5><p>RLock接口的lock方法是通过继承JUC包下的Lock接口获得，最终RedissonLock间接实现了RLock接口以及其中的中法。</p><p>继承关系如图所示：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/rlock.png"></p><p>RedissonLock中具体lock方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        lock(-<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);  <br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>根据顺序，一步步进入方法查看：</p><p>lock -&gt; tryAcquire -&gt; tryAcquireAsync -&gt; tryLockInnerAsync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T&gt; RFuture&lt;T&gt; <span class="hljs-title function_">tryLockInnerAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;  <br>    <span class="hljs-keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,  <br>            <span class="hljs-string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +  <br>                    <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +  <br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +  <br>                    <span class="hljs-string">&quot;return nil; &quot;</span> +  <br>                    <span class="hljs-string">&quot;end; &quot;</span> +  <br>                    <span class="hljs-string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +  <br>                    <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +  <br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +  <br>                    <span class="hljs-string">&quot;return nil; &quot;</span> +  <br>                    <span class="hljs-string">&quot;end; &quot;</span> +  <br>                    <span class="hljs-string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,  <br>            Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId));  <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到Redisson中的加锁方法也是采用lua脚本</p><p>Redisson锁的自动定时续期是通过：<code>scheduleExpirationRenewal</code> 方法实现</p><p>其方法内部通过 <code>renewExpiration</code> 重置过期时间，采用TimerTask完成定时任务</p><p>解锁方法unlock也是采用lua脚本</p><p><strong>Redisson自动续期、可重入与防死锁</strong></p><p>实现方案与之前手动实现的Redis分布式锁类似</p><ol><li><p>如果当前代码运行时间过长，超出了锁的过期时间，但是程序仍在执行过程中，所以需要为锁续期</p><p>-&gt; Redisson内部提供了一个监控锁的看门狗（定时任务），它的作用是在Redisson实例被关闭前，不断地延长锁的有效期。默认情况下，看门狗每隔30秒检查一次。</p></li><li><p>如果负责储存分布式锁的Redisson节点宕机后，而这个锁恰好处于锁住状态，这时候会出现死锁。</p><p>-&gt; Redisson通过为锁设置超时时间（有效期），若有效期内没有定时任务为其续期，则其超过该时间就会自动解开。</p></li></ol><h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><p>测试自动续期代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>    lock.lock();<br>    <span class="hljs-comment">// 查询库存信息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试可重入代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>    lock.lock();<br>    <span class="hljs-comment">// 查询库存信息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>    <span class="hljs-built_in">this</span>.test();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>    lock.lock();<br>    System.out.println(<span class="hljs-string">&quot;测试可重入锁...&quot;</span>);<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-5-3-公平锁"><a href="#2-5-3-公平锁" class="headerlink" title="2.5.3 公平锁"></a>2.5.3 公平锁</h4><p>公平的体现：公平锁保证当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程。</p><p>所有的请求线程会在一个队列中排队。如果某线程宕机后，Redisson等待5秒后继续下一个线程。</p><p>举个🌰：若前面有5个线程宕机，那么延迟将会是25秒。</p><p>顺便提一点：个人认为此处Redisson官方的<a href="https://github.com/redisson/redisson/wiki/8.-distributed-locks-and-synchronizers">中文文档</a>描述略有不妥，不是<del>前面5个线程处于等待状态</del>，而是处于宕机状态</p><blockquote><p>  所有请求线程会在一个队列中排队，当某个线程出现宕机时，Redisson会等待5秒后继续下一个线程，也就是说如果前面有5个线程都处于等待状态，那么后面的线程会等待至少25秒。</p></blockquote><p>对照英文版本：</p><blockquote><p>  All waiting threads are queued and if some thread has died then Redisson waits its return for 5 seconds. For example, if 5 threads are died for some reason then delay will be 25 seconds.</p></blockquote><h5 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h5><ol><li><p>在StockController添加新的测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/fair/lock/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testFairLock</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testFairLock(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test fair lock&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService添加新的测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFairLock</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">fairLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getFairLock(<span class="hljs-string">&quot;fairLock&quot;</span>);<br>    fairLock.lock();<br>    System.out.println(<span class="hljs-string">&quot;测试公平锁==================&quot;</span> + id);<br>    <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        fairLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>启动SpringBoot，依次在浏览器请求 <code>test/fair/lock/&#123;id&#125;</code> 5次</p><p>可以看到最终的输出顺序和请求顺序一致，说明实现了公平锁</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221014004141382.png" alt="image-20221014004141382"></p><p>如果开启了两个SpringBoot并采用nginx进行负载均衡，会出现一个请求被发送多次的情况。</p><p>这是因为nginx有纠错机制，当发送一个请求长时间未得到响应时，nginx会再次发送。</p><p>解决方案：配置nginx.conf文件，将超时时间延长。重新配置之后记得重新启动nginx。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br>    <span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">12000</span><br>    proxy_send_timeout <span class="hljs-number">12000</span><br>    proxy_read_timeout <span class="hljs-number">12000</span><br>    location / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://distributedLock;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-5-4-联锁"><a href="#2-5-4-联锁" class="headerlink" title="2.5.4 联锁"></a>2.5.4 联锁</h4><p>Redisson可以将多个RLock对象关联为一个联锁。即要么同时上锁，要么同时解锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RLock</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> redissonInstance1.getLock(<span class="hljs-string">&quot;lock1&quot;</span>);<br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> redissonInstance2.getLock(<span class="hljs-string">&quot;lock2&quot;</span>);<br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock3</span> <span class="hljs-operator">=</span> redissonInstance3.getLock(<span class="hljs-string">&quot;lock3&quot;</span>);<br><br><span class="hljs-type">RedissonMultiLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedissonMultiLock</span>(lock1, lock2, lock3);<br><span class="hljs-comment">// 同时加锁：lock1 lock2 lock3</span><br><span class="hljs-comment">// 所有的锁都上锁成功才算成功。</span><br>lock.lock();<br>...<br>lock.unlock();<br></code></pre></td></tr></table></figure><p>但是缺点很明显：任何一个Redis宕机之后，其他所有的Redis都不可用，一般不用。</p><h4 id="2-5-5-红锁"><a href="#2-5-5-红锁" class="headerlink" title="2.5.5 红锁"></a>2.5.5 红锁</h4><p>红锁与联锁的不同之处在于：红锁只要大部分（过半数）节点上加锁成功就算成功。红锁也不重要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RLock</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> redissonInstance1.getLock(<span class="hljs-string">&quot;lock1&quot;</span>);<br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> redissonInstance2.getLock(<span class="hljs-string">&quot;lock2&quot;</span>);<br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock3</span> <span class="hljs-operator">=</span> redissonInstance3.getLock(<span class="hljs-string">&quot;lock3&quot;</span>);<br><br><span class="hljs-type">RedissonRedLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedissonRedLock</span>(lock1, lock2, lock3);<br><span class="hljs-comment">// 同时加锁：lock1 lock2 lock3</span><br><span class="hljs-comment">// 红锁在大部分节点上加锁成功就算成功。</span><br>lock.lock();<br>...<br>lock.unlock();<br></code></pre></td></tr></table></figure><h4 id="2-5-6-读写锁"><a href="#2-5-6-读写锁" class="headerlink" title="2.5.6 读写锁"></a>2.5.6 读写锁</h4><p>读写锁特性为：读操作可以并发，但是写操作之间不可以并发，读操作与写操作不可以并发</p><p>举例论证读写锁存在的必要：</p><ul><li>假设读操作之间可以并发，写操作之间不可以并发。这种加锁方式保证了写操作的安全性</li><li>但这种方式确保不了读与写操作的安全性，因为没有限制读和写的并发，因此需要引入读写锁</li></ul><h5 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h5><ol><li><p>在StockController中新增以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/read/lock&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testReadLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testReadLock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test read lock&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@GetMapping(&quot;test/write/lock&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testWriteLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testWriteLock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test write lock&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService中新增以下代码：选择超时自动解锁的方式加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testReadLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RReadWriteLock</span> <span class="hljs-variable">rwLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getReadWriteLock(<span class="hljs-string">&quot;rwLock&quot;</span>);<br>    rwLock.readLock().lock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    System.out.println(<span class="hljs-string">&quot;执行写操作...&quot;</span>);<br>    <span class="hljs-comment">//rwLock.readLock().unlock();</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWriteLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RReadWriteLock</span> <span class="hljs-variable">rwLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getReadWriteLock(<span class="hljs-string">&quot;rwLock&quot;</span>);<br>    rwLock.writeLock().lock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    System.out.println(<span class="hljs-string">&quot;执行写操作...&quot;</span>);<br>    <span class="hljs-comment">//rwLock.writeLock().unlock();</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>测试对应的方法，然后查看redis中读写锁是如何存储的。</p><ol><li><p>对于读，可以存在多个读操作，mode为read</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015231801864.png" alt="image-20221015231801864"></p></li><li><p>对于写，同一时间只能有一个写操作，其余均阻塞，mode为write</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015231952586.png" alt="image-20221015231952586"></p></li><li><p>在读的过程中，写操作会被阻塞；在写的过程中，读操作也会被阻塞</p></li></ol><h4 id="2-5-7-信号量"><a href="#2-5-7-信号量" class="headerlink" title="2.5.7 信号量"></a>2.5.7 信号量</h4><p>与JUC中信号量的共同之处：都可以对请求进行限流，均适用于需求量大资源有限的情景</p><h5 id="JUC信号量"><a href="#JUC信号量" class="headerlink" title="JUC信号量"></a>JUC信号量</h5><p>回顾JUC中的信号量：模拟6个线程争抢有限的3个资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            semaphore.acquire();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;抢到了停车位&quot;</span>);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">10</span>));<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;停了一会儿开走了&quot;</span>);<br>            semaphore.release();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;, i + <span class="hljs-string">&quot;号车&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015233103573.png" alt="image-20221015233103573"></p><p>但是JUC信号量只能对单机情况下进行限流，无法做到对分布式环境进行限流</p><h5 id="分布式信号量"><a href="#分布式信号量" class="headerlink" title="分布式信号量"></a>分布式信号量</h5><ol><li><p>在StockController中添加如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/semaphore&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">testSemaphore</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.stockService.testSemaphore();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test semaphore&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService中添加如下代码：通过redis记录争抢资源的顺序日志，更直观地证明分布式下的正确性</p><p>如果要更改semaphore可允许线程数的值，记得将redis中旧的值删去（或者起一个新的名字）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSemaphore</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RSemaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getSemaphore(<span class="hljs-string">&quot;semaphore&quot;</span>);<br>    semaphore.trySetPermits(<span class="hljs-number">3</span>); <span class="hljs-comment">// 设置限流的线程数</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        semaphore.acquire(); <span class="hljs-comment">// 获取资源成功之后才可继续处理业务操作，否则阻塞</span><br>        <span class="hljs-built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-string">&quot;10010获取资源，开始处理...&quot;</span> + Thread.currentThread().getName());<br>        TimeUnit.SECONDS.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">10</span>));<br>        <span class="hljs-built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-string">&quot;10010处理完成，释放资源...&quot;</span> + Thread.currentThread().getName());<br>        semaphore.release(); <span class="hljs-comment">// 手动释放资源</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>启动两个服务，redis中的输出日志如下：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221016001007227.png" alt="image-20221016001007227"></p><h4 id="2-5-8-倒计数器（闭锁）"><a href="#2-5-8-倒计数器（闭锁）" class="headerlink" title="2.5.8 倒计数器（闭锁）"></a>2.5.8 倒计数器（闭锁）</h4><p>一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行</p><h5 id="JUC倒计数器"><a href="#JUC倒计数器" class="headerlink" title="JUC倒计数器"></a>JUC倒计数器</h5><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;：开始执行...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">5</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;：结束执行...&quot;</span>);<br>            countDownLatch.countDown();<br>        &#125;, i + <span class="hljs-string">&quot;号线程&quot;</span>).start();<br>    &#125;<br>    countDownLatch.await();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;：其他线程均已结束，执行最后任务...&quot;</span>);<br></code></pre></td></tr></table></figure><p>输出如下：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221016002330475.png" alt="image-20221016002330475"></p><h5 id="分布式倒计数器"><a href="#分布式倒计数器" class="headerlink" title="分布式倒计数器"></a>分布式倒计数器</h5><ol><li><p>在StockController中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/await&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testLAwait</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testAwait();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;wait for other threads...&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@GetMapping(&quot;test/countdown&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testCountDown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testCountDown();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;execute...&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAwait</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RCountDownLatch</span> <span class="hljs-variable">cdl</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getCountDownLatch(<span class="hljs-string">&quot;cdl&quot;</span>);<br>    cdl.trySetCount(<span class="hljs-number">6</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        cdl.await(); <span class="hljs-comment">// 阻塞，直到其余所有线程执行完毕</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCountDown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RCountDownLatch</span> <span class="hljs-variable">cdl</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getCountDownLatch(<span class="hljs-string">&quot;cdl&quot;</span>);<br>    cdl.countDown();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-Zookeeper分布式锁"><a href="#3-Zookeeper分布式锁" class="headerlink" title="3. Zookeeper分布式锁"></a>3. Zookeeper分布式锁</h2><h3 id="3-1-Zookeeper基本指令"><a href="#3-1-Zookeeper基本指令" class="headerlink" title="3.1 Zookeeper基本指令"></a>3.1 Zookeeper基本指令</h3><ol><li><p>查看某个目录下的子节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> /<br><span class="hljs-built_in">ls</span> /node<br></code></pre></td></tr></table></figure></li><li><p>创建节点 create命令</p><p>在根目录创建 <code>node</code> 节点，其内容为 “abc”</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">create /<span class="hljs-keyword">node</span> <span class="hljs-title">&quot;abc</span><span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>更新节点内容 set命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> /node <span class="hljs-string">&quot;aaa&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>获取节点数据 get命令</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">get /<span class="hljs-keyword">node</span><br><span class="hljs-title">get</span> -s /<span class="hljs-keyword">node</span> <span class="hljs-title">获取详细内容</span><br></code></pre></td></tr></table></figure></li><li><p>删除节点 delete命令</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">delete /<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-2-ZNode节点类型"><a href="#3-2-ZNode节点类型" class="headerlink" title="3.2 ZNode节点类型"></a>3.2 ZNode节点类型</h3><p>永久节点：一旦节点被创建就一直存在，及时Zookeeper宕机也不会被删除，只能手动将其删除</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">create /<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><p>临时节点：临时节点的生命周期与客户端会话相绑定，会话消失则节点也会随之消失。并且临时节点只能做叶子节点，不能创建子节点</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">create -e /<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><p>永久序列化节点：具有永久节点的特性，而且在创建该类节点时，Zookeeper会在节点名称后加入顺序编号</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">create -s /<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><p>临时序列化节点：具有临时节点的特性，而且在创建该类节点时，Zookeeper会在节点名称后加入顺序编号</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">create -e -s /<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><h3 id="3-3-事件监听"><a href="#3-3-事件监听" class="headerlink" title="3.3 事件监听"></a>3.3 事件监听</h3><p>Watcher事件监听器：监听是一次性的，一个监听指令只能监听到一次变化</p><p>同时开启两个zk客户端，一个客户端用于监听，另一个客户端用于操作节点</p><ol><li><p>节点创建：NodeCreated</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span> -w /xx<br></code></pre></td></tr></table></figure></li><li><p>节点删除：NodeDeleted</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span> -w /xx<br></code></pre></td></tr></table></figure></li><li><p>节点数据变化：NodeDataChanged</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">get</span> -w /xx<br></code></pre></td></tr></table></figure></li><li><p>子节点变化：NodeChildrenChanged</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 监听xx下的子节点变化</span><br><span class="hljs-built_in">ls</span> -w /xx <br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-Java客户端"><a href="#3-4-Java客户端" class="headerlink" title="3.4 Java客户端"></a>3.4 Java客户端</h3><h4 id="3-4-1-案例搭建"><a href="#3-4-1-案例搭建" class="headerlink" title="3.4.1 案例搭建"></a>3.4.1 案例搭建</h4><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>创建ZkTest类，在main方法编写如下代码</p><ul><li>Zookeeper构造方法中需要填的参数<ul><li>ip地址与端口号port</li><li>超时时间</li><li>Watcher事件监听器匿名类</li></ul></li><li>用CountDownLatch，使Zookeeper在获取到链接之后才进行之后的操作</li><li>Watcher事件监听中：监听获取链接与关闭链接两个事件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zooKeeper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">try</span> &#123;<br>    zooKeeper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>, <span class="hljs-number">30000</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> &#123;<br>            Event.<span class="hljs-type">KeeperState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> watchedEvent.getState();<br>            <span class="hljs-keyword">if</span> (Event.KeeperState.SyncConnected.equals(state)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;获取链接：&quot;</span> + watchedEvent);<br>                countDownLatch.countDown();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Event.KeeperState.Closed.equals(state)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;关闭链接：&quot;</span> + watchedEvent);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    countDownLatch.await();<br>    System.out.println(<span class="hljs-string">&quot;执行操作...&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (zooKeeper != <span class="hljs-literal">null</span>) &#123;<br>        zooKeeper.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">获取链接：WatchedEvent <span class="hljs-keyword">state</span>:SyncConnected type:None path:null<br>执行操作...<br>关闭链接：WatchedEvent <span class="hljs-keyword">state</span>:Closed type:None path:null<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-4-2-操作节点"><a href="#3-4-2-操作节点" class="headerlink" title="3.4.2 操作节点"></a>3.4.2 操作节点</h4><ol><li><p>创建节点：第一个参数为节点名路径，第二参数为节点内容，第三个参数为节点权限，第四个参数为节点类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 永久节点</span><br>zooKeeper.create(<span class="hljs-string">&quot;ltyzzz/test1&quot;</span>, <span class="hljs-string">&quot;hello zookeeper&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br><span class="hljs-comment">// 临时节点</span><br>zooKeeper.create(<span class="hljs-string">&quot;ltyzzz/test2&quot;</span>, <span class="hljs-string">&quot;hello zookeeper&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);<br><span class="hljs-comment">// 永久序列化节点</span><br>zooKeeper.create(<span class="hljs-string">&quot;ltyzzz/test3&quot;</span>, <span class="hljs-string">&quot;hello zookeeper&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);<br><span class="hljs-comment">// 临时序列化节点 </span><br>zooKeeper.create(<span class="hljs-string">&quot;ltyzzz/test3&quot;</span>, <span class="hljs-string">&quot;hello zookeeper&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);<br></code></pre></td></tr></table></figure></li><li><p>查询节点</p><ol><li><p>判断节点是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Stat</span> <span class="hljs-variable">exists</span> <span class="hljs-operator">=</span> zooKeeper.exists(<span class="hljs-string">&quot;/ltyzzz&quot;</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (exists != <span class="hljs-literal">null</span>) &#123;<br>    System.out.println(<span class="hljs-string">&quot;当前节点存在&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;当前节点不存在&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>获取当前节点中的数据内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] data = zooKeeper.getData(<span class="hljs-string">&quot;/ltyzzz&quot;</span>, <span class="hljs-literal">false</span>, exists);<br>System.out.println(<span class="hljs-string">&quot;当前节点内容：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data));<br></code></pre></td></tr></table></figure></li><li><p>获取当前节点的子节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; children = zooKeeper.getChildren(<span class="hljs-string">&quot;/ltyzzz&quot;</span>, <span class="hljs-literal">false</span>);<br>System.out.println(<span class="hljs-string">&quot;当前节点的子节点：&quot;</span> + children);<br></code></pre></td></tr></table></figure></li></ol></li><li><p>更新节点</p><ul><li>其中第三个参数为版本号。该版本号必须和当前节点版本号一致，否则更新失败（乐观锁）</li><li>可以将其指定为-1，表示不关心版本号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">zooKeeper.setData(<span class="hljs-string">&quot;/ltyzzz&quot;</span>, <span class="hljs-string">&quot;zzz...&quot;</span>.getBytes(), exists.getVersion());<br>zooKeeper.setData(<span class="hljs-string">&quot;/ltyzzz&quot;</span>, <span class="hljs-string">&quot;zzz...&quot;</span>.getBytes(), -<span class="hljs-number">1</span>); <span class="hljs-comment">// 不关心版本号</span><br></code></pre></td></tr></table></figure></li><li><p>删除操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zooKeeper.delete(<span class="hljs-string">&quot;/ltyzzz/test1&quot;</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// 不关心版本号</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="3-4-3-节点监听事件"><a href="#3-4-3-节点监听事件" class="headerlink" title="3.4.3 节点监听事件"></a>3.4.3 节点监听事件</h4><p>每一个操作节点的方法中均有一个watch参数，为boolean类型。</p><p>watch为true时，代表启动节点监听事件</p><h3 id="3-5-实现Zookeeper分布式锁"><a href="#3-5-实现Zookeeper分布式锁" class="headerlink" title="3.5 实现Zookeeper分布式锁"></a>3.5 实现Zookeeper分布式锁</h3><p>独占排他：ZNode节点不可重复</p><h4 id="3-5-1-自旋锁版本"><a href="#3-5-1-自旋锁版本" class="headerlink" title="3.5.1 自旋锁版本"></a>3.5.1 自旋锁版本</h4><ol><li><p>创建ZkClient，用于初始化时获取Zk链接与结束时释放Zk链接</p><ul><li>添加@Component注解，交给Spring容器管理，SpringBoot启动时会执行初始化操作</li><li>@PostConstruct：执行完ZkClient构造方法之后，获取Zookeeper链接</li><li>@PreDestroy：在ZkClient销毁之前，释放Zookeeper链接</li><li>getLock：用于创建锁对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkClient</span> &#123;<br><br>    <span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zooKeeper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 获取Zk链接</span><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            zooKeeper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>, <span class="hljs-number">30000</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> &#123;<br>                    Event.<span class="hljs-type">KeeperState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> watchedEvent.getState();<br>                    <span class="hljs-keyword">if</span> (Event.KeeperState.SyncConnected.equals(state)) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;获取链接：&quot;</span> + watchedEvent);<br>                        countDownLatch.countDown();<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Event.KeeperState.Closed.equals(state)) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;关闭链接：&quot;</span> + watchedEvent);<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 释放Zk链接</span><br>        <span class="hljs-keyword">if</span> (zooKeeper != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                zooKeeper.close();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ZkDistributedLock <span class="hljs-title function_">getLock</span><span class="hljs-params">(String lockName)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZkDistributedLock</span>(zooKeeper, lockName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建ZkDistributedLock类，用于实现锁</p><ul><li>所有的锁都将创建在 <code>/locks</code> 目录下，所以在构造方法中，需要先判断有没有该目录，没有的话则需要提前创建</li><li>注意：<code>/locks</code> 为永久节点，而创建出来的锁为临时节点，这是为了防止服务器宕机造成的死锁问题，而设置为临时节点的话，服务器宕机之后，临时节点也会随之被删除。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkDistributedLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String lockName;<br>    <span class="hljs-keyword">private</span> ZooKeeper zooKeeper;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROOT_PATH</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/locks&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ZkDistributedLock</span><span class="hljs-params">(ZooKeeper zooKeeper, String lockName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.zooKeeper = zooKeeper;<br>        <span class="hljs-built_in">this</span>.lockName = lockName;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (zooKeeper.exists(ROOT_PATH, <span class="hljs-literal">false</span>) == <span class="hljs-literal">null</span>) &#123;<br>                zooKeeper.create(ROOT_PATH, <span class="hljs-literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建ZNode节点</span><br>        tryLock();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            zooKeeper.create(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + lockName, <span class="hljs-literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">80</span>);<br>                tryLock();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>                ex.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 删除ZNode节点</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.zooKeeper.delete(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + lockName, -<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService中注入ZkClient对象，并修改deduct方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ZkClient zkClient;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ZkDistributedLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> zkClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-5-2-阻塞公平锁版本"><a href="#3-5-2-阻塞公平锁版本" class="headerlink" title="3.5.2 阻塞公平锁版本"></a>3.5.2 阻塞公平锁版本</h4><p>利用临时序列化节点与监听机制实现</p><ol><li><p>临时序列化节点在创建节点时，节点的名称后会追加序列号。</p><p>给每一个获取锁的请求都创建一个临时序列化节点，越先尝试获取锁的节点，其序列号越小，优先级越高，满足公平锁的定义</p><ol><li>获取当前节点的前驱节点<ul><li>若前驱节点为空，则获取锁成功，否则监听前驱节点</li></ul></li><li>获取锁成功后执行业务操作，最后释放当前节点的锁</li></ol></li><li><p>后创建的节点监听它之前的一个节点，如果监听到它的前驱节点被删除，则相当于获取到锁；否则阻塞</p><p>（类似于AQS中同步队列的定义）</p></li></ol><p>改造之前的代码：更改tryLock与unlock代码</p><p>注意：</p><ol><li>Zookeeper调用create方法后，会返回其全路径，这里将其作为了成员变量，方便解锁时删除</li><li>路径中加上了“-”，方便之后获取每个节点的序列号</li><li>通过编写getPreNode方法，获取当前节点的前驱节点</li><li>通过CountDownLatch实现阻塞功能</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        currentNodePath = zooKeeper.create(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + lockName + <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);<br>        <span class="hljs-comment">// 获取前驱节点：若前驱节点为空，则获取锁成功，否则监听该节点</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">preNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getPreNode();<br>        <span class="hljs-keyword">if</span> (preNode != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 利用闭锁实现阻塞</span><br>            <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 因为获取前驱节点操作不具备原子性，需要再次判断zk中的前驱节点是否存在</span><br>            <span class="hljs-keyword">if</span> (zooKeeper.exists(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + preNode, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> &#123;<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;) == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            countDownLatch.await();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">getPreNode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取根节点下的所有节点</span><br>        List&lt;String&gt; children = <span class="hljs-built_in">this</span>.zooKeeper.getChildren(ROOT_PATH, <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(children)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(<span class="hljs-string">&quot;非法操作&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 获取根节点中对应于当前锁的所有节点</span><br>        List&lt;String&gt; nodes = children.stream().filter(node -&gt; StringUtils.startsWith(node, lockName + <span class="hljs-string">&quot;-&quot;</span>)).collect(Collectors.toList());<br>        <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(nodes)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(<span class="hljs-string">&quot;非法操作&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 按照序列号排序</span><br>        Collections.sort(nodes);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">currentNode</span> <span class="hljs-operator">=</span> StringUtils.substringAfterLast(currentNodePath, <span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-comment">// 获取当前节点对应的下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Collections.binarySearch(nodes, currentNode);<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(<span class="hljs-string">&quot;非法操作&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 返回当前节点的前驱节点</span><br>            <span class="hljs-keyword">return</span> nodes.get(index - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(<span class="hljs-string">&quot;非法操作&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 删除ZNode节点</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">this</span>.zooKeeper.delete(currentNodePath, -<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-5-3-实现可重入功能"><a href="#3-5-3-实现可重入功能" class="headerlink" title="3.5.3 实现可重入功能"></a>3.5.3 实现可重入功能</h4><p>通过ThreadLocal这一线程局部变量，记录重入次数</p><p>改造代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 判断thread local中是否已经有锁，有锁则直接重入+1</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> THREAD_LOCAL.get();<br>        <span class="hljs-keyword">if</span> (flag != <span class="hljs-literal">null</span> &amp;&amp; flag &gt; <span class="hljs-number">0</span>) &#123;<br>            THREAD_LOCAL.set(flag + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        currentNodePath = zooKeeper.create(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + lockName + <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);<br>        <span class="hljs-comment">// 获取前驱节点：若前驱节点为空，则获取锁成功，否则监听该节点</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">preNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getPreNode();<br>        <span class="hljs-keyword">if</span> (preNode != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 利用闭锁实现阻塞</span><br>            <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 因为获取前驱节点操作不具备原子性，需要再次判断zk中的前驱节点是否存在</span><br>            <span class="hljs-keyword">if</span> (zooKeeper.exists(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + preNode, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> &#123;<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;) == <span class="hljs-literal">null</span>) &#123;<br>                THREAD_LOCAL.set(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            countDownLatch.await();<br>        &#125;<br>        THREAD_LOCAL.set(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 删除ZNode节点</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        THREAD_LOCAL.set(THREAD_LOCAL.get() - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 减为0则删除</span><br>        <span class="hljs-keyword">if</span> (THREAD_LOCAL.get() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">this</span>.zooKeeper.delete(currentNodePath, -<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6-Curator"><a href="#3-6-Curator" class="headerlink" title="3.6 Curator"></a>3.6 Curator</h3><p>Curator由一系列的模块构成，对于一般开发者而言，常用的是curator-framework和curator-recipes：</p><ul><li>curator-framework：提供了常见的zk相关的底层操作</li><li>curator-recipes：提供了一些zk的典型使用场景的参考</li></ul><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置Curator：新建CuratorConfig配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CuratorConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CuratorFramework <span class="hljs-title function_">curatorFramework</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 初始化重试策略，使用的指数补偿策略</span><br>        <span class="hljs-type">RetryPolicy</span> <span class="hljs-variable">retry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">10000</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 设置初始间隔时间与重试次数</span><br>        <span class="hljs-comment">// 初始化curatork客户端</span><br>        <span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory.newClient(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>, retry);<br>        client.start(); <span class="hljs-comment">// 手动启动，否则很多方法功能不能够工作</span><br>        <span class="hljs-keyword">return</span> client;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-6-1-InterProcessMutex"><a href="#3-6-1-InterProcessMutex" class="headerlink" title="3.6.1 InterProcessMutex"></a>3.6.1 InterProcessMutex</h4><p>与ReentrantLock类似，拥有可重入的特性。</p><h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><p>注入CuratorFramework，修改StockService中的deduct方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> CuratorFramework curatorFramework;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">InterProcessMutex</span> <span class="hljs-variable">mutex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessMutex</span>(curatorFramework, <span class="hljs-string">&quot;/curator/locks&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        mutex.acquire();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.testSub(mutex); <span class="hljs-comment">// 测试可重入</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mutex.release();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSub</span><span class="hljs-params">(InterProcessMutex mutex)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        mutex.acquire();<br>        System.out.println(<span class="hljs-string">&quot;测试可重入锁。。。。&quot;</span>);<br>        mutex.release();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h5><p>InterProcessMutex初始化原理</p><ol><li><p>首先调用如下构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将传入的参数再传入到下一个构造方法中</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">InterProcessMutex</span><span class="hljs-params">(CuratorFramework client, String path)</span><br>&#123;<br>    <span class="hljs-built_in">this</span>(client, path, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardLockInternalsDriver</span>());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>进一步调用构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// this中的第一个参数为传进来的client，第二个参数为传进来的path</span><br><span class="hljs-comment">// 第三个参数为常量LOCK_NAME:&quot;lock-&quot;</span><br><span class="hljs-comment">// 第四个参数为驱动Driver：new StandardLockInternalsDriver()</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">InterProcessMutex</span><span class="hljs-params">(CuratorFramework client, String path, LockInternalsDriver driver)</span><br>&#123;<br>    <span class="hljs-comment">// 1为租约：maxLeases</span><br>    <span class="hljs-built_in">this</span>(client, path, LOCK_NAME, <span class="hljs-number">1</span>, driver);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>再进一步调用构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">InterProcessMutex(CuratorFramework client, String path, String lockName, <span class="hljs-type">int</span> maxLeases, LockInternalsDriver driver)<br>&#123;<br>    <span class="hljs-comment">// 这是对传进来的path参数做校验</span><br>    basePath = PathUtils.validatePath(path);<br>    <span class="hljs-comment">// LockInternals实例化很关键，之后的加锁与解锁方法都需要用到这个类</span><br>    internals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockInternals</span>(client, driver, path, lockName, maxLeases);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建LockInternals对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">LockInternals(CuratorFramework client, LockInternalsDriver driver, String path, String lockName, <span class="hljs-type">int</span> maxLeases)<br>&#123;<br>    <span class="hljs-built_in">this</span>.driver = driver;<br>    <span class="hljs-built_in">this</span>.lockName = lockName;<br>    <span class="hljs-built_in">this</span>.maxLeases = maxLeases;<br><br>    <span class="hljs-built_in">this</span>.client = client.newWatcherRemoveCuratorFramework();<br>    <span class="hljs-comment">// 再次校验path参数</span><br>    <span class="hljs-built_in">this</span>.basePath = PathUtils.validatePath(path);<br>    <span class="hljs-comment">// 将路径与锁名称进行拼接</span><br>    <span class="hljs-built_in">this</span>.path = ZKPaths.makePath(path, lockName);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>加锁原理</p><ol><li><p>执行 <code>mutex.acquire()</code> 方法时，内部调用acquire方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br>    <span class="hljs-keyword">if</span> ( !internalLock(-<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>) )<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Lost connection while trying to acquire lock: &quot;</span> + basePath);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>内部又调用了internalLock方法：直接看注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">internalLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">currentThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">// 通过当前线程获取localData对象</span><br>    <span class="hljs-type">LockData</span> <span class="hljs-variable">lockData</span> <span class="hljs-operator">=</span> threadData.get(currentThread);<br>    <span class="hljs-comment">// 如果lockData不为null，说明发生了重入</span><br>    <span class="hljs-keyword">if</span> ( lockData != <span class="hljs-literal">null</span> )<br>    &#123;<br>        <span class="hljs-comment">// 将重入次数加1，然后直接返回即可</span><br>        lockData.lockCount.incrementAndGet();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-comment">// lockData为null，说明是获取新的锁</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockPath</span> <span class="hljs-operator">=</span> internals.attemptLock(time, unit, getLockNodeBytes());<br>    <span class="hljs-keyword">if</span> ( lockPath != <span class="hljs-literal">null</span> )<br>    &#123;<br>        <span class="hljs-comment">// 创建一个新的lockData，并将当前线程的lockData记录到哈希表中</span><br>        <span class="hljs-type">LockData</span> <span class="hljs-variable">newLockData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockData</span>(currentThread, lockPath);<br>        threadData.put(currentThread, newLockData);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中threadData是一个ConcurrentMap，key为Thread，值为LockData。记录了重入信息。</p><p>LockData是一个内部类</p><p>threadData与LockData属性如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;Thread, LockData&gt; threadData = Maps.newConcurrentMap();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockData</span><br>&#123;<br>    <span class="hljs-keyword">final</span> Thread owningThread; <span class="hljs-comment">// 所属线程</span><br>    <span class="hljs-keyword">final</span> String lockPath; <span class="hljs-comment">// 锁路径</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">lockCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 重入次数</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LockData</span><span class="hljs-params">(Thread owningThread, String lockPath)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.owningThread = owningThread;<br>        <span class="hljs-built_in">this</span>.lockPath = lockPath;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>获取新的锁时，会调用 <code>internals.attemptLock()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">attemptLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit, <span class="hljs-type">byte</span>[] lockNodeBytes)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>      <span class="hljs-variable">startMillis</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Long</span>      <span class="hljs-variable">millisToWait</span> <span class="hljs-operator">=</span> (unit != <span class="hljs-literal">null</span>) ? unit.toMillis(time) : <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[]    localLockNodeBytes = (revocable.get() != <span class="hljs-literal">null</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>] : lockNodeBytes;<br>    <span class="hljs-type">int</span>             <span class="hljs-variable">retryCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">String</span>          <span class="hljs-variable">ourPath</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span>         <span class="hljs-variable">hasTheLock</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span>         <span class="hljs-variable">isDone</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 死循环重复尝试获取锁</span><br>    <span class="hljs-keyword">while</span> ( !isDone )<br>    &#123;<br>        isDone = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-comment">// 创建一个当前锁的节点（临时序列化节点），并获取当前锁的全路径</span><br>            ourPath = driver.createsTheLock(client, path, localLockNodeBytes);<br>            hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> ( KeeperException.NoNodeException e )<br>        &#123;<br>            <span class="hljs-keyword">if</span> ( client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper()) )<br>            &#123;<br>                isDone = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( hasTheLock )<br>    &#123;<br>        <span class="hljs-keyword">return</span> ourPath;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-6-2-其它锁"><a href="#3-6-2-其它锁" class="headerlink" title="3.6.2 其它锁"></a>3.6.2 其它锁</h4><ol><li><p>InterceProcessSemaphoreMutex：不可重入锁，其它与InterProcessMutex一致</p></li><li><p>InterProcessReadWriteMutex：读写锁 -&gt; 读读可并发，读写不可并发，写写不可并发</p><p>有一个不同于Redisson分布式读写锁的特点：写锁在释放之前仍会阻塞请求线程，而读锁不会</p><ol><li><p>在StockController中加入如下两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/zk/read/lock&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testZkReadLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testZkReadLock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test Zk read lock&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@GetMapping(&quot;test/zk/write/lock&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testZkWriteLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testZkWriteLock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test Zk write lock&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService中加入如下两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testZkReadLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">InterProcessReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessReadWriteLock</span>(curatorFramework, <span class="hljs-string">&quot;/curator/rwLock&quot;</span>);<br>        lock.readLock().acquire(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        <span class="hljs-comment">//lock.readLock().release();</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testZkWriteLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">InterProcessReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessReadWriteLock</span>(curatorFramework, <span class="hljs-string">&quot;/curator/rwLock&quot;</span>);<br>        lock.writeLock().acquire(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        <span class="hljs-comment">//lock.readLock().release();</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>InterProcessMultiLock：联锁。所有的锁都加锁成功才算成功，否则加锁失败</p></li><li><p>InterProcessSemaphoreV2：信号量。限流作用</p><p>修改StockService中的testSemaphore方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSemaphore</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">InterProcessSemaphoreV2</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessSemaphoreV2</span>(curatorFramework, <span class="hljs-string">&quot;/curator/locks&quot;</span>, <span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Lease</span> <span class="hljs-variable">lease</span> <span class="hljs-operator">=</span> semaphore.acquire();<br>        <span class="hljs-built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-string">&quot;10086获取资源，开始处理...&quot;</span> + Thread.currentThread().getName());<br>        TimeUnit.SECONDS.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">10</span>));<br>        <span class="hljs-built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-string">&quot;10086处理完成，释放资源...&quot;</span> + Thread.currentThread().getName());<br>        semaphore.returnLease(lease);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>共享计数器：类似于CountDownLatch</p><p>Curator提供了两个实现类：SharedCount与DistributedAtomicNumber </p><p>SharedCount实现如下：</p><ol><li><p>StockController中新增如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/sharedCount&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testSharedCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testSharedCount();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test SharedCount&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>StockService中新增如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSharedCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">SharedCount</span> <span class="hljs-variable">sharedCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedCount</span>(curatorFramework, <span class="hljs-string">&quot;/curator/sharedcount&quot;</span>, <span class="hljs-number">100</span>);<br>        sharedCount.start();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> sharedCount.getCount();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1000</span>);<br>        sharedCount.setCount(random);<br>        System.out.println(<span class="hljs-string">&quot;共享计数器初始值为：&quot;</span> + count + <span class="hljs-string">&quot;, 现在值为：&quot;</span> + random);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="4-MySQL分布式锁"><a href="#4-MySQL分布式锁" class="headerlink" title="4. MySQL分布式锁"></a>4. MySQL分布式锁</h2><h3 id="4-1-实现方案"><a href="#4-1-实现方案" class="headerlink" title="4.1 实现方案"></a>4.1 实现方案</h3><p>数据库准备工作</p><ol><li><p>新建一张表tb_lock，两个字段分别为：id、lock_name</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221020232747128.png" alt="image-20221020232747128"></p></li><li><p>为lock_name设置索引，索引类型为unique唯一键索引</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221020232946531.png" alt="image-20221020232946531"></p></li></ol><p>思路为：</p><ol><li><p>加锁时执行如下SQL语句，若执行成功则代表加锁成功</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb_lock(lock_name) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;lock&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>释放锁时，通过delete删除对应的锁记录</p></li></ol><p>代码实现：</p><ol><li><p>在pojo包下新建Lock类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;tb_lock&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String lockName;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在mapper包下创建LockMapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LockMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Lock&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改StockService中的deduct方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Lock</span>();<br>        lock.setLockName(<span class="hljs-string">&quot;lock&quot;</span>);<br>        <span class="hljs-built_in">this</span>.lockMapper.insert(lock);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.lockMapper.deleteById(lock.getId());<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>            <span class="hljs-built_in">this</span>.deduct();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(ex);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>经过JMeter测试之后发现，基于MySQL实现的分布式锁虽然实现了并发下将库存减为0的功能，但是性能极差。</p><h3 id="4-2-小结"><a href="#4-2-小结" class="headerlink" title="4.2 小结"></a>4.2 小结</h3><ol><li><p>独占排他互斥使用：采用唯一键索引实现</p></li><li><p>防死锁：客户端程序获取到锁之后，客户端服务器宕机造成死锁。</p><ul><li><p>解决方案：为tb_lock表添加获取锁时间字段lock_time，根据系统当前时间进行判断是否超时。</p><p>需要采用额外的定时器去检查获取锁的系统时间与当前系统时间的差值是否超过某一阈值</p></li></ul></li><li><p>可重入：</p><ul><li>解决方案：为tb_lock表添加server_id字段，代表对应的服务器；添加thread_id字段，代表对应服务器的线程；添加count字段，代表重入次数。</li></ul></li><li><p>防误删：借助于id的唯一性防误删</p></li><li><p>原子性：单个写操作，还可借助MySQL悲观锁</p></li><li><p>自动续期：使用服务内的定时器重置获取锁的系统时间</p></li><li><p>单机故障：搭建MySQL主备服务器</p></li><li><p>集群下锁机制失效：难解决</p></li><li><p>阻塞锁：难实现</p></li></ol><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ol><li>简易程度：MySQL最简单，其次Redis，Zookeeper最难</li><li>性能：Redis &gt; Zookeeper &gt; MySQL</li><li>可靠性：Zookeeper &gt; Redis &#x3D; MySQL</li></ol><ul><li>如果要求不高、只实现独占排他、不要求可靠性与性能，选择MySQL</li><li>如果追求性能，选择Redis</li><li>如果追求可靠性，选择Zookeeper</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>锁</tag>
      
      <tag>MySQL</tag>
      
      <tag>分布式</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 870. Advantage Shuffle</title>
    <link href="/2022/10/08/LC-Solution-870-Advantage-Shuffle/"/>
    <url>/2022/10/08/LC-Solution-870-Advantage-Shuffle/</url>
    
    <content type="html"><![CDATA[<h1 id="870-Advantage-Shuffle"><a href="#870-Advantage-Shuffle" class="headerlink" title="870. Advantage Shuffle"></a><a href="https://leetcode.cn/problems/advantage-shuffle/">870. Advantage Shuffle</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个大小相等的数组 <code>nums1</code> 和 <code>nums2</code>，<code>nums1</code> 相对于 <code>nums</code> 的优势可以用满足 <code>nums1[i]</code> &gt; <code>nums2[i]</code> 的索引 <code>i</code> 的数目来描述。</p><p>返回 <code>nums1</code> 的任意排列，使其相对于 <code>nums2</code> 的优势最大化。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums1 = <span class="hljs-string">[2,7,11,15]</span>, nums2 = <span class="hljs-string">[1,10,4,11]</span><br>输出：<span class="hljs-string">[2,11,7,15]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums1 = <span class="hljs-string">[12,24,8,32]</span>, nums2 = <span class="hljs-string">[13,25,32,11]</span><br>输出：<span class="hljs-string">[24,32,8,12]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>1 &lt;&#x3D; nums1.length &lt;&#x3D; 105</p></li><li><p>nums2.length &#x3D;&#x3D; nums1.length</p></li><li><p>0 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 109</p></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：田忌赛马-gt-贪心-双指针"><a href="#方法一：田忌赛马-gt-贪心-双指针" class="headerlink" title="方法一：田忌赛马 -&gt; 贪心 + 双指针"></a>方法一：田忌赛马 -&gt; 贪心 + 双指针</h3><p>该方案采用的是 <a href="%5B%E5%8A%9B%E6%89%A3%5D(https://leetcode.cn/problems/advantage-shuffle/solution/tian-ji-sai-ma-by-endlesscheng-yxm6/)">灵神</a> 的题解，下面我说一下我的理解</p><p>题目要求使 <code>nums1</code> 数组 <strong>“战胜”</strong> <code>nums2</code> 数组的次数最大化</p><p>通过此很容易想到贪心思路，对 <code>nums1</code> 与 <code>nums2</code> 分别进行排序，</p><p>然后对比 <code>nums1</code> 当前最小值 与 <code>nums2</code> 当前最小值</p><ul><li><p>若 <code>nums1</code> 的当前最小值大于 <code>nums2</code> 的当前最小值，则 <code>nums1</code> 获胜</p></li><li><p>否则，说明 <code>nums1</code> 的当前最小值无法战胜 <code>nums2</code> 的所有值，所以让 <code>nums1</code> 的当前最小值与 <code>nums2</code> 的当前最大值作战（即当“炮灰”），这样可以抵消掉 <code>nums2</code> 的最大值。</p></li></ul><p>这就是典型的 <code>田忌赛马</code> 思路，用下等马去战胜上等马！</p><ul><li><code>nums1</code> 的下等马无法战胜 <code>nums2</code> 的下等马时，就让其当炮灰去对战 <code>nums2</code> 的上等马</li></ul><p>每一个 “作战回合” 结束之后，需要将本回合用过的元素摒弃掉。</p><p>而 <code>nums2</code> 的最小值（即数组尾元素）或最大值（即数组首元素）均可能被使用，所以本题采用 <code>首尾双指针</code> 思路，逐渐缩小问题规模，最终得到全部对应关系。</p><p>但在代码具体实现过程中，如果对两个数组均进行排序，则丢失了原本的 ”作战“ 顺序，所以只对 <code>nums1</code> 进行排序。用额外的下标数组 <code>ids</code>，根据 <code>nums2</code> 的元素大小，对其下标进行排序。<code>ids[0]</code> 对应 <code>nums2</code> 第一小值下标，<code>ids[1]</code> 对应 <code>nums2</code> 第二小值下标…</p><p>通过 <code>ids</code> 数组，就可以知道当前 <code>nums2</code> 下标所要对应的 <code>nums1</code> 元素。</p><p>感觉这道题直接看代码更容易理解。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">advantageCount</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums1)<br>        ans = [<span class="hljs-number">0</span>] * n<br>        nums1.sort()<br>        ids = <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">range</span>(n), key=<span class="hljs-keyword">lambda</span> i: nums2[i])<br>        left, right = <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums1:<br>            <span class="hljs-keyword">if</span> x &gt; nums2[ids[left]]:<br>                ans[ids[left]] = x  <br>                left += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                ans[ids[right]] = x  <br>                right -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>注意：Java采用比较器排序时，只能使用包装类Integer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] advantageCount(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums2.length;<br>        Integer[] ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) ids[i] = i;<br>        Arrays.sort(nums1);<br>        Arrays.sort(ids, (a, b) -&gt; nums2[a] - nums2[b]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, q = len - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : nums1) &#123;<br>            <span class="hljs-keyword">if</span>(x &gt; nums2[ids[p]]) ans[ids[p++]] = x;<br>            <span class="hljs-keyword">else</span> ans[ids[q--]] = x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第15篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1800. Maximum Ascending Subarray Sum</title>
    <link href="/2022/10/07/LC-Solution-1800-Maximum-Ascending-Subarray-Sum/"/>
    <url>/2022/10/07/LC-Solution-1800-Maximum-Ascending-Subarray-Sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-ascending-subarray-sum/">1800. 最大升序子数组和</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数组成的数组 <code>nums</code> ，返回 <code>nums</code> 中一个 <strong>升序</strong> 子数组的最大可能元素和。</p><p>子数组是数组中的一个连续数字序列。</p><p>已知子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，若对所有 <code>i</code>（<code>l &lt;= i &lt; r</code>），<code>numsi</code> &lt; <code>numsi+1</code> 都成立，则称这一子数组为 <strong>升序</strong> 子数组。注意，大小为 1 的子数组也视作 <strong>升序</strong> 子数组。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[10,20,30,5,10,50]</span><br>输出：65<br>解释：<span class="hljs-comment">[5,10,50]</span> 是元素和最大的升序子数组，最大元素和为 65 。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[10,20,30,40,50]</span><br>输出：<span class="hljs-number">150</span><br>解释：<span class="hljs-string">[10,20,30,40,50]</span> 是元素和最大的升序子数组，最大元素和为 <span class="hljs-number">150</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[12,17,15,13,10,11,12]</span><br>输出：33<br>解释：<span class="hljs-comment">[10,11,12]</span> 是元素和最大的升序子数组，最大元素和为 33 。 <br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">100,10,1</span>]<br>输出：<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：简单模拟"><a href="#方法一：简单模拟" class="headerlink" title="方法一：简单模拟"></a>方法一：简单模拟</h3><p>遍历数组，比较相邻元素之间是否满足升序条件。</p><p>用 <code>s</code> 记录当前升序子数组的和，用 <code>ans</code> 记录最终最大的和。</p><ul><li><p>若当前元素大于前一个元素（ <code>nums[i] &gt; nums[i - 1</code>] ），将当前元素 <code>nums[i]</code> 累加到 <code>s</code> 中，并更新 <code>ans = max(ans, s)</code></p></li><li><p>否则，将 <code>s</code> 重置为当前元素，即 <code>s = nums[i]</code></p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxAscendingSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = s = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[i - <span class="hljs-number">1</span>]:<br>                s += nums[i]<br>                ans = <span class="hljs-built_in">max</span>(ans, s)<br>            <span class="hljs-keyword">else</span>:<br>                s = nums[i]<br>        <span class="hljs-keyword">return</span> ans      <br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAscendingSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>], sum = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                sum += nums[i];<br>                ans = Math.max(ans, sum);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sum = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第14篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo从0到1搭建博客系列03：文章与评论模块</title>
    <link href="/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9703%EF%BC%9A%E6%96%87%E7%AB%A0%E4%B8%8E%E8%AF%84%E8%AE%BA%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9703%EF%BC%9A%E6%96%87%E7%AB%A0%E4%B8%8E%E8%AF%84%E8%AE%BA%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo从0到1搭建博客系列03：文章与评论模块"><a href="#Hexo从0到1搭建博客系列03：文章与评论模块" class="headerlink" title="Hexo从0到1搭建博客系列03：文章与评论模块"></a>Hexo从0到1搭建博客系列03：文章与评论模块</h1><h2 id="1-文章的编辑与发布"><a href="#1-文章的编辑与发布" class="headerlink" title="1. 文章的编辑与发布"></a>1. 文章的编辑与发布</h2><p>在这一部分，我们主要学习如何编辑文章，并将其发布在Hexo博客上。</p><p>这一部分我们仍然在Hexo博客根目录上操作。</p><ol><li>执行以下命令，创建一篇新的文章。引号内为博客的标题</li></ol>  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;&quot;</span><br>e.g.: hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;我的第一篇博客&quot;</span><br></code></pre></td></tr></table></figure><p>  如图所示，该博客已经被创建到 <code>source/_posts</code> 目录下啦</p><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/first-blog.png"></p><ol start="2"><li>编辑该页面，可以看到如下信息（可以采用 <a href="https://github.com/marktext/marktext">MarkText</a> 进行编辑，这个是免费的）</li></ol>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">我的第一篇博客</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-10-05 16:00:30</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>  其中包含了博客的 <code>title</code>、<code>date</code>、<code>tags</code>信息</p><ol start="3"><li>接下来，我们编辑博客的 <code>tags</code> 与 <code>categories</code>，仍然需要注意 <code>yaml</code> 格式</li></ol>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">我的第一篇博客</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-10-05 16:00:30</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">学习感悟</span>, <span class="hljs-string">知识分享</span>, <span class="hljs-string">Java</span>]<br><span class="hljs-attr">categories:</span> [<span class="hljs-string">Java基础</span>]<br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><ol start="4"><li>在下面接着编辑博客内容（可以采用 <a href="https://github.com/marktext/marktext">MarkText</a> 进行编辑，这个是免费的）</li></ol><p>  示例如下：</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">我的第一篇博客</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-10-05 16:00:30</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">学习感悟</span>, <span class="hljs-string">知识分享</span>, <span class="hljs-string">Java</span>]<br><span class="hljs-attr">categories:</span> [<span class="hljs-string">Java基础</span>]<br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-comment"># 我的第一篇博客</span><br><br><span class="hljs-comment">## 1. Java基础</span><br><br><span class="hljs-string">Java是一门后端语言，我爱Java。</span><br><br><span class="hljs-comment">## 2. Java实战</span><br><br><span class="hljs-string">第一行代码</span><br><br><span class="hljs-string">```java</span><br><span class="hljs-string">System.out.println(&quot;Hello</span> <span class="hljs-string">World!&quot;);</span><br></code></pre></td></tr></table></figure><ol start="5"><li><code>Ctrl + S</code> 保存，然后将博客运行到本地服务器。</li></ol>  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>这样一来就可以完成博客的编辑与发布啦，看看成品吧~</p><p>下面那一篇是 <code>Hexo</code> 初始化的文章</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/blog-content1.png" alt="https//cdnjsdelivrnet/gh/ltyzzzxxx/ltyzzzImageBed/blogimg/blogcontentpng"></p><p>进入 <code>分类</code>、<code>标签</code> 页可以看到相应的内容</p><h2 id="2-引入评论模块"><a href="#2-引入评论模块" class="headerlink" title="2. 引入评论模块"></a>2. 引入评论模块</h2><p>引入评论听起来非常高大上。如果自己手动搭建一个评论系统，将是需要一定技术的工作，而在<code>Hexo-Fluid</code> 中，这仅仅只是一个简单的配置</p><ol><li>打开之前粘贴好的 <code>_config.fluid.yml</code> 文件，找到以下内容。</li></ol>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">comments:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">disqus</span><br></code></pre></td></tr></table></figure><p>  这里我推荐使用另外一个评论插件 <code>Valine</code>，所以将type进行相应的更改。</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">comments:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">valine</span><br></code></pre></td></tr></table></figure><p>  其他评论插件官方文档有详细的写，如果想尝试其他的，请点击[这里](<a href="https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA">配置指南 | Hexo Fluid 用户手册</a>)查找~</p><ol start="2"><li><p>进入 <a href="https://valine.js.org/quickstart.html">Valine</a> 主页，注册一个 <code>LeanCloud</code> 账号，然后完成相应的实名认证。这一部分就比较简单啦，不再赘述。</p></li><li><p>进入 <code>LeanCloud</code> 个人主页控制台，左上角创建应用。</p></li></ol><p>  我已经创建过啦，就不再创建了。</p><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/leadcloud-page.png"></p><ol start="4"><li>点击进入创建好的应用，点击左侧菜单 设置 - 应用凭证，就可以看到相应的配置信息啦</li></ol><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/leancloud-key.png"></p><ol start="5"><li>将 <code>AppID</code> 与 <code>AppKey</code> 复制并粘贴到 <code>_config.fluid.yml</code> 文件中如下相应的位置</li></ol>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">valine:</span><br>  <span class="hljs-attr">appId:</span> <span class="hljs-string">xxxxx</span><br>  <span class="hljs-attr">appKey:</span> <span class="hljs-string">xxxxx</span><br></code></pre></td></tr></table></figure><ol start="6"><li>保存配置文件，再次运行博客到本地服务器</li></ol>  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>打开之前发布的博客页，拉到最底部，即可看到评论界面啦~</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/comment.png"></p><p>由于 <code>Valine</code> 是一个无后端评论系统，想要管理评论的话，得去 <code>LeanCloud</code> 后台数据存储进行管理相关评论数据。</p><h2 id="3-后记"><a href="#3-后记" class="headerlink" title="3. 后记"></a>3. 后记</h2><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>Hexo搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo从0到1搭建博客系列02：引入Fluid</title>
    <link href="/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9702%EF%BC%9A%E5%BC%95%E5%85%A5Fluid/"/>
    <url>/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9702%EF%BC%9A%E5%BC%95%E5%85%A5Fluid/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo从0到1搭建博客系列02：引入Fluid"><a href="#Hexo从0到1搭建博客系列02：引入Fluid" class="headerlink" title="Hexo从0到1搭建博客系列02：引入Fluid"></a>Hexo从0到1搭建博客系列02：引入Fluid</h1><h2 id="1-Fluid简介"><a href="#1-Fluid简介" class="headerlink" title="1. Fluid简介"></a>1. Fluid简介</h2><blockquote><p>Fluid [官网](<a href="https://hexo.fluid-dev.com/docs/start/">开始使用 | Hexo Fluid 用户手册</a>)</p><p>Fluid 是基于 Hexo 的一款 Material Design 风格的主题，由 Fluid-dev 负责开发与维护。</p><p>主题 GitHub: <a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>预览网站：<a href="https://hexo.fluid-dev.com/">Fluid’s blog</a> <a href="https://zkqiang.cn/">zkqiang’s blog</a></p></blockquote><p>Fluid其实就是基于Hexo现有功能，进行了更进一步的配置、美化，引入了很多新的功能，使我们的博客变得更加美观、简洁与高效。</p><p>在进行Fluid实战之前，必须得先搭建好Hexo基础博客。</p><h2 id="2-Fluid简单实战"><a href="#2-Fluid简单实战" class="headerlink" title="2. Fluid简单实战"></a>2. Fluid简单实战</h2><ol><li>进入之前搭建好的 <code>Hexo</code> 博客目录，执行以下命令，安装 <code>fluid</code> 主题</li></ol>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid</span><br></code></pre></td></tr></table></figure><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/fluid-install.png"></p><ol start="2"><li>在博客目录下创建 <code>_config.fluid.yml</code>，将 <code>fluid</code> 主题自己的 <code>_config.yml</code> 粘贴进去。</li></ol><p>  这一步很重要，一定要进入<a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml%E8%BF%99%E4%B8%80%E7%BD%91%E9%A1%B5%EF%BC%8C">https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml这一网页，</a> 将对应的文件粘贴到之前创建好的空的<code>_config.fluid.yml</code>文件中。这个文件很长，所以没办法贴在这里，见谅~</p><ol start="3"><li>打开创建好的 <code>Hexo</code> 博客目录下的 <code>_config.yml</code> ，将对应配置项修改为以下内容</li></ol><p>  一定要注意这是 <code>yaml</code> 格式文件，冒号后一定要有空格。</p><p>  灵活使用 <code>Ctrl + F</code> 搜索关键字</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><p>仍然是使用 <code>hexo server</code> 命令运行到本地</p><p>展示一下成品吧~</p><p><img src="file:///Users/lty/Downloads/hexo-fluid-page.png?msec=1664956366776"></p><p>是不是瞬间比之前Hexo基础博客提升了一个档次？</p><p>之后我们的大部分功能将在 <code>_config.fluid.yml</code> 文件里完成配置~</p><h2 id="3-后记"><a href="#3-后记" class="headerlink" title="3. 后记"></a>3. 后记</h2><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>Hexo搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo从0到1搭建博客系列01：浅尝Hexo.md</title>
    <link href="/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9701%EF%BC%9A%E6%B5%85%E5%B0%9DHexo-md/"/>
    <url>/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9701%EF%BC%9A%E6%B5%85%E5%B0%9DHexo-md/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo从0到1搭建博客系列01：浅尝Hexo"><a href="#Hexo从0到1搭建博客系列01：浅尝Hexo" class="headerlink" title="Hexo从0到1搭建博客系列01：浅尝Hexo"></a>Hexo从0到1搭建博客系列01：浅尝Hexo</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>作为一个程序员，我们总是想记录一些自己日常学习的东西、自己对于技术的思考以及自己平时折腾的一些小项目。但是自己手动搭建一个博客是很费时费力的一件事情，我们需要考虑一下几点难题：</p><ol><li><p>制作一个博客网站需要这些技术：后端采用 <code>SpringBoot</code> 全家桶，前端采用 <code>Vue/React</code> 。如果追求快速搭建一个博客，可以使用全栈 <code>nodejs</code>（ <code>egg.js</code>、<code>express</code>、<code>koa</code> 等）。如果想让博客功能更强大，需要引入更多的技术。但这些技术的学习都很耗时费力，极可能劝退。</p></li><li><p>如果想让博客页面更好看，需要自己设计 <code>UI</code>。</p></li><li><p>博客最终展示给别人，需要部署到服务器上才能让大家看到。需要买服务器、买域名、域名备案、学习部署知识等等。</p></li><li><p>服务器后期需要维护，一年维护费用可能几百至上千不等。</p></li><li><p>服务器被人恶意攻击（ <code>DDOS</code>、 <code>SQL注入</code> 等），需要自己手动解决或花钱升级服务器。</p></li></ol><p>如果你想要通过博客项目，以此学习前后端的知识、提升自己的编程水平甚至是将其作为一个简历上可以拿得出手的项目，我强烈建议你将以上步骤逐一完成，甚至可以将个人博客延伸为社交博客论坛（类似 <code>CSDN</code>、<code>掘金</code> 等），引入微服务与分布式技术。将这些做完，绝对会有明显的技术提升。</p><p>但是，如果你只想有一个自己的网站去记录一些日常的学习等内容，继续往下看，我将会使用 <code>Hexo</code> 简化以上流程，从0到1实现一个美观精致高效的博客。</p><h2 id="2-Hexo简介"><a href="#2-Hexo简介" class="headerlink" title="2. Hexo简介"></a>2. Hexo简介</h2><p>首先简单介绍一下 <code>Hexo</code></p><blockquote><p>引自[官方](<a href="https://hexo.io/zh-cn/docs/index.html">文档 | Hexo</a>)</p><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p>其实 <code>Hexo</code> 就是帮我们完成了大部分与书写博客无关的事情，我们只需要根据 <code>Hexo</code> 现有的框架，做一些简单的配置，即可做出一个博客网站。之后，我们就可以专注地写自己的博客啦</p><p>在接下来的部分中，你只需要有以下几点前置知识，即可快速完成之后系列的全部内容：</p><ol><li><code>Node.js</code>：主要用于安装<code>Hexo</code>、发布文章、部署等操作</li></ol><p>  安装 <code>Node.js</code> ：</p><ol><li><p><a href="https://nodejs.org/en/download/">官网</a>安装</p></li><li><p>Mac可采用 <code>Homebrew</code> 安装</p></li><li><p><code>Git</code> 及 <code>Github</code>：最后的博客网站将发布到 <code>Github</code> 中</p></li><li><p><code>Markdown</code>：这个很简单，在 <code>CSDN</code> 或者用Typora写过博客的人都知道怎么用</p></li></ol><p>之后全部的实战部分，均采用 <code>VSCode</code> 编辑器完成。如果你熟练使用命令行操作，也可以直接在命令行上完成全部操作。</p><h2 id="3-Hexo简单实战"><a href="#3-Hexo简单实战" class="headerlink" title="3. Hexo简单实战"></a>3. Hexo简单实战</h2><ol><li>首先打开命令行窗口，执行以下命令，安装Hexo。</li></ol>  <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/hexo-install.png"></p><ol start="2"><li>选择一个合适的位置（之后博客全部文件所在的地方），执行以下命令。</li></ol><p>  这里我博客命名为ltyzzz-blog</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init ltyzzz<span class="hljs-literal">-blog</span><br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> ltyzzz<span class="hljs-literal">-blog</span><br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><ol start="3"><li>通过 <code>VSCode</code> 打开创建好的博客目录</li></ol><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/hexo-file.png" alt="https//cdnjsdelivrnet/gh/ltyzzzxxx/ltyzzzImageBed/blogimg/hexofilepng"></p><p>  介绍其中几个重要的文件：</p><ul><li><p>_config.yml：博客相关的配置均在这个文件中（之后引入Fluid主题后有所变化）</p></li><li><p>source：用来存放用户资源的位置（我们写的文章就存储在这里）</p></li></ul><ol start="4"><li>执行以下命令，生成静态网页文件 <code>public</code></li></ol>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><ol start="5"><li>执行以下命令，在本地服务器（默认为：<code>http://localhost:4000/</code>）启动博客</li></ol>  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>最终Hexo基础博客页面如图所示：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/hexo-page.png"></p><p>看到这里，是不是感觉Hexo页面十分的简陋甚至有点丑？</p><p>没关系，之前的部分只是带大家简单尝试一下Hexo，了解一下基本的框架与命令使用。</p><p>我们的重头戏将放在Fluid主题，通过该主题熟悉Hexo核心功能以及Fluid新增的功能。</p><p>接下来的内容包括有：</p><ol><li>博客文章的编辑与发布</li><li>评论区功能模块引入</li><li>图床的最佳实践</li><li>新增留言板界面</li><li>将博客部署到Github</li></ol><h2 id="4-后记"><a href="#4-后记" class="headerlink" title="4. 后记"></a>4. 后记</h2><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>Hexo搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 811. Subdomain Visit Count</title>
    <link href="/2022/10/05/LC-Solution-811-Subdomain-Visit-Count/"/>
    <url>/2022/10/05/LC-Solution-811-Subdomain-Visit-Count/</url>
    
    <content type="html"><![CDATA[<h1 id="811-子域名访问计数"><a href="#811-子域名访问计数" class="headerlink" title="811. 子域名访问计数"></a><a href="https://leetcode.cn/problems/subdomain-visit-count/">811. 子域名访问计数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>网站域名 <code>&quot;discuss.leetcode.com&quot;</code> 由多个子域名组成。顶级域名为 <code>&quot;com&quot;</code> ，二级域名为 <code>&quot;leetcode.com&quot;</code> ，最低一级为 <code>&quot;discuss.leetcode.com&quot;</code> 。当访问域名 <code>&quot;discuss.leetcode.com&quot;</code> 时，同时也会隐式访问其父域名 <code>&quot;leetcode.com&quot;</code> 以及 <code>&quot;com&quot;</code> 。</p><p><strong>计数配对域名</strong> 是遵循 <code>&quot;rep d1.d2.d3&quot;</code> 或 <code>&quot;rep d1.d2&quot;</code> 格式的一个域名表示，其中 <code>rep</code> 表示访问域名的次数，<code>d1.d2.d3</code> 为域名本身。</p><p>例如，<code>&quot;9001 discuss.leetcode.com&quot;</code> 就是一个 <strong>计数配对域名</strong> ，表示 <code>discuss.leetcode.com</code> 被访问了 <code>9001</code> 次。<br>给你一个 <strong>计数配对域名</strong> 组成的数组 <code>cpdomains</code> ，解析得到输入中每个子域名对应的 <strong>计数配对域名</strong> ，并以数组形式返回。可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：cpdomains = [<span class="hljs-string">&quot;9001 discuss.leetcode.com&quot;</span>]<br>输出：[<span class="hljs-string">&quot;9001 leetcode.com&quot;</span>,<span class="hljs-string">&quot;9001 discuss.leetcode.com&quot;</span>,<span class="hljs-string">&quot;9001 com&quot;</span>]<br>解释：例子中仅包含一个网站域名：<span class="hljs-string">&quot;discuss.leetcode.com&quot;</span>。<br>按照前文描述，子域名 <span class="hljs-string">&quot;leetcode.com&quot;</span> 和 <span class="hljs-string">&quot;com&quot;</span> 都会被访问，所以它们都被访问了 <span class="hljs-number">9001</span> 次。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：cpdomains = [<span class="hljs-string">&quot;900 google.mail.com&quot;</span>, <span class="hljs-string">&quot;50 yahoo.com&quot;</span>, <span class="hljs-string">&quot;1 intel.mail.com&quot;</span>, <span class="hljs-string">&quot;5 wiki.org&quot;</span>]<br>输出：[<span class="hljs-string">&quot;901 mail.com&quot;</span>,<span class="hljs-string">&quot;50 yahoo.com&quot;</span>,<span class="hljs-string">&quot;900 google.mail.com&quot;</span>,<span class="hljs-string">&quot;5 wiki.org&quot;</span>,<span class="hljs-string">&quot;5 org&quot;</span>,<span class="hljs-string">&quot;1 intel.mail.com&quot;</span>,<span class="hljs-string">&quot;951 com&quot;</span>]<br>解释：按照前文描述，会访问 <span class="hljs-string">&quot;google.mail.com&quot;</span> <span class="hljs-number">900</span> 次，<span class="hljs-string">&quot;yahoo.com&quot;</span> <span class="hljs-number">50</span> 次，<span class="hljs-string">&quot;intel.mail.com&quot;</span> <span class="hljs-number">1</span> 次，<span class="hljs-string">&quot;wiki.org&quot;</span> <span class="hljs-number">5</span> 次。<br>而对于父域名，会访问 <span class="hljs-string">&quot;mail.com&quot;</span> <span class="hljs-number">900</span> + <span class="hljs-number">1</span> = <span class="hljs-number">901</span> 次，<span class="hljs-string">&quot;com&quot;</span> <span class="hljs-number">900</span> + <span class="hljs-number">50</span> + <span class="hljs-number">1</span> = <span class="hljs-number">951</span> 次，和 <span class="hljs-string">&quot;org&quot;</span> <span class="hljs-number">5</span> 次。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><p><code>1 &lt;= cpdomain.length &lt;= 100</code></p></li><li><p><code>1 &lt;= cpdomain[i].length &lt;= 100</code></p></li><li><p><code>cpdomain[i]</code> 会遵循 <code>&quot;repi d1i.d2i.d3i&quot;</code> 或 <code>&quot;repi d1i.d2i&quot;</code> 格式</p></li><li><p><code>repi</code> 是范围 <code>[1, 104]</code> 内的一个整数</p></li><li><p><code>d1i</code>、<code>d2i</code> 和 <code>d3i</code> 由小写英文字母组成</p></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h3><p>通过哈希表统计 <code>cpdomains</code> 中所有的子域名的频率。</p><p>以 <code>google.mail.com</code> 为例，<code>google.mail.com</code> 为三级域名，<code>mail.com</code> 为二级域名，<code>com</code>为顶级域名。</p><p>思路如下：</p><ol><li><p>遍历 <code>cpdomains</code> 列表，获取每一个 <code>cpdomain</code> 的访问次数 <code>cnt</code> 与其域名 <code>domain</code></p></li><li><p>将 <code>domain</code> 的访问次数累加至原哈希表</p></li><li><p>继续遍历 <code>domain</code>的子域名字符串</p></li><li><p>若 <code>domain[i] == &#39;.&#39;</code>，说明其之后为一个完整的子域名，将其访问次数累加到哈希表中。</p></li><li><p>遍历结束之后，将哈希表的 <code>K</code> 与 <code>V</code> 以列表的形式返回</p></li></ol><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subdomainVisits</span>(<span class="hljs-params">self, cpdomains: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        dic = defaultdict(<span class="hljs-built_in">int</span>)<br>        <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> cpdomains:<br>            ds = d.split()<br>            cnt, domain = <span class="hljs-built_in">int</span>(ds[<span class="hljs-number">0</span>]), ds[<span class="hljs-number">1</span>]<br>            dic[domain] += cnt<br>            <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(domain):<br>                <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;.&#x27;</span>:<br>                    dic[domain[i+<span class="hljs-number">1</span>:]] += cnt<br>        <span class="hljs-keyword">return</span> [<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;v&#125;</span> <span class="hljs-subst">&#123;k&#125;</span>&quot;</span> <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> dic.items()]<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第13篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 921. Minumum Add to Make Parentheses Valid</title>
    <link href="/2022/10/04/LC-Solution-921-Minumum-Add-to-Make-Parentheses-Valid/"/>
    <url>/2022/10/04/LC-Solution-921-Minumum-Add-to-Make-Parentheses-Valid/</url>
    
    <content type="html"><![CDATA[<h1 id="921-使括号有效的最少添加"><a href="#921-使括号有效的最少添加" class="headerlink" title="921. 使括号有效的最少添加"></a><a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/">921. 使括号有效的最少添加</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>只有满足下面几点之一，括号字符串才是有效的：</p><ul><li><p>它是一个空字符串，或者</p></li><li><p>它可以被写成 <code>AB</code> （<code>A</code> 与 <code>B</code> 连接）, 其中 <code>A</code> 和 <code>B</code> 都是有效字符串，或者</p></li><li><p>它可以被写作 <code>(A)</code>，其中 <code>A</code> 是有效字符串。</p></li></ul><p>给定一个括号字符串 <code>s</code> ，移动N次，你就可以在字符串的任何位置插入一个括号。</p><p>例如，如果 <code>s = &quot;()))&quot;</code> ，你可以插入一个开始括号为 <code>&quot;(()))&quot;</code> 或结束括号为 <code>&quot;())))&quot;</code> 。<br>返回 为使结果字符串 <code>s</code> 有效而必须添加的最少括号数。</p><p><strong>示例1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;())&quot;</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(((&quot;</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 字符。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：栈"><a href="#方法一：栈" class="headerlink" title="方法一：栈"></a>方法一：栈</h3><p>对于成对出现的括号题，合法的每一对括号是具有顺序的，可以直观地想到用栈解决。</p><p>将成对的括号移除出栈，最后栈中保留的一定是无法成对的括号数量，最终栈的大小即为需要添加的括号次数。</p><p>遍历字符串 <code>s</code>：</p><ul><li><p>若 <code>s[i] == &#39;(&#39;</code>，直接入栈。</p></li><li><p>若 <code>s[i] == &#39;)&#39;</code>，且当前栈不为空 and 栈顶元素为 <code>&#39;(&#39;</code>，说明此时构成了一对合法括号，可以将栈顶的 <code>&#39;(&#39;</code>出栈。若不满足此条件，则将 <code>s[i]</code> 入栈</p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minAddToMakeValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        q = deque() <br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                q.append(x)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> q[-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                    q.pop()<br>                <span class="hljs-keyword">else</span>:<br>                    q.append(x)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(q)<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minAddToMakeValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Character&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> x : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span>(x == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                d.addLast(x);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(!d.isEmpty() &amp;&amp; d.peekLast() == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    d.pollLast();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    d.addLast(x);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> d.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：模拟计数"><a href="#方法二：模拟计数" class="headerlink" title="方法二：模拟计数"></a>方法二：模拟计数</h3><p>根据题意进行模拟，用 <code>cnt</code> 表示 <code>&#39;(&#39;</code>的个数。</p><p>遍历字符串 <code>s</code></p><ul><li><p>若 <code>s[i] == &#39;(&#39;</code>，cnt++</p></li><li><p>若 <code>s[i] == &#39;)&#39;</code>，cnt–，相当于消除一个 <code>&#39;(&#39;</code></p><ul><li>若此时进行 <code>cnt--</code> 操作之后，cnt变为-1，说明 <code>&#39;(&#39;</code>数量不足，需要添加一个 <code>&#39;(&#39;</code>进行额外配对，并将 <code>cnt</code> 重新置为0</li></ul></li></ul><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minAddToMakeValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        cnt, ans = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                cnt -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cnt == -<span class="hljs-number">1</span>:<br>                cnt = <span class="hljs-number">0</span><br>                ans += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans + cnt<br></code></pre></td></tr></table></figure><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minAddToMakeValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> x : s.toCharArray()) &#123;<br>            cnt += x == <span class="hljs-string">&#x27;(&#x27;</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(cnt == -<span class="hljs-number">1</span>) &#123;<br>                cnt = <span class="hljs-number">0</span>;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans + cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第12篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 926. Flip String to Monotone Increasing</title>
    <link href="/2022/10/03/LC-Solution-926-Flip-String-to-Monotone-Increasing/"/>
    <url>/2022/10/03/LC-Solution-926-Flip-String-to-Monotone-Increasing/</url>
    
    <content type="html"><![CDATA[<h1 id="926-Flip-String-to-Monotone-Increasing"><a href="#926-Flip-String-to-Monotone-Increasing" class="headerlink" title="926. Flip String to Monotone Increasing"></a><a href="https://leetcode.cn/problems/flip-string-to-monotone-increasing/">926. Flip String to Monotone Increasing</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如果一个二进制字符串，是以一些 <code>0</code>（可能没有 <code>0</code>）后面跟着一些 <code>1</code>（也可能没有 <code>1</code>）的形式组成的，那么该字符串是 <strong>单调递增</strong> 的。</p><p>给你一个二进制字符串 <code>s</code>，你可以将任何 <code>0</code> 翻转为 <code>1</code> 或者将 <code>1</code> 翻转为 <code>0</code> 。</p><p>返回使 <code>s</code> 单调递增的最小翻转次数。</p><p><strong>示例1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;00110&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：翻转最后一位得到 <span class="hljs-number">00111</span>.<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;010110&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：翻转得到 <span class="hljs-number">011111</span>，或者是 <span class="hljs-number">000111</span>。<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;00011000&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：翻转得到 <span class="hljs-number">00000000</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：前缀和"><a href="#方法一：前缀和" class="headerlink" title="方法一：前缀和"></a>方法一：前缀和</h3><p>题目要求通过翻转 <code>0</code> 与 <code>1</code> 使得最后得到的二进制字符串为单调递增，</p><p>通过此可以想到：统计字符 <code>s[i]</code> 左边 <code>1</code> 数目，右边 <code>0</code> 的数目。将这些 <code>1</code> 与 <code>0</code> 翻转，最终的字符串 <code>s</code> 即可满足单调递增，翻转次数 &#x3D; 左边 <code>1</code> 的数目 + 右边 <code>0</code> 的数目</p><p>因此，该问题可以采用前缀和的思路解决。</p><ul><li><p>设置 <code>sum</code> 数组统计前缀和（长度为 <code>len(s) + 1</code> ）</p></li><li><p><code>sum[i]</code> 代表字符 <code>s[i]</code> 左边 <code>1</code> 的数目（不包含 <code>i</code> ）</p></li><li><p>通过 <code>sum[i]</code> 可计算得到 <code>s[i]</code> 右边 <code>0</code> 的数目（包含 <code>i</code>）</p><ul><li>右边 <code>0</code> 的数目为：<code>(len(s) - i) - (sum[len(s)] - sum[i])</code></li></ul></li></ul><p>遍历两次字符串 <code>s</code> ，求得最终答案</p><ul><li><p>第一次遍历：求得前缀和数组 <code>sum</code></p></li><li><p>第二次遍历：计算当前翻转次数（左边 <code>1</code> 的数目 + 右边 <code>0</code> 的数目）并与 <code>ans</code> 比较，取最小值。</p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minFlipsMonoIncr</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n, ans = <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-built_in">sum</span> = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-built_in">sum</span>[i] = <span class="hljs-built_in">sum</span>[i - <span class="hljs-number">1</span>] + (s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>):<br>            l_ones, r_zeros = <span class="hljs-built_in">sum</span>[i], n - i - (<span class="hljs-built_in">sum</span>[n] - <span class="hljs-built_in">sum</span>[i])<br>            ans = <span class="hljs-built_in">min</span>(ans, l_ones + r_zeros)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFlipsMonoIncr</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            sum[i] = sum[i - <span class="hljs-number">1</span>] + (cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftOnes</span> <span class="hljs-operator">=</span> sum[i], rightZeros = n - i - (sum[n] - sum[i]);<br>            ans = Math.min(ans, leftOnes + rightZeros);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：优化前缀和"><a href="#方法二：优化前缀和" class="headerlink" title="方法二：优化前缀和"></a>方法二：优化前缀和</h3><p>方法一种提到：</p><ul><li><p><code>s[i]</code> 左边 <code>1</code> 的数目为 <code>sum[i]</code></p></li><li><p><code>s[i]</code> 右边 <code>0</code> 的数目为 <code>(len(s) - i) - (sum[len(s)] - sum[i])</code></p></li><li><p>遍历一轮 <code>s</code>，二者求和的最小值即为答案</p></li></ul><p>即 <code>left_ones + right_zeros = 2 * sum[i] - i + len(s) - sum[len(s)]</code></p><p>因此，只需保证 <code>2 * sum[i] - i</code> 为最小值，然后求得所有 <code>1</code> 的数目，即可得到最终的翻转次数，采用常数级空间复杂度即可实现。</p><p>注意：根据之前的定义，这里 <code>i</code> 的最大值仍然为 <code>len(s)</code></p><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minFlipsMonoIncr</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n, ans, l_ones = <span class="hljs-built_in">len</span>(s), inf, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>):<br>            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-number">2</span> * l_ones - i)<br>            <span class="hljs-comment"># 防止越界</span><br>            <span class="hljs-keyword">if</span> i &lt; n:<br>                l_ones += s[i] == <span class="hljs-string">&#x27;1&#x27;</span><br>        <span class="hljs-keyword">return</span> ans + n - l_ones;<br></code></pre></td></tr></table></figure><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFlipsMonoIncr</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), ans = Integer.MAX_VALUE, leftOnes = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            ans = Math.min(ans, <span class="hljs-number">2</span> * leftOnes - i);<br>            <span class="hljs-keyword">if</span>(i &lt; n) &#123;<br>                leftOnes += s.charAt(i) == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans + n - leftOnes;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第11篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 881. Boats to Save People</title>
    <link href="/2022/10/03/LC-Solution-881-Boats-to-Save-People/"/>
    <url>/2022/10/03/LC-Solution-881-Boats-to-Save-People/</url>
    
    <content type="html"><![CDATA[<h1 id="881-救生艇"><a href="#881-救生艇" class="headerlink" title="881. 救生艇"></a><a href="https://leetcode.cn/problems/boats-to-save-people/">881. 救生艇</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定数组 <code>people</code> 。<code>people[i]</code>表示第 <code>i</code> 个人的体重 ，<strong>船的数量不限</strong>，每艘船可以承载的最大重量为 <code>limit</code>。</p><p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 <code>limit</code>。</p><p>返回 <em>承载所有人所需的最小船数</em> 。</p><p><strong>示例1：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：people = [1,2], <span class="hljs-built_in">limit</span> = 3<br>输出：1<br>解释：1 艘船载 (1, 2)<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：people = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], limit = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-number">3</span> 艘船分别载 <span class="hljs-comment">(1, 2)</span>, <span class="hljs-comment">(2)</span> 和 <span class="hljs-comment">(3)</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：people = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], limit = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">4</span><br>解释：<span class="hljs-number">4</span> 艘船分别载 <span class="hljs-comment">(3)</span>, <span class="hljs-comment">(3)</span>, <span class="hljs-comment">(4)</span>, <span class="hljs-comment">(5)</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= people.length &lt;= 5 * 104</code></li><li><code>1 &lt;= people[i] &lt;= limit &lt;= 3 * 104</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：贪心-双指针"><a href="#方法一：贪心-双指针" class="headerlink" title="方法一：贪心 + 双指针"></a>方法一：贪心 + 双指针</h3><p>通过分析题意可以得出以下几点关键的信息：</p><ol><li><p>可用船数不限制</p></li><li><p>每艘船限乘2人，每搜船限制总重为<code>limit</code></p></li><li><p>返回结果与<code>people</code>数组的顺序无关</p></li></ol><p>为使得使用的船数最少，每搜船上的两个人的总重量最好 <strong>等于或尽可能接近</strong> <code>limit</code></p><p>因此，不难得出本题的思路：对<code>people</code>数组进行升序排序，双指针遍历<code>people</code>数组。</p><p>需要注意的一点：双指针<code>i</code>与<code>j</code>重合时，此时只剩余一个人，所以他单独乘一艘船。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numRescueBoats</span>(<span class="hljs-params">self, people: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], limit: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        people.sort()<br>        i, j, ans = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(people) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt;= j:<br>            <span class="hljs-keyword">if</span> i == j:<br>                ans += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> people[i] + people[j] &lt;= limit:<br>                ans, i, j = ans + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                ans, j = ans + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numRescueBoats</span><span class="hljs-params">(<span class="hljs-type">int</span>[] people, <span class="hljs-type">int</span> limit)</span> &#123;<br>        Arrays.sort(people);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = people.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-keyword">if</span>(i == j) &#123;<br>                ans++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(people[i] + people[j] &lt;= limit) &#123;<br>                ans++; i++; j--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans++; j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第10篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1784 Check if Binary String Has at Most One Segment of Ones</title>
    <link href="/2022/10/03/LC-Solution-1784-Check-if-Binary-String-Has-at-Most-One-Segment-of-Ones/"/>
    <url>/2022/10/03/LC-Solution-1784-Check-if-Binary-String-Has-at-Most-One-Segment-of-Ones/</url>
    
    <content type="html"><![CDATA[<h1 id="1784-检查二进制字符串字段"><a href="#1784-检查二进制字符串字段" class="headerlink" title="1784. 检查二进制字符串字段"></a><a href="https://leetcode.cn/problems/check-if-binary-string-has-at-most-one-segment-of-ones/">1784. 检查二进制字符串字段</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二进制字符串 <code>s</code> ，该字符串 <strong>不含前导零</strong> 。</p><p>如果 <code>s</code> 包含 <strong>零个或一个由连续的 ‘1’ 组成的字段</strong> ，返回 <code>true</code>​​​ 。否则，返回 <code>false</code></p><p>如果 <code>s</code> 中 <strong>由连续若干个 ‘1’ 组成的字段 数量不超过 1</strong>，返回 <code>true</code>​​​ 。否则，返回 <code>false</code></p><p><strong>示例1：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;1001&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：由连续若干个 <span class="hljs-string">&#x27;1&#x27;</span> 组成的字段数量为 <span class="hljs-number">2</span>，返回 <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;110&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s[i]</code>​​​​ 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li><li><code>s[0]</code> 为 <code>&#39;1&#39;</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：简单模拟"><a href="#方法一：简单模拟" class="headerlink" title="方法一：简单模拟"></a>方法一：简单模拟</h3><p>题目已经明确给定<code>s[0] = &#39;1&#39;</code>，所以我们只需要找出<code>s</code>中的第一个字符<code>&#39;0&#39;</code>的下标。</p><ul><li><p>若字符串<code>s</code>中不存在<code>&#39;0&#39;</code>，那么一定全为<code>&#39;1&#39;</code>，返回<code>True</code></p></li><li><p>若字符串<code>s</code>中存在<code>&#39;0&#39;</code>，但是在它的后面不存在<code>&#39;1&#39;</code>，说明<code>s</code>中只有一个由连续的<code>&#39;1&#39;</code>组成的字段（因为<code>s[0] = &#39;1&#39;</code>），返回<code>True</code></p></li></ul><p>若不满足以上两点条件，直接返回<code>False</code></p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkOnesSegment</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        idx = s.find(<span class="hljs-string">&#x27;0&#x27;</span>)<br>        <span class="hljs-keyword">if</span> idx == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s[idx:]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>采用三元表达式写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkOnesSegment</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> s.find(<span class="hljs-string">&#x27;0&#x27;</span>) == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s[s.find(<span class="hljs-string">&#x27;0&#x27;</span>):] <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkOnesSegment</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> s.indexOf(<span class="hljs-string">&quot;0&quot;</span>);<br>        <span class="hljs-keyword">if</span>(idx == -<span class="hljs-number">1</span> || s.substring(idx).indexOf(<span class="hljs-string">&quot;1&quot;</span>) == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure><p>采用三元表达式写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkOnesSegment</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> s.indexOf(<span class="hljs-string">&quot;0&quot;</span>) == -<span class="hljs-number">1</span> || s.substring(s.indexOf(<span class="hljs-string">&quot;0&quot;</span>)).indexOf(<span class="hljs-string">&quot;1&quot;</span>) == -<span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第9篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 807. Max Increase to Keep City Skyline</title>
    <link href="/2022/10/03/LC-Solution-807-Max-Increase-to-Keep-City-Skyline/"/>
    <url>/2022/10/03/LC-Solution-807-Max-Increase-to-Keep-City-Skyline/</url>
    
    <content type="html"><![CDATA[<h1 id="807-保持城市天际线"><a href="#807-保持城市天际线" class="headerlink" title="807. 保持城市天际线"></a><a href="https://leetcode.cn/problems/max-increase-to-keep-city-skyline/">807. 保持城市天际线</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一座由 <code>n x n</code> 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 <strong>0</strong> 开始的 <code>n x n</code> 整数矩阵 <code>grid</code> ，其中 <code>grid[r][c]</code> 表示坐落于 <code>r</code> 行 <code>c</code> 列的建筑物的 <strong>高度</strong> 。</p><p>城市的 <strong>天际线</strong> 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 <strong>天际线</strong> 可能不同。</p><p>我们被允许为 <strong>任意数量的建筑物</strong> 的高度增加 <strong>任意增量（不同建筑物的增量可能不同）</strong> 。 高度为 0 的建筑物的高度也可以增加。然而，增加的建筑物高度 <strong>不能影响</strong> 从任何主要方向观察城市得到的 <strong>天际线</strong> 。</p><p>在 <strong>不改变</strong> 从任何主要方向观测到的城市 <strong>天际线</strong> 的前提下，返回建筑物可以增加的 <strong>最大高度增量总和</strong></p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：grid = <span class="hljs-comment">[<span class="hljs-comment">[3,0,8,4]</span>,<span class="hljs-comment">[2,4,5,7]</span>,<span class="hljs-comment">[9,2,6,3]</span>,<span class="hljs-comment">[0,3,1,0]</span>]</span><br>输出：35<br>解释：建筑物的高度如上图中心所示。<br>用红色绘制从不同方向观看得到的天际线。<br>在不影响天际线的情况下，增加建筑物的高度：<br>gridNew = <span class="hljs-comment">[ <span class="hljs-comment">[8, 4, 8, 7]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[7, 4, 7, 7]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[9, 4, 8, 7]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[3, 3, 3, 3]</span> ]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[0,0,0],[0,0,0],[0,0,0]]</span><br>输出：<span class="hljs-number">0</span><br>解释：增加任何建筑物的高度都会导致天际线的变化。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == grid.length</code></li><li><code>n == grid[r].length</code></li><li><code>2 &lt;= n &lt;= 50</code></li><li><code>0 &lt;= grid[r][c] &lt;= 100</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：贪心算法"><a href="#方法一：贪心算法" class="headerlink" title="方法一：贪心算法"></a>方法一：贪心算法</h3><p>分析题意不难得出，东南西北的视图即<code>天际线</code>是由每行每列的最大值决定的。</p><p>因此，每个建筑最终达到的高度不能超过其所在行与列的最大高度，更加具体地说，不能超过<code>min(该行最大高度, 该列最大高度)</code>。</p><ul><li><p>第一遍遍历：提前预处理出每一行与每一列对应的最大高度值</p></li><li><p>第二遍遍历：往<code>ans</code>结果中累加当前遍历的建筑可以增加的最大高度</p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxIncreaseKeepingSkyline</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans, n = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(grid)<br>        rowMax, colMax = [<span class="hljs-number">0</span>] * n, [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                rowMax[i] = <span class="hljs-built_in">max</span>(rowMax[i], grid[i][j])<br>                colMax[j] = <span class="hljs-built_in">max</span>(colMax[j], grid[i][j])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                ans += <span class="hljs-built_in">min</span>(rowMax[i], colMax[j]) - grid[i][j]<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxIncreaseKeepingSkyline</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span>[] rowMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], colMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                rowMax[i] = Math.max(rowMax[i], grid[i][j]);<br>                colMax[j] = Math.max(colMax[j], grid[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                ans += Math.min(rowMax[i], colMax[j]) - grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第8篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 781. Rabbits in Forest</title>
    <link href="/2022/10/03/LC-Solution-781-Rabbits-in-Forest/"/>
    <url>/2022/10/03/LC-Solution-781-Rabbits-in-Forest/</url>
    
    <content type="html"><![CDATA[<h1 id="781-森林中的兔子"><a href="#781-森林中的兔子" class="headerlink" title="781. 森林中的兔子"></a><a href="https://leetcode.cn/problems/rabbits-in-forest/">781. 森林中的兔子</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>森林中有未知数量的兔子。提问其中若干只兔子 “<strong>还有多少只兔子与你（指被提问的兔子）颜色相同?</strong>“ ，将答案收集到一个整数数组 <code>answers</code> 中，其中 <code>answers[i]</code> 是第 <code>i</code> 只兔子的回答。</p><p>给你数组 <code>answers</code> ，返回森林中兔子的最少数量。</p><p><strong>示例1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：answers = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">5</span><br>解释：<br>两只回答了 <span class="hljs-string">&quot;1&quot;</span> 的兔子可能有相同的颜色，设为红色。 <br>之后回答了 <span class="hljs-string">&quot;2&quot;</span> 的兔子不会是红色，否则他们的回答会相互矛盾。<br>设回答了 <span class="hljs-string">&quot;2&quot;</span> 的兔子为蓝色。 <br>此外，森林中还应有另外 <span class="hljs-number">2</span> 只蓝色兔子的回答没有包含在数组中。 <br>因此森林中兔子的最少数量是 <span class="hljs-number">5</span> 只：<span class="hljs-number">3</span> 只回答的和 <span class="hljs-number">2</span> 只没有回答的。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：answers </span>=<span class="hljs-string"> [10,10,10]</span><br><span class="hljs-string">输出：11</span><br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：找规律"><a href="#方法一：找规律" class="headerlink" title="方法一：找规律"></a>方法一：找规律</h3><p>举例分析：</p><ol><li><p>当数组为<code>[2, 2 ,2]</code>时，1种颜色 - 3只兔子</p></li><li><p>当数组为<code>[2, 2, 2, 2]</code>时，2种颜色 - 6只兔子（前三只兔子为一种颜色，最后一只兔子以及未被问到的另外两只不知名兔子为另一种颜色）</p></li><li><p>当数组为<code>[2, 2, 2, 2, 2, 2]</code>时，2种颜色 - 6只兔子（前三只兔子为一种颜色，后三只兔子为另一种颜色）</p></li><li><p>当数组为<code>[2, 2, 2, 2, 2, 2, 2]</code>时，3种颜色 - 9只兔子（1,2,3号兔子为色号1，4,5,6号兔子为色号2，7号兔子以及另外两只不知名兔子为色号3）</p></li><li><p>以此类推…</p></li></ol><p>经过分析，抽象为数学找规律的题目。</p><p>用哈希表统计同一个数字出现的频率。设<code>num</code>为哈希表的key，<code>freq</code>为哈希表的值。</p><p>将<code>freq</code>分为<code>freq // (num + 1)</code>个组，余数再单独分到另一个组。</p><p>举例：<code>[1, 1, 2, 2, 2, 2, 2]</code>数组统计存入哈希表后。一个键值对为<code>&#123;1: 2&#125;</code>，可以被分为<code>2 // (1 + 1) = 1</code>个组，正好整除。另一个键值对为<code>&#123;2: 4&#125;</code>，可以被分为<code>4 // (2 + 1) = 1</code>个组，剩余的2组成一个组。答案为每个键值对对应的组数乘以<code>num + 1</code>求和</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numRabbits</span>(<span class="hljs-params">self, answers: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        dic = Counter(answers)<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> num, freq <span class="hljs-keyword">in</span> dic.items():<br>            ans += freq // (num + <span class="hljs-number">1</span>) * (num + <span class="hljs-number">1</span>) <br>            <span class="hljs-keyword">if</span> freq % (num + <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>:<br>                ans += num + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第7篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 777. Swap Adjacent in LR String</title>
    <link href="/2022/10/03/LC-Solution-777-Swap-Adjacent-in-LR-String/"/>
    <url>/2022/10/03/LC-Solution-777-Swap-Adjacent-in-LR-String/</url>
    
    <content type="html"><![CDATA[<h1 id="777-在LR字符串中交换相邻字符"><a href="#777-在LR字符串中交换相邻字符" class="headerlink" title="777. 在LR字符串中交换相邻字符"></a><a href="https://leetcode.cn/problems/swap-adjacent-in-lr-string/">777. 在LR字符串中交换相邻字符</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个由 <code>&#39;L&#39;</code> , <code>&#39;R&#39;</code> 和 <code>&#39;X&#39;</code> 三个字符组成的字符串（例如<code>&quot;RXXLRXRXL&quot;</code>）中进行移动操作。一次移动操作指用一个<code>&quot;LX&quot;</code>替换一个<code>&quot;XL&quot;</code>，或者用一个<code>&quot;XR&quot;</code>替换一个<code>&quot;RX&quot;</code>。现给定起始字符串<code>start</code>和结束字符串<code>end</code>，请编写代码，当且仅当存在一系列移动操作使得<code>start</code>可以转换成<code>end</code>时， 返回<code>True</code>。</p><p><strong>示例：</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coq">输入: start = <span class="hljs-string">&quot;RXXLRXRXL&quot;</span>, <span class="hljs-keyword">end</span> = <span class="hljs-string">&quot;XRLXXRRLX&quot;</span><br>输出: True<br>解释:<br>我们可以通过以下几步将start转换成<span class="hljs-keyword">end</span>:<br>RXXLRXRXL -&gt;<br>XRXLRXRXL -&gt;<br>XRLXRXRXL -&gt;<br>XRLXXRRXL -&gt;<br>XRLXXRRLX<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= len(start) = len(end) &lt;= 10000</code>。</li><li><code>start</code>和<code>end</code>中的字符串仅限于<code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>和<code>&#39;X&#39;</code>。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h3><p>根据题意进行分析模拟，题目将每一个<code>XL</code>都替换成了<code>LX</code>，将每一个<code>RX</code>都替换成了<code>XR</code></p><p>通过找规律可发现，替换的过程可以理解为<code>L</code>与<code>R</code>移动的过程。</p><ul><li><p>当<code>L</code>的左边为<code>X</code>时，<code>L</code>可向左移动</p></li><li><p>当<code>R</code>的右边为<code>X</code>时，<code>R</code>可向右移动</p></li><li><p><code>L</code>与<code>R</code>无法互相穿过（因为<code>L</code>左和<code>R</code>右必须为<code>X</code>）</p><ul><li>可得知当<code>start</code>与<code>end</code>去掉<code>X</code>后，剩余字符必须相同，否则返回False</li></ul></li></ul><p>根据此规律，使用双指针<code>i</code>与<code>j</code>从头到尾遍历<code>start</code>与<code>end</code></p><p>找到<code>start</code>与<code>end</code>中<code>非X</code>的字符时则停止移动，进行判断</p><p>判断条件为：</p><ul><li><p>若<code>start[i] == L and i &lt; j</code>，又因<code>L</code>无法向右移动，直接返回False</p></li><li><p>若<code>start[i] == R and i &gt; j</code>，又因<code>R</code>无法向左移动，直接返回False</p></li></ul><p>当双指针遍历字符串结束后，说明中途未返回False，则最终返回True</p><p>注意：</p><p><code>if i != j and (start[i] == &#39;L&#39;) != (i &gt; j)</code>该行代码摘自<a href="https://leetcode.cn/u/endlesscheng/">灵山茶艾府</a>大佬的题解，相当于将两个<code>if</code>判断条件揉为一个，其本质为：</p><ul><li><p><code>if i &lt; j and start[i] == &#39;L&#39;: return False</code></p></li><li><p><code>if i &gt; j and start[i] == &#39;R&#39;: return False</code></p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canTransform</span>(<span class="hljs-params">self, start: <span class="hljs-built_in">str</span>, end: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> start.replace(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>) != end.replace(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        n = <span class="hljs-built_in">len</span>(start)<br>        i = j = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; n <span class="hljs-keyword">and</span> j &lt; n:<br>            <span class="hljs-keyword">while</span> i &lt; n <span class="hljs-keyword">and</span> start[i] == <span class="hljs-string">&#x27;X&#x27;</span>: i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> j &lt; n <span class="hljs-keyword">and</span> end[j] == <span class="hljs-string">&#x27;X&#x27;</span>: j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> i != j <span class="hljs-keyword">and</span> (start[i] == <span class="hljs-string">&#x27;L&#x27;</span>) != (i &gt; j): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            i, j = i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canTransform</span><span class="hljs-params">(String start, String end)</span> &#123;<br>        <span class="hljs-keyword">if</span>(!start.replace(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).equals(end.replace(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> start.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; j &lt; n) &#123;<br>            <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; start.charAt(i) == <span class="hljs-string">&#x27;X&#x27;</span>) i += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(j &lt; n &amp;&amp; end.charAt(j) == <span class="hljs-string">&#x27;X&#x27;</span>) j += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> ((i != j) &amp;&amp; ((start.charAt(i) == <span class="hljs-string">&#x27;L&#x27;</span>) != (i &gt; j))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            i++; j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第5篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1694. Reformat Phone Number</title>
    <link href="/2022/10/03/LC-Solution-1694-Reformat-Phone-Number/"/>
    <url>/2022/10/03/LC-Solution-1694-Reformat-Phone-Number/</url>
    
    <content type="html"><![CDATA[<h1 id="1694-重新格式化电话号码"><a href="#1694-重新格式化电话号码" class="headerlink" title="1694. 重新格式化电话号码"></a><a href="https://leetcode.cn/problems/reformat-phone-number/">1694. 重新格式化电话号码</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串形式的电话号码 <code>number</code> 。<code>number</code> 由数字、空格 <code>&#39; &#39;</code>、和破折号<code>&#39;-&#39;</code>组成。</p><p>请你按下述方式重新格式化电话号码。</p><ul><li><p>首先，删除 所有的空格和破折号。</p></li><li><p>其次，将数组从左到右 每 3 个一组 分块，直到 剩下 4 个或更少数字。剩下的数字将按下述规定再分块：</p><ul><li><p>2 个数字：单个含 2 个数字的块。</p></li><li><p>3 个数字：单个含 3 个数字的块。</p></li><li><p>4 个数字：两个分别含 2 个数字的块。</p></li></ul></li><li><p>最后用破折号将这些块连接起来。注意，重新格式化过程中 不应该 生成仅含 1 个数字的块，并且 最多 生成两个含 2 个数字的块。</p></li></ul><p>返回格式化后的电话号码。</p><p><strong>示例1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：number <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1-23-45 6&quot;</span><br>输出：<span class="hljs-string">&quot;123-456&quot;</span><br>解释：数字是 <span class="hljs-string">&quot;123456&quot;</span><br>步骤 <span class="hljs-number">1</span>：共有超过 <span class="hljs-number">4</span> 个数字，所以先取 <span class="hljs-number">3</span> 个数字分为一组。第 <span class="hljs-number">1</span> 个块是 <span class="hljs-string">&quot;123&quot;</span> 。<br>步骤 <span class="hljs-number">2</span>：剩下 <span class="hljs-number">3</span> 个数字，将它们放入单个含 <span class="hljs-number">3</span> 个数字的块。第 <span class="hljs-number">2</span> 个块是 <span class="hljs-string">&quot;456&quot;</span> 。<br>连接这些块后得到 <span class="hljs-string">&quot;123-456&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：number <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123 4-567&quot;</span><br>输出：<span class="hljs-string">&quot;123-45-67&quot;</span><br>解释：数字是 <span class="hljs-string">&quot;1234567&quot;</span>.<br>步骤 <span class="hljs-number">1</span>：共有超过 <span class="hljs-number">4</span> 个数字，所以先取 <span class="hljs-number">3</span> 个数字分为一组。第 <span class="hljs-number">1</span> 个块是 <span class="hljs-string">&quot;123&quot;</span> 。<br>步骤 <span class="hljs-number">2</span>：剩下 <span class="hljs-number">4</span> 个数字，所以将它们分成两个含 <span class="hljs-number">2</span> 个数字的块。这 <span class="hljs-number">2</span> 块分别是 <span class="hljs-string">&quot;45&quot;</span> 和 <span class="hljs-string">&quot;67&quot;</span> 。<br>连接这些块后得到 <span class="hljs-string">&quot;123-45-67&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：number <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123 4-5678&quot;</span><br>输出：<span class="hljs-string">&quot;123-456-78&quot;</span><br>解释：数字是 <span class="hljs-string">&quot;12345678&quot;</span> 。<br>步骤 <span class="hljs-number">1</span>：第 <span class="hljs-number">1</span> 个块 <span class="hljs-string">&quot;123&quot;</span> 。<br>步骤 <span class="hljs-number">2</span>：第 <span class="hljs-number">2</span> 个块 <span class="hljs-string">&quot;456&quot;</span> 。<br>步骤 <span class="hljs-number">3</span>：剩下 <span class="hljs-number">2</span> 个数字，将它们放入单个含 <span class="hljs-number">2</span> 个数字的块。第 <span class="hljs-number">3</span> 个块是 <span class="hljs-string">&quot;78&quot;</span> 。<br>连接这些块后得到 <span class="hljs-string">&quot;123-456-78&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：number <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12&quot;</span><br>输出：<span class="hljs-string">&quot;12&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例5：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：number = &quot;-<span class="hljs-string">-17</span><span class="hljs-string">-5</span> 229 35<span class="hljs-string">-39475</span> &quot;<br>输出：&quot;175<span class="hljs-string">-229</span><span class="hljs-string">-353</span><span class="hljs-string">-94</span><span class="hljs-string">-75</span>&quot;<br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：简单模拟"><a href="#方法一：简单模拟" class="headerlink" title="方法一：简单模拟"></a>方法一：简单模拟</h3><p>先预处理<code>number</code>字符串，去除字符串中除数字之外的字符。</p><p>定义<code>res</code>为字符串列表，其中的每一个字符串最终需要以<code>&#39;-&#39;</code>分割。</p><p>根据题意分析循环过程中的if条件（<code>i</code>表示当前遍历位置，<code>s</code>表示预处理后的字符串）：</p><ul><li><p>若当前位置<code>i + 4 == len(s)</code>，将<code>s[i:i+2]</code>与<code>s[i+2:i+4]</code>切片追加到<code>res</code>列表</p></li><li><p>否则，直接将<code>s[i:i+3]</code>切片追加到<code>res</code>列表</p><ul><li><p>这里隐藏了一点：<code>i + 2 == len(s)</code>的特殊情况已经考虑在else情况中：</p><ul><li>巧妙利用了Python的切片性质：右边界超出字符串长度时，直接将字符串长度作为右边界。</li></ul></li></ul></li></ul><p>理清模拟逻辑后，开始编写代码，注意循环的<code>step</code>为3，最后用<code>&#39;-&#39;</code>将res拼接。</p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reformatNumber</span>(<span class="hljs-params">self, number: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        s = number.replace(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>        res = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-number">3</span>):<br>            <span class="hljs-keyword">if</span> i + <span class="hljs-number">4</span> == <span class="hljs-built_in">len</span>(s):<br>                res.append(s[i:i + <span class="hljs-number">2</span>])<br>                res.append(s[i + <span class="hljs-number">2</span>:i + <span class="hljs-number">4</span>])   <br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                res.append(s[i: i + <span class="hljs-number">3</span>])<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;-&#x27;</span>.join(res)<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第4篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution Interview Questions 01.08</title>
    <link href="/2022/10/03/LC-Solution-Interview-Questions-01-08/"/>
    <url>/2022/10/03/LC-Solution-Interview-Questions-01-08/</url>
    
    <content type="html"><![CDATA[<h1 id="01-08-Zero-Matrix-LCCI"><a href="#01-08-Zero-Matrix-LCCI" class="headerlink" title="01.08. Zero Matrix LCCI"></a><a href="https://leetcode.cn/problems/zero-matrix-lcci/">01.08. Zero Matrix LCCI</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,1,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,0,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,1,1]</span></span><br><span class="hljs-comment">]</span><br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,0,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[0,0,0]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,0,1]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[0,1,2,0]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4,5,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3,1,5]</span></span><br><span class="hljs-comment">]</span><br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[0,0,0,0]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[0,4,5,0]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[0,3,1,0]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h3><p>题目要求当二维数组中的某个元素值为0时，将其所在的行和列的全部元素置为0。</p><p>通过分析题意，可以想到采用标记数组存储符合题意的行与列。</p><ul><li><p>第一次遍历：标记行与列</p></li><li><p>第二次遍历：对标记的行与列中的元素进行修改</p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setZeroes</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        row = [<span class="hljs-literal">False</span>] * <span class="hljs-built_in">len</span>(matrix)<br>        col = [<span class="hljs-literal">False</span>] * <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span>:<br>                    row[i] = col[j] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>                matrix[i][j] = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> row[i] == <span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> col[j] == <span class="hljs-literal">True</span> <span class="hljs-keyword">else</span> matrix[i][j]<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[] row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m], col = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    row[i] = col[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span>(row[i] == <span class="hljs-literal">true</span> || col[j] == <span class="hljs-literal">true</span>) &#123;<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第3篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 3. Longest Substring Without Repeating Characters</title>
    <link href="/2022/10/03/LC-Solution-3-Longest-Substring-Without-Repeating-Characters/"/>
    <url>/2022/10/03/LC-Solution-3-Longest-Substring-Without-Repeating-Characters/</url>
    
    <content type="html"><![CDATA[<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><h3 id="方法一：滑动窗口"><a href="#方法一：滑动窗口" class="headerlink" title="方法一：滑动窗口"></a>方法一：滑动窗口</h3><p>题目要求从给定字符串<code>s</code>中找出不包含重复字符的最长子串的长度</p><p>由于子串是连续的，可以想到采用滑动窗口解决该问题。</p><p>思路如下：</p><ul><li><p>采用双指针<code>i</code>与<code>j</code>作为滑动窗口的左端点与右端点，初始值为0</p></li><li><p>采用哈希表记录已经遍历过的字符。其<code>key</code>为字符本身，<code>value</code>为当前字符对应的下标</p></li><li><p>设<code>maxLen</code>为不包含重复字符的最长子串的长度</p></li><li><p>从头到尾遍历字符串<code>s</code></p><ol><li>判断哈希表是否存储当前字符<code>c</code></li></ol><ul><li><p>若哈希表已存储当前字符<code>c</code></p><ul><li><p>需要收缩滑动窗口，即更新滑动窗口左端点<code>i</code>的位置</p><ul><li><p>此时，左端点<code>i</code>有两种选择，第一种为保持<code>i</code>不变，第二种为将其更新为哈希表中当前字符<code>c</code>对应的下标再加1</p><ol><li><p>如果当前滑动窗口不包含当前字符<code>c</code>但哈希表中却存储着<code>c</code>，则需要选择第一种更新方案。例如<code>abba</code>字符串。</p></li><li><p>如果当前滑动窗口包含当前字符<code>c</code>，则需要选择第二种更新方案。例如<code>abca</code>字符串。</p></li></ol></li></ul><p>. 为综合以上两种更新方案，左端点<code>i</code>更新时区二者最大值即可。</p></li></ul></li></ul><ol start="2"><li><p>更新哈希表</p></li><li><p>比较当前滑动窗口长度与<code>maxLen</code>的大小，并为<code>maxLen</code>赋值</p></li><li><p>滑动窗口向右滑动，<code>j</code>自增</p></li></ol></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dic = defaultdict(<span class="hljs-built_in">int</span>)<br>        maxlen, left = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">in</span> dic:<br>                left = <span class="hljs-built_in">max</span>(dic[s[i]] + <span class="hljs-number">1</span>, left)<br>            dic[s[i]] = i<br>            maxlen = <span class="hljs-built_in">max</span>(maxlen, i - left + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> maxlen<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, curLen = <span class="hljs-number">0</span>;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            curLen++;<br>            <span class="hljs-keyword">while</span>(set.contains(s.charAt(i))) &#123;<br>                set.remove(s.charAt(left));<br>                left++;<br>                curLen--;<br>            &#125;<br>            maxLen = Math.max(curLen, maxLen);<br>            set.add(s.charAt(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第6篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 2. Add Two Nums</title>
    <link href="/2022/10/03/LC-Solution-2-Add-Two-Nums/"/>
    <url>/2022/10/03/LC-Solution-2-Add-Two-Nums/</url>
    
    <content type="html"><![CDATA[<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[2,4,3]</span>, l2 = <span class="hljs-comment">[5,6,4]</span><br>输出：<span class="hljs-comment">[7,0,8]</span><br>解释：342 + 465 = 807.<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[0]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：l1 = [<span class="hljs-number">9,9,9,9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>], l2 = [<span class="hljs-number">9,9,9,9</span>]<br>输出：[<span class="hljs-number">8,9,9,9</span>,<span class="hljs-number">0,0,0,1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：链表-数学-模拟"><a href="#方法一：链表-数学-模拟" class="headerlink" title="方法一：链表 + 数学 + 模拟"></a>方法一：链表 + 数学 + 模拟</h3><p>此题可直接理解为数学中的竖式相加</p><p>链表从左至右可以理解为从低位到高位，因此依次遍历链表，同一位置直接相加即可</p><p>设当前两个链表相同位置上的数分别为<code>x1</code>与<code>x2</code>，其进位值为<code>carry</code></p><p>进行相加之后，<code>sum</code>为<code>x1 + x2 + carry</code>，则</p><ul><li><p>结果链表的当前值<code>head.val = sum % 10</code>，添加至结果链表，链表前移</p></li><li><p>新的进位值<code>carry = sum // 10</code></p></li></ul><p>依次类推，继续前移链表节点，直至两链表遍历结束。</p><p>注意：遍历结束之后，需要判断最后的<code>carry</code>是否为1</p><ul><li>若最后的<code>carry == 1</code>，则说明需要再向上进一位</li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        res = head = <span class="hljs-literal">None</span><br>        carry = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2:<br>            v1 = l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            v2 = l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-built_in">sum</span> = v1 + v2 + carry<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res:<br>                res = head = ListNode(<span class="hljs-built_in">sum</span> % <span class="hljs-number">10</span>)<br>            <span class="hljs-keyword">else</span>:<br>                head.<span class="hljs-built_in">next</span> = ListNode(<span class="hljs-built_in">sum</span> % <span class="hljs-number">10</span>)<br>                head = head.<span class="hljs-built_in">next</span><br>            carry = <span class="hljs-built_in">sum</span> // <span class="hljs-number">10</span><br>            <span class="hljs-keyword">if</span> l1:<br>                l1 = l1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> l2:<br>                l2 = l2.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">if</span> carry &gt; <span class="hljs-number">0</span>:<br>            head.<span class="hljs-built_in">next</span> = ListNode(carry)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, head = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> v1 + v2 + carry;<br>            <span class="hljs-keyword">if</span>(res == <span class="hljs-literal">null</span>) &#123;<br>                res = head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                head.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>                head = head.next;<br>            &#125;<br>            carry = sum / <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">null</span>) l1 = l1.next;<br>            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">null</span>) l2 = l2.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry &gt; <span class="hljs-number">0</span>) &#123;<br>            head.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第2篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1. Two Sum</title>
    <link href="/2022/10/03/LC-Solution-1-Two-Sum/"/>
    <url>/2022/10/03/LC-Solution-1-Two-Sum/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1.两数之和</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重lt复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p>进阶：你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h3><p>对数组进行遍历，用哈希表存放数组值及其对应的下标值。</p><ul><li><code>key</code> &#x3D;&gt; 元素值， <code>value</code> &#x3D;&gt; 元素值对应的下标值</li></ul><p>当发现<code>target - nums[i]</code> 即 <code>目标值与当前值之差</code> 是否在哈希表中出现过</p><ul><li><p>若出现过，则说明找到了目标值，直接返回即可</p></li><li><p>若未出现，继续遍历</p></li></ul><p>核心思路为<code>空间换时间</code>，若不采用哈希表，则双重for循环朴素解法时间复杂度为<code>O(n^2)</code></p><p>在循环遍历的过程中确定<code>nums[i]</code>为当前数，然后在哈希表中查找该数之前是否存在一个数为<code>target - nums[i]</code>。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], t: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        dic = defaultdict(<span class="hljs-built_in">int</span>)<br>        <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            x = t - v<br>            <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> dic:<br>                <span class="hljs-keyword">return</span> [dic[x], i]<br>            dic[v] = i<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> t) &#123;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(t - nums[i])) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;map.get(t - nums[i]), i&#125;;<br>            map.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第1篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
