<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>详解JDK锁01:Lock接口</title>
    <link href="/2022/10/12/%E8%AF%A6%E8%A7%A3JDK%E9%94%8101-Lock%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/10/12/%E8%AF%A6%E8%A7%A3JDK%E9%94%8101-Lock%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="详解JDK锁01：Lock接口"><a href="#详解JDK锁01：Lock接口" class="headerlink" title="详解JDK锁01：Lock接口"></a>详解JDK锁01：Lock接口</h1><h2 id="1-Lock简介"><a href="#1-Lock简介" class="headerlink" title="1. Lock简介"></a>1. Lock简介</h2><p>先引用Lock接口源码中作者贴的一段话</p><blockquote><p>Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more <code>flexible structuring</code>, may have quite <code>different properties</code>, and may support <code>multiple associated Condition objects</code>.</p></blockquote><p>其实这段话就简单概括了Lock的三大优点：</p><ol><li><p>灵活的结构：可以显式地获取与释放锁</p></li><li><p>多种不同的属性与方法</p></li><li><p>引入了 <code>Condition</code> 对象</p></li></ol><p>接下来的部分将着重介绍这几点</p><h2 id="2-Lock锁的灵活性"><a href="#2-Lock锁的灵活性" class="headerlink" title="2. Lock锁的灵活性"></a>2. Lock锁的灵活性</h2><h3 id="2-1-Lock接口方法"><a href="#2-1-Lock接口方法" class="headerlink" title="2.1 Lock接口方法"></a>2.1 Lock接口方法</h3><p>在 JDK5.0 之前，Java是借助于 <code>Synchronized</code> 关键字实现加锁功能，而这个功能是通过JVM实现的。而在 JDK5.0 之后，JUC包中新增了Lock接口实现锁功能。</p><p>虽然该Lock接口不具备 <code>Synchronized</code> 关键字隐式获取锁的便捷性，但是其提供了一系列手动操作锁的方法：</p><ol><li>阻塞式地获取锁</li></ol><p>  该方法有一定的缺陷：如果当前锁被占用，那么当前线程将被禁用，进入阻塞状态，直到获取到锁为止。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li>阻塞式地可打断地获取锁</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><p>  虽然是阻塞式地获取锁，但是如果该线程被中断后，会抛出异常，停止继续阻塞。</p><ol start="3"><li>非阻塞式地获取锁</li></ol><p>  尝试非阻塞地获取锁，调用该方法后立即返回</p><ul><li><p>若能够获取到锁，则返回 true</p></li><li><p>若锁已被占用，则返回 false</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>  该方法的典型使用场景为：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 伪代码</span><br><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ...;<br><span class="hljs-keyword">if</span> (lock.tryLock() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 操作共享资源</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 未获取到锁，执行其余操作</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>带有超时时间地获取锁</li></ol><p>  尝试在指定的一段时间内获取锁</p><ul><li><p>若在指定时间 <code>time</code> 内能够获取到锁，且未被中断，则返回 true</p></li><li><p>若指定时间 <code>time</code> 结束后仍未获取到锁，则返回 false</p></li><li><p>若在指定时间 <code>time</code> 内被打断，则抛出 <code>InterruptedException</code></p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><p>  其中 <code>time</code> 代表指定的超时时间，<code>unit</code> 代表时间单位</p><ol start="5"><li>释放锁</li></ol>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span>()</span>;<br></code></pre></td></tr></table></figure><h3 id="2-2-灵活性体现"><a href="#2-2-灵活性体现" class="headerlink" title="2.2 灵活性体现"></a>2.2 灵活性体现</h3><p>使用 <code>Synchronized</code> 关键字进行获取锁与释放锁操作时：</p><p>当嵌套式地获取锁之后，其释放锁的顺序必须与获取锁的顺序相反</p><p>如下获取锁顺序为：lock1 -&gt; lock2 -&gt; lock3</p><p>释放锁顺序为：lock3 -&gt; lock2 -&gt; lock1</p><p>从外到内获取锁，从内到外释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">lock3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>    System.out.println(<span class="hljs-string">&quot;获取到lock1锁&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>        System.out.println(<span class="hljs-string">&quot;获取到lock2锁&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (lock3) &#123;<br>            System.out.println(<span class="hljs-string">&quot;获取到lock3锁&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是我们假设存在这一业务需求：</p><p>先获取锁A，再获取锁B，再释放锁A，再获取锁C，再释放锁B，再获取锁D。</p><p>这种获取锁的顺序与释放锁的顺序是不固定的，此时无法用 <code>Synchronized</code> 解决。</p><p>而采用Lock接口实现锁则可以完美解决这一问题，因为它提供了手动的加锁解锁方法！</p><h2 id="3-Lock锁的多种功能"><a href="#3-Lock锁的多种功能" class="headerlink" title="3. Lock锁的多种功能"></a>3. Lock锁的多种功能</h2><p>Lock接口中虽然只提供了简单的获取锁与释放锁的基本方法，但是其实现类ReentrantLock中实现了多种方法，提供了不同的功能。</p><blockquote><p>这一篇文章只对Lock接口进行详细介绍，所以以下只做简单的文字介绍。</p><p>后续文章会通过源码解读 <code>ReentrantLock</code></p></blockquote><ol><li>实现公平锁与非公平锁。实例化ReentrantLock时，其有参构造方法中传入的值为boolean类型。若传入值为true，为公平锁；否则为非公平锁</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>判断锁是否已经被持有</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> sync.isLocked();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>判断锁是否为公平锁</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFair</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> sync <span class="hljs-keyword">instanceof</span> FairSync;  <br>&#125;<br></code></pre></td></tr></table></figure><p>相较于Lock接口，<code>Synchronized</code> 只实现了非公平锁。</p><h2 id="4-Condition基本使用"><a href="#4-Condition基本使用" class="headerlink" title="4. Condition基本使用"></a>4. Condition基本使用</h2><p>回顾 <code>Synchronized</code> 关键字，其实现 <code>等待/通知</code> 的模式是通过 <code>Object</code> 类内部的 <code>wait</code>、<code>notify</code> 以及 <code>notifyAll</code> 实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            lock.wait();  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);  <br>        &#125;  <br>        System.out.println(<span class="hljs-string">&quot;Thread1已被唤醒&quot;</span>);  <br>    &#125;  <br>&#125;);  <br>thread1.start();  <br>Thread.sleep(<span class="hljs-number">2000</span>);  <br><span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>    System.out.println(<span class="hljs-string">&quot;唤醒Thread1&quot;</span>);  <br>    lock.notify();  <br>    <span class="hljs-comment">// lock.notifyAll();  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>notify</code> 方法是唤醒 <code>lock</code> 锁上的其中一个线程，<code>notifyAll</code> 方法是唤醒 <code>lock</code> 锁上的全部线程。</p><p>然而，这两种方法均不能指定想要唤醒的线程。</p><p>Condition的出现很好地解决了这一问题，可以分组唤醒想要唤醒的线程。</p><p>如下为Condition的基本实现方式：需要使用 <code>ReentrantLock</code> 实现 <code>Lock</code> 接口</p><blockquote><p>后续文章会详细解读 <code>Condition</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br><span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();  <br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;Thread1进入等待&quot;</span>);  <br>            condition.await();  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);  <br>        &#125;  <br>        System.out.println(<span class="hljs-string">&quot;Thread1已被唤醒&quot;</span>);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;).start();  <br><br>Thread.sleep(<span class="hljs-number">3000</span>);  <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;唤醒Thread1&quot;</span>);  <br>        condition.signal();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;).start();<br></code></pre></td></tr></table></figure><h2 id="5-Lock与Synchronized-对比"><a href="#5-Lock与Synchronized-对比" class="headerlink" title="5. Lock与Synchronized 对比"></a>5. Lock与Synchronized 对比</h2><ol><li><p><code>Lock</code> 所处的层面是JDK，是人为通过Java代码而实现的；而 <code>Synchronized</code> 是Java的关键字，是底层C++语言实现，处于JVM层面。</p></li><li><p><code>Lock</code> 获取和释放锁的顺序不固定，因为其内置了手动操作锁的方法；而 <code>Synchronized</code> 必须按照获取锁的相反顺序去释放锁。</p></li><li><p><code>Lock</code> 可以非阻塞式地获取锁（ <code>tryLock</code> 方法）；而 <code>Synchronized</code> 只能通过阻塞式地获取锁，若当前锁已被其他线程获取，那么该线程只能阻塞等待。</p></li><li><p><code>Lock</code> 既可实现公平锁，也可实现非公平锁；而 <code>Synchronized</code>只能实现非公平锁。</p></li><li><p><code>lock</code> 等待锁过程中可以用 <code>lockInterruptibly</code> 来中断等待，而synchronized只能等待锁的释放，不能响应中断；</p></li></ol><h2 id="6-写在后面"><a href="#6-写在后面" class="headerlink" title="6. 写在后面"></a>6. 写在后面</h2><p>参考文献：</p><blockquote><ol><li><p>JDK5.0源码</p></li><li><p>《Java并发编程的艺术》</p></li><li><p><a href="https://www.bilibili.com/video/BV16J411h7Rd/?spm_id_from=333.337.search-card.all.click&vd_source=4e7654633e4719c03a8fb6c6b524ddc2">黑马Java并发编程教程</a></p></li></ol></blockquote><p>这个系列大概会有5篇左右的样子，我尽可能把自己对于JUC的理解通俗易懂地写出来</p><p>但如果有错误的地方，请大家指出来，我会及时去学习与改进~</p><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>锁</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1877. Minimize Maximum Pair Sum in Array</title>
    <link href="/2022/10/11/LC-Solution-1877-Minimize-Maximum-Pair-Sum-in-Array/"/>
    <url>/2022/10/11/LC-Solution-1877-Minimize-Maximum-Pair-Sum-in-Array/</url>
    
    <content type="html"><![CDATA[<h1 id="1877-数组中最大数对和的最小值"><a href="#1877-数组中最大数对和的最小值" class="headerlink" title="1877. 数组中最大数对和的最小值"></a><a href="https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array/">1877. 数组中最大数对和的最小值</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个数对 <code>(a,b)</code> 的 <strong>数对和</strong> 等于 <code>a + b</code> 。<strong>最大数对和</strong> 是一个数对数组中最大的 <strong>数对和</strong> 。</p><ul><li>比方说，如果我们有数对 <code>(1,5)</code> ，<code>(2,3)</code> 和 <code>(4,4)</code>，<strong>最大数对和</strong> 为 <code>max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8</code> 。</li></ul><p>给你一个长度为 <strong>偶数</strong> <code>n</code> 的数组 <code>nums</code> ，请你将 <code>nums</code> 中的元素分成 <code>n / 2</code> 个数对，使得：</p><ul><li><code>nums</code> 中每个元素 <strong>恰好</strong> 在 <strong>一个</strong> 数对中，且</li><li><strong>最大数对和</strong> 的值 <strong>最小</strong> 。</li></ul><p>请你在最优数对划分的方案下，返回最小的 <strong>最大数对和</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[3,5,2,3]</span><br>输出：<span class="hljs-number">7</span><br>解释：数组中的元素可以分为数对 (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>) 和 (<span class="hljs-number">5</span>,<span class="hljs-number">2</span>) 。<br>最大数对和为 <span class="hljs-built_in">max</span>(<span class="hljs-number">3</span>+<span class="hljs-number">3</span>, <span class="hljs-number">5</span>+<span class="hljs-number">2</span>) = <span class="hljs-built_in">max</span>(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>) = <span class="hljs-number">7</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[3,5,4,2,4,6]</span><br>输出：<span class="hljs-number">8</span><br>解释：数组中的元素可以分为数对 (<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)，(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>) 和 (<span class="hljs-number">6</span>,<span class="hljs-number">2</span>) 。<br>最大数对和为 <span class="hljs-built_in">max</span>(<span class="hljs-number">3</span>+<span class="hljs-number">5</span>, <span class="hljs-number">4</span>+<span class="hljs-number">4</span>, <span class="hljs-number">6</span>+<span class="hljs-number">2</span>) = <span class="hljs-built_in">max</span>(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>) = <span class="hljs-number">8</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>n</code> 是 <strong>偶数</strong> 。</li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：贪心-双指针"><a href="#方法一：贪心-双指针" class="headerlink" title="方法一：贪心 + 双指针"></a>方法一：贪心 + 双指针</h3><p>分析题意可知：题目给定了一个偶数长度的 <code>nums</code> 数组，将其两两分组组成数对，使得最终构成的数对数组中的最大数对和尽可能的小。</p><p>数对和意思是：一个数对中的两个数之和</p><p>为了使得最大的数对和尽可能地小，直观判断便是采用贪心思想，使得数组中的最小值与最大值组队，第二小值与第二大值组队 … 依次类推。最终得到的数对数组便可符合这一条件。</p><p>于是根据这一贪心思想，很容易想到算法实现方案 -&gt; 排序双指针，遍历数组</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPairSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        nums.sort()<br>        i, j = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; j:<br>            ans = <span class="hljs-built_in">max</span>(ans, nums[i] + nums[j])<br>            i, j = i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>采用推导式进一步简化代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPairSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        nums.sort()<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[i] + nums[<span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span> - i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)) <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(nums) // <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPairSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>            ans = Math.max(ans, nums[l] + nums[r]);<br>            l++;<br>            r--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第22篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1846. Maximum Element After Decreasing and Rearranging</title>
    <link href="/2022/10/11/LC-Solution-1846-Maximum-Element-After-Decreasing-and-Rearranging/"/>
    <url>/2022/10/11/LC-Solution-1846-Maximum-Element-After-Decreasing-and-Rearranging/</url>
    
    <content type="html"><![CDATA[<h1 id="1846-减小和重新排列数组后的最大元素"><a href="#1846-减小和重新排列数组后的最大元素" class="headerlink" title="1846. 减小和重新排列数组后的最大元素"></a><a href="https://leetcode.cn/problems/maximum-element-after-decreasing-and-rearranging/">1846. 减小和重新排列数组后的最大元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数数组 <code>arr</code> 。请你对 <code>arr</code> 执行一些操作（也可以不进行任何操作），使得数组满足以下条件：</p><ul><li><p><code>arr</code> 中 <strong>第一个</strong> 元素必须为 <code>1</code></p></li><li><p>任意相邻两个元素的差的绝对值 <strong>小于等于</strong> <code>1</code> ，也就是说，对于任意的 <code>1 &lt;= i &lt; arr.length</code> （<strong>数组下标从 0 开始</strong>），都满足 <code>abs(arr[i] - arr[i - 1]) &lt;= 1</code> 。<code>abs(x)</code> 为 <code>x</code> 的绝对值。</p></li></ul><p>你可以执行以下 2 种操作任意次：</p><ul><li><strong>减小</strong> <code>arr</code> 中任意元素的值，使其变为一个 <strong>更小的正整数</strong> 。</li><li><strong>重新排列</strong> <code>arr</code> 中的元素，你可以以任意顺序重新排列。</li></ul><p>请你返回执行以上操作后，在满足前文所述的条件下，<code>arr</code> 中可能的 <strong>最大值</strong> 。</p><p><strong>示例1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[2,2,1,2,1]</span><br>输出：<span class="hljs-number">2</span><br>解释：<br>我们可以重新排列 arr 得到 <span class="hljs-string">[1,2,2,2,1]</span> ，该数组满足所有条件。<br>arr 中最大元素为 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">输入：arr = [100,1,1000]<br>输出：3<br>解释：<br>一个可行的方案如下：<br><span class="hljs-bullet">1.</span> 重新排列 arr 得到 [1,100,1000] 。<br><span class="hljs-bullet">2.</span> 将第二个元素减小为 2 。<br><span class="hljs-bullet">3.</span> 将第三个元素减小为 3 。<br>现在 arr = [1,2,3] ，满足所有条件。<br>arr 中最大元素为 3 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-number">5</span><br>解释：数组已经满足所有条件，最大元素为 <span class="hljs-number">5</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 105</code></li><li><code>1 &lt;= arr[i] &lt;= 109</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：贪心"><a href="#方法一：贪心" class="headerlink" title="方法一：贪心"></a>方法一：贪心</h3><p>分析题意：题目要求通过 <code>减法运算</code> 或 <code>重排序</code> 两种方法，使得数组的两两元素之差的绝对值小于等于1（<code>abs(arr[i] - arr[i - 1]) &lt;= 1</code>），且 <code>arr[0] = 1</code></p><p>于是很容易想到用贪心思想解决本题</p><ol><li><p>允许重排序且题目最终要求返回数组最大值：最终返回结果与数组顺序无关，所以我们可以直接对数组 <code>arr</code> 进行排序。</p></li><li><p><code>arr[0] = 1</code>：从此可以确定对 <code>arr</code> 进行升序排序</p></li><li><p>可以做减法运算：从此条件可以进一步简化题目。既然我们之前已经确定了采用升序排序，那么可以得知此条件始终成立 <code>arr[i] &gt;= arr[i - 1]</code>。</p></li></ol><p>  所以我们遍历 <code>arr</code> 数组时：</p><ol><li><p>无需计算元素之差的绝对值</p></li><li><p>当不满足元素之差小于等于1的条件（ <code>arr[i] &gt; arr[i] + 1</code> ）时，只需 <code>arr[i] = arr[i -1] + 1</code>，使较大的值等于较小的值加1，相当于对较大的值做减法运算</p></li></ol><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumElementAfterDecrementingAndRearranging</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        arr.sort()<br>        arr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(arr)):<br>            <span class="hljs-keyword">if</span> arr[i] - arr[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span>:<br>                arr[i] = arr[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> arr[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumElementAfterDecrementingAndRearranging</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        Arrays.sort(arr);<br>        arr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[i] - arr[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span>) &#123;<br>               arr[i] = arr[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[arr.length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第21篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1833. Maximum Ice Cream Bars</title>
    <link href="/2022/10/11/LC-Solution-1833-Maximum-Ice-Cream-Bars/"/>
    <url>/2022/10/11/LC-Solution-1833-Maximum-Ice-Cream-Bars/</url>
    
    <content type="html"><![CDATA[<h1 id="1833-雪糕的最大数量"><a href="#1833-雪糕的最大数量" class="headerlink" title="1833. 雪糕的最大数量"></a><a href="https://leetcode.cn/problems/maximum-ice-cream-bars/">1833. 雪糕的最大数量</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。</p><p>商店中新到 <code>n</code> 支雪糕，用长度为 <code>n</code> 的数组 <code>costs</code> 表示雪糕的定价，其中 <code>costs[i]</code> 表示第 <code>i</code> 支雪糕的现金价格。Tony 一共有 <code>coins</code> 现金可以用于消费，他想要买尽可能多的雪糕。</p><p>给你价格数组 <code>costs</code> 和现金量 <code>coins</code> ，请你计算并返回 Tony 用 <code>coins</code> 现金能够买到的雪糕的 <strong>最大数量</strong> 。</p><p><strong>注意：</strong> Tony 可以按任意顺序购买雪糕。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：costs = [1,3,2,4,1], coins = 7<br>输出：4<br>解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>= 7<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：costs = <span class="hljs-string">[10,6,8,7,7,8]</span>, coins = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">0</span><br>解释：Tony 没有足够的钱买任何一支雪糕。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：costs = [1,6,3,1,2,5], coins = 20<br>输出：6<br>解释：Tony 可以买下所有的雪糕，总价为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 18 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>costs.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= costs[i] &lt;= 105</code></li><li><code>1 &lt;= coins &lt;= 108</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：贪心"><a href="#方法一：贪心" class="headerlink" title="方法一：贪心"></a>方法一：贪心</h3><p>用有限的钱，买到最多的雪糕。</p><p>从此很容易可以想到，对于价格便宜的雪糕，购买优先级高。</p><p>因此，对雪糕的价格数组 <code>costs</code> 进行排序。</p><p>每个雪糕只能买一次，因此遍历 <code>costs</code> 数组，用 <code>cnt</code> 计数买到雪糕的数量。</p><p>当将 <code>coins</code> 花完的时候，便可以得到可以购买的最大数量。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxIceCream</span>(<span class="hljs-params">self, costs: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], coins: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        costs.sort()<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> costs:<br>            <span class="hljs-keyword">if</span> coins - c &gt;= <span class="hljs-number">0</span>:<br>                coins -= c<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxIceCream</span><span class="hljs-params">(<span class="hljs-type">int</span>[] costs, <span class="hljs-type">int</span> coins)</span> &#123;<br>        Arrays.sort(costs);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c : costs) &#123;<br>            <span class="hljs-keyword">if</span>(coins - c &gt;= <span class="hljs-number">0</span>) &#123;<br>                coins -= c;<br>                cnt++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第20篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1790. Check if One String Swap Can Make Strings Equal</title>
    <link href="/2022/10/11/LC-Solution-1790-Check-if-One-String-Swap-Can-Make-Strings-Equal/"/>
    <url>/2022/10/11/LC-Solution-1790-Check-if-One-String-Swap-Can-Make-Strings-Equal/</url>
    
    <content type="html"><![CDATA[<h1 id="1790-仅执行一次字符串交换能否使两个字符串相等"><a href="#1790-仅执行一次字符串交换能否使两个字符串相等" class="headerlink" title="1790. 仅执行一次字符串交换能否使两个字符串相等"></a><a href="https://leetcode.cn/problems/check-if-one-string-swap-can-make-strings-equal/">1790. 仅执行一次字符串交换能否使两个字符串相等</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你长度相等的两个字符串 <code>s1</code> 和 <code>s2</code> 。一次 <strong>字符串交换</strong> 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。</p><p>如果对 <strong>其中一个字符串</strong> 执行 <strong>最多一次字符串交换</strong> 就可以使两个字符串相等，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;bank&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;kanb&quot;</span><br>输出：true<br>解释：例如，交换 <span class="hljs-built_in">s2</span> 中的第一个和最后一个字符可以得到 <span class="hljs-string">&quot;bank&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;attack&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;defend&quot;</span><br>输出：false<br>解释：一次字符串交换无法使两个字符串相等<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;kelb&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;kelb&quot;</span><br>输出：true<br>解释：两个字符串已经相等，所以不需要进行字符串交换<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;dcba&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li><code>1 &lt;= s1.length, s2.length &lt;= 100</code></li><li><code>s1.length == s2.length</code></li><li><code>s1</code> 和 <code>s2</code> 仅由小写英文字母组成</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：哈希表-计数"><a href="#方法一：哈希表-计数" class="headerlink" title="方法一：哈希表 + 计数"></a>方法一：哈希表 + 计数</h3><p>思路：</p><ul><li><p>先用哈希表统计字符串 <code>s1</code> 与 <code>s2</code> 的词频，只有词频相同的情况下，才可能满足题目要求的交换一次便得到相同字符串。</p></li><li><p>计数：遍历，对两个字符串逐个判断，得到不同字符数量 <code>cnt</code> 。</p><ul><li>若 <code>s1[i] != s2[i]</code>，<code>cnt += 1</code></li></ul></li><li><p>最终，当 <code>cnt == 0</code> 或 <code>cnt == 2</code>，分别对应着交换次数为0和交换次数为1的情况。（前提是两字符串词频相同）</p></li></ul><p>该方法缺点在于空间复杂度为O(n)</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">areAlmostEqual</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        dic1, dic2 = Counter(s1), Counter(s2)<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s1)):<br>            <span class="hljs-keyword">if</span> s1[i] != s2[i]:<br>                cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> (cnt == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt == <span class="hljs-number">2</span>) <span class="hljs-keyword">and</span> dic1 == dic2<br></code></pre></td></tr></table></figure><h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">areAlmostEqual</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray();<br>        Map&lt;Character, Integer&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(), map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs1.length; i++) &#123;<br>            map1.put(cs1[i], map1.getOrDefault(cs1[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            map2.put(cs2[i], map2.getOrDefault(cs2[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(cs1[i] != cs2[i]) cnt++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (cnt == <span class="hljs-number">0</span> || cnt == <span class="hljs-number">2</span>) &amp;&amp; map1.equals(map2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：纯计数"><a href="#方法二：纯计数" class="headerlink" title="方法二：纯计数"></a>方法二：纯计数</h3><p>思路：</p><p>仍然是同时遍历两字符串 <code>s1</code> 与 <code>s2</code>，用 <code>cnt</code> 统计相同下标不同字符的数量。</p><p>但不采用哈希表统计词频，而是用两个变量 <code>c1</code> 与 <code>c2</code> 记录上一次相同下标的情况下 <code>s1</code> 与 <code>s2</code> 不相同的字符。</p><p>若 <code>cnt == 2</code>时，当前 <code>s1[i] != c2</code> 或 <code>s2[i] != c1</code>，此时可能出现如下情况</p><ul><li><p><code>bank</code> 与 <code>canb</code>，隐含的意思就是两字符串词频不同，只不过这个方法咱们没有用哈希表进行统计。</p><p>因为题目中说只可交换一次，所以只需判断 <code>cnt == 2</code> 这种情况下词频是否相同。</p></li></ul><p>最终遍历完成之后，还需要判断 cnt 是否等于 1，防止出现如下情况</p><ul><li><code>bank</code> 与 <code>cank</code>，只有一个下标的字符不相同，隐含意思是词频不相同，无法交换。</li></ul><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">areAlmostEqual</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        cnt = <span class="hljs-number">0</span><br>        c1, c2 = <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s1)):<br>            <span class="hljs-keyword">if</span> s1[i] != s2[i]:<br>                cnt += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> cnt &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> (cnt == <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> (s1[i] != c2 <span class="hljs-keyword">or</span> s2[i] != c1)):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                c1, c2 = s1[i], s2[i]<br>        <span class="hljs-keyword">return</span> cnt != <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">areAlmostEqual</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, c2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs1.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(cs1[i] != cs2[i]) &#123;<br>                <span class="hljs-keyword">if</span>(++cnt &gt; <span class="hljs-number">2</span> || (cnt == <span class="hljs-number">2</span> &amp;&amp; (cs1[i] != c2 || cs2[i] != c1))) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                c1 = cs1[i];<br>                c2 = cs2[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt != <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第19篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1249. Minimum Remove to Make Valid Parentheses</title>
    <link href="/2022/10/09/LC-Solution-1249-Minimum-Remove-to-Make-Valid-Parentheses/"/>
    <url>/2022/10/09/LC-Solution-1249-Minimum-Remove-to-Make-Valid-Parentheses/</url>
    
    <content type="html"><![CDATA[<h1 id="1249-移除无效的括号"><a href="#1249-移除无效的括号" class="headerlink" title="1249. 移除无效的括号"></a><a href="https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/">1249. 移除无效的括号</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个由 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 和小写字母组成的字符串 <code>s</code>。</p><p>你需要从字符串中删除最少数目的 <code>&#39;(&#39;</code> 或者 <code>&#39;)&#39;</code> （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p><p>请返回任意一个合法字符串。</p><p>有效「括号字符串」应当符合以下 <strong>任意一条</strong> 要求：</p><ul><li>空字符串或只包含小写字母的字符串</li><li>可以被写作 <code>AB</code>（<code>A</code> 连接 <code>B</code>）的字符串，其中 <code>A</code> 和 <code>B</code> 都是有效「括号字符串」</li><li>可以被写作 <code>(A)</code> 的字符串，其中 <code>A</code> 是一个有效的「括号字符串」</li></ul><p><strong>示例1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;lee(t(c)o)de)&quot;</span><br>输出：<span class="hljs-string">&quot;lee(t(c)o)de&quot;</span><br>解释：<span class="hljs-string">&quot;lee(t(co)de)&quot;</span> , <span class="hljs-string">&quot;lee(t(c)ode)&quot;</span> 也是一个可行答案。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a)b(c)d&quot;</span><br>输出：<span class="hljs-string">&quot;ab(c)d&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;))((&quot;</span><br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：空字符串也是有效的<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 可能是 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 或英文小写字母</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：栈"><a href="#方法一：栈" class="headerlink" title="方法一：栈"></a>方法一：栈</h3><p>一看到合法括号题，第一反应首先想到用栈解决。</p><p>题目要求删掉字符串 <code>s</code> 中的无效括号，使得剩余的所有括号构成有效括号，要求删除次数尽可能的少。</p><p>简单直接地理解题目：对 <code>s</code> 做减法，删除左右括号中数量较多的一方以达成有效括号</p><p>但是应思考如何尽可能地优雅且简单地从字符串中删除对应的字符</p><p>如果直接对字符串动手脚，下标会产生变化。</p><p><strong>思路转化：</strong></p><p>选择将字符串 <code>s</code> 转为数组，将需要删除的括号置为空即代表删除。</p><p>栈用于存储 <code>&#39;(&#39;</code> 的下标，便于通过下标对字符串数组进行操作。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minRemoveToMakeValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        stack, s = [], <span class="hljs-built_in">list</span>(s)<br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                stack.append(i)<br>            <span class="hljs-keyword">elif</span> x == <span class="hljs-string">&#x27;)&#x27;</span>:<br>                <span class="hljs-keyword">if</span> stack:<br>                    stack.pop()<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 此时没有&#x27;(&#x27;与&#x27;)&#x27;配对，删除</span><br>                    s[i] = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-comment"># 栈中剩余的均为&#x27;(&#x27;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> stack:<br>            <span class="hljs-comment"># 此时没有&#x27;)&#x27;与&#x27;(&#x27;配对，删除</span><br>            s[i] = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(s)<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>Java无法直接对字符赋空值，先填一个占位字符，之后利用replace方法将其替换为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minRemoveToMakeValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(cs[i] == <span class="hljs-string">&#x27;(&#x27;</span>) stack.addLast(i);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cs[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span>(!stack.isEmpty()) stack.pollLast();<br>                <span class="hljs-keyword">else</span> cs[i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : stack) cs[i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(cs).replace(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第18篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 678. Valid Parenthesis String</title>
    <link href="/2022/10/09/LC-Solution-678-Valid-Parenthesis-String/"/>
    <url>/2022/10/09/LC-Solution-678-Valid-Parenthesis-String/</url>
    
    <content type="html"><![CDATA[<h1 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a href="https://leetcode.cn/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包含三种字符的字符串：<code>（</code> ，<code>）</code> 和 <code>*</code>，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p><ol><li>任何左括号 <code>(</code> 必须有相应的右括号 <code>)</code>。</li><li>任何右括号 <code>)</code> 必须有相应的左括号 <code>(</code> 。</li><li>左括号 <code>(</code> 必须在对应的右括号之前 <code>)</code>。</li><li><code>*</code> 可以被视为单个右括号 <code>)</code> ，或单个左括号 <code>(</code> ，或一个空字符串。</li><li>一个空字符串也被视为有效字符串。</li></ol><p><strong>示例1：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;()&quot;</span><br>输出: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;(*)&quot;</span><br>输出: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;(*))&quot;</span><br>输出: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>字符串大小将在 [1，100] 范围内。</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：双栈"><a href="#方法一：双栈" class="headerlink" title="方法一：双栈"></a>方法一：双栈</h3><p>遇到括号题，第一反应便是栈。因为栈的先进后出的特性与括号之间嵌套的特性相一致。</p><p>栈内总是存储左括号 <code>&#39;(&#39;</code>，通过右括号 <code>&#39;)&#39;</code> 与左括号 <code>&#39;(&#39;</code> 配对，使左括号出栈。</p><p>本题思路：</p><p><code>&#39;*&#39;</code> 可以表示三种字符：<code>&#39;&#39;</code> 、 <code>&#39;(&#39;</code> 、<code>&#39;)&#39;</code>，优先将 <code>&#39;*&#39;</code> 当作左括号使用。</p><p>因此使用两个栈分别存储 <code>&#39;*&#39;</code> 与 <code>&#39;(&#39;</code> 对应于 <code>s</code> 的下标。</p><ul><li><p>存储下标的意义在于：由于我们是优先将 <code>&#39;*&#39;</code> 当作左括号使用，当右括号 <code>&#39;)&#39;</code> 全部消耗完。这时候多余的 <code>&#39;*&#39;</code> 将要作为右括号 <code>&#39;)&#39;</code> 与剩余的 <code>&#39;(&#39;</code> 进行配对。右括号必须在左括号之后。因此存储下标可以帮助我们判断 <code>&#39;*&#39;</code> 与 <code>&#39;(&#39;</code> 的先后顺序是否符合合法括号的要求。</p><p><code>&#39;(&#39;</code> 使用优先级 <strong>大于</strong> <code>&#39;*&#39;</code></p></li></ul><ol><li>遍历字符串 <code>s</code> ：</li></ol><p>  . 若 <code>s[i] == &#39;(&#39;</code>， 将其添加到 <code>&#39;(&#39;</code> 栈中</p><p>  . 若 <code>s[i] == &#39;*&#39;</code>， 将其添加到 <code>&#39;*&#39;</code> 栈中</p><p>  . 若 <code>s[i] == &#39;*&#39;</code>：</p><p>  . <code>&#39;(&#39;</code> 栈 或 <code>&#39;*&#39;</code> 栈不为空时，优先使用 <code>&#39;(&#39;</code> 栈进行出栈</p><p>  . 否则，没有字符与 <code>&#39;(&#39;</code> 进行配对，返回 <code>False</code></p><ol start="2"><li>遍历 <code>&#39;(&#39;</code> 与 <code>&#39;*&#39;</code> 栈，将 <code>&#39;*&#39;</code> 当作 <code>&#39;)&#39;</code> 与 剩余 <code>&#39;(&#39;</code> 进行匹配</li></ol><p>  . 若弹出的 <code>&#39;*&#39;</code> 下标 <strong>小于</strong> 弹出的 <code>&#39;(&#39;</code>， 返回False</p><ol start="3"><li>最终判断是否仍然有剩余的 <code>&#39;(&#39;</code></li></ol><p>  . 若仍然有，返回False；否则，返回True</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkValidString</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        stack1, stack2 = [], []<br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                stack1.append(i)<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                stack2.append(i)<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;)&#x27;</span>:<br>                <span class="hljs-keyword">if</span> stack1:<br>                    stack1.pop()<br>                <span class="hljs-keyword">elif</span> stack2:<br>                    stack2.pop()<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">while</span> stack1 <span class="hljs-keyword">and</span> stack2:<br>            idx1, idx2 = stack1.pop(), stack2.pop()<br>            <span class="hljs-keyword">if</span> idx1 &gt; idx2:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> stack1<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkValidString</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        Deque&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(cs[i] == <span class="hljs-string">&#x27;(&#x27;</span>) stack1.addLast(i);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cs[i] == <span class="hljs-string">&#x27;*&#x27;</span>) stack2.addLast(i);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(!stack1.isEmpty()) stack1.pollLast();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!stack2.isEmpty()) stack2.pollLast();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!stack1.isEmpty() &amp;&amp; !stack2.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx1</span> <span class="hljs-operator">=</span> stack1.pollLast(), idx2 = stack2.pollLast();<br>            <span class="hljs-keyword">if</span>(idx1 &gt; idx2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack1.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第17篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 856. Score of Parentheses</title>
    <link href="/2022/10/09/LC-Solution-856-Score-of-Parentheses/"/>
    <url>/2022/10/09/LC-Solution-856-Score-of-Parentheses/</url>
    
    <content type="html"><![CDATA[<h1 id="856-Score-of-Parentheses"><a href="#856-Score-of-Parentheses" class="headerlink" title="856. Score of Parentheses"></a><a href="https://leetcode.cn/problems/score-of-parentheses/">856. Score of Parentheses</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个平衡括号字符串 <code>S</code>，按下述规则计算该字符串的分数：</p><ul><li><code>()</code> 得 1 分。</li><li><code>AB</code> 得 <code>A + B</code> 分，其中 A 和 B 是平衡括号字符串。</li><li><code>(A)</code> 得 <code>2 * A</code> 分，其中 A 是平衡括号字符串。</li></ul><p><strong>示例1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入： <span class="hljs-string">&quot;()&quot;</span><br>输出： <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入： <span class="hljs-string">&quot;(())&quot;</span><br>输出： <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">输入： &quot;()()&quot;<br>输出： <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">输入： &quot;(()(()))&quot;<br>输出： <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>S</code> 是平衡括号字符串，且只含有 <code>(</code> 和 <code>)</code> 。</li><li><code>2 &lt;= S.length &lt;= 50</code></li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：根据-计数"><a href="#方法一：根据-计数" class="headerlink" title="方法一：根据()计数"></a>方法一：根据()计数</h3><p>分析题意可知，外层括号所累加的分数都与最里括号 <code>&#39;()&#39;</code> 有关。</p><ul><li><p>假设当前括号深度为 <code>d</code>，每一个 <code>&#39;()&#39;</code> 的得分为 <code>2 ** d</code> 或者 <code>1 &lt;&lt; d</code></p></li><li><p>最后的总分数与 <code>&#39;()&#39;</code> 的数量有关。</p></li></ul><p>举例说明：<code>&#39;(()(()))&#39;</code>，利用乘法分配律可表示为 <code>&#39;(()) + ((()))&#39;</code></p><p>共有两个 <code>&#39;()&#39;</code>，其分数为 <code>2 ** 1 + 2 ** 2 = 6</code></p><p>所以，我们只需要找到 <code>s</code> 中的每一个 <code>&#39;()&#39;</code> 即可</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">scoreOfParentheses</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans, d = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            d += <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> v == <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> v == <span class="hljs-string">&#x27;)&#x27;</span> <span class="hljs-keyword">and</span> s[i - <span class="hljs-number">1</span>] ==<span class="hljs-string">&#x27;(&#x27;</span>:<br>                ans += <span class="hljs-number">1</span> &lt;&lt; d<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">scoreOfParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, d = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            d += s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                ans += <span class="hljs-number">1</span> &lt;&lt; d;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：栈"><a href="#方法二：栈" class="headerlink" title="方法二：栈"></a>方法二：栈</h3><p>采用栈记录字符串 <code>s</code> 对应的分数。初始栈顶部的分数为0。</p><p>遍历字符串：</p><ol><li><p>若 <code>s[i] == &#39;(&#39;</code>，先将分数0压入栈顶占位</p></li><li><p>若 <code>s[i] == &#39;)&#39;</code>，此时有两种情况：</p></li></ol><ul><li><p><code>s[i - 1] == &#39;(&#39;</code>，这是一个 <code>&#39;()&#39;</code>， 此时栈顶值 <code>v</code> 为0，该分数为1</p></li><li><p><code>s[i - 1] != &#39;(&#39;</code>，这是一个外层括号，该分数为栈顶值 <code>v</code> × 2</p></li></ul><p>  两种情况综合为 <code>max(v * 2, 1)</code></p><p>  将栈顶值出栈计算完成之后，再将计算结果累加到当前的栈顶值。</p><p>最终返回结果为栈顶值。</p><p>这是因为一开始还未遍历字符串 <code>s</code> 时，就已经初始化了栈顶值。而且该字符串 <code>s</code> 为平衡括号字符串，说明 <code>&#39;(&#39; </code>与 <code>&#39;)&#39;</code> 数量一致，所以最后栈中一个值，即为最终分数。</p><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">scoreOfParentheses</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        stack = [<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                stack.append(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">else</span>:<br>                v = stack.pop()<br>                stack[-<span class="hljs-number">1</span>] += <span class="hljs-built_in">max</span>(v * <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> stack[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">scoreOfParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        stack.addLast(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span>) stack.addLast(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> stack.pollLast();<br>                stack.addLast(stack.pollLast() + Math.max(v * <span class="hljs-number">2</span>, <span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.pollLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第16篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式锁学习笔记</title>
    <link href="/2022/10/09/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/09/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式锁学习笔记"><a href="#分布式锁学习笔记" class="headerlink" title="分布式锁学习笔记"></a>分布式锁学习笔记</h1><p>持续更新中，预计10月下旬更完~</p><p>该笔记中除了视频中核心的笔记、代码，还额外补充了视频中老师讲解过的但官方笔记中没有提到的重要内容。</p><p>有错误或者遗漏的地方请大家提出来呀，有不懂的地方留言我尽量回答（毕竟我也很菜~</p><h2 id="1-传统锁-减库存案例"><a href="#1-传统锁-减库存案例" class="headerlink" title="1. 传统锁 - 减库存案例"></a>1. 传统锁 - 减库存案例</h2><p><img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/stock.png"></p><p>多线程同时操纵同一个服务的共享资源，必然会造成线程安全问题。</p><p>解决方案：采用JVM提供的 <code>Reentrantlock</code> 或者 <code>Synchronized</code> 锁</p><h3 id="1-1-初始化工程"><a href="#1-1-初始化工程" class="headerlink" title="1.1 初始化工程"></a>1.1 初始化工程</h3><p>这一部分跟着视频完成，以下内容省略了未连接数据库之前的部分（个人认为之前未连接数据库的部分仅演示了并发流程，与实际业务关联性不大，也较为容易，可自行实现）。</p><ol><li><p>创建SpringBoot工程，选择 <code>JDK8</code> 版本，引入 <code>Spring Web</code></p></li><li><p>在 <code>pom.xml</code>引入如下依赖</p></li></ol>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>创建数据库 <code>distributed_lock</code>，在数据库内创建表 <code>db_stock</code>，创建如下字段。</li></ol><p>  <img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/20221008221626.png"></p><p>  新建一条数据记录</p><p>  <img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/20221008221728.png"></p><ol start="4"><li>修改application.properties文件，规定Web启动端口号</li></ol>  <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">10010</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/distributed_lock</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">your password</span><br></code></pre></td></tr></table></figure><ol start="5"><li>在目录下创建 <code>pojo</code> 包，用于存放实体类 <code>Stock</code> 对象</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;db_stock&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span> &#123;<br><br><span class="hljs-keyword">private</span> Long id;<br><span class="hljs-keyword">private</span> String productCode;<br><span class="hljs-keyword">private</span> String warehouse;<br><span class="hljs-keyword">private</span> Integer count;<br>&#125;<br></code></pre></td></tr></table></figure><p>  创建 <code>mapper</code> 包，创建 <code>StockMapper</code> 类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StockMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Stock&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>  更改 <code>SpringBoot</code> 启动类，添加如下注解</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.ltyzzz.distributedlock.mapper&quot;)</span><br></code></pre></td></tr></table></figure><p>  创建 <code>service</code> 包，创建 <code>StockService</code> 类</p><p>  try-finally块之后用于加锁</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockService</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StockMapper stockMapper;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stockMapper.selectOne(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;product_code&quot;</span>, <span class="hljs-string">&quot;1001&quot;</span>));<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>            stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">this</span>.stockMapper.updateById(stock);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  创建 <code>controller</code> 包，创建 <code>StockController</code> 类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    StockService stockService;<br><br>    <span class="hljs-meta">@GetMapping(&quot;stock/deduct&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>        stockService.deduct();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello stock deduct!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-JVM本地锁"><a href="#1-2-JVM本地锁" class="headerlink" title="1.2 JVM本地锁"></a>1.2 JVM本地锁</h3><h4 id="1-2-1-使用JMeter进行并发测试"><a href="#1-2-1-使用JMeter进行并发测试" class="headerlink" title="1.2.1 使用JMeter进行并发测试"></a>1.2.1 使用JMeter进行并发测试</h4><p>首先启动 SpringBoot 库存项目</p><p>利用 <code>JMeter</code> 进行压力测试</p><ol><li>创建 <code>Thread Group</code></li></ol><p>  <img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/thread-group.png"></p><ol start="2"><li>设置 <code>Thread Properties</code></li></ol><p>  <img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/thread-proper.png"></p><ol start="3"><li>设置 <code>request</code></li></ol><p>  <img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/reque.png"></p><p>  <img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/20221008224501.png"></p><ol start="4"><li>添加 <code>Aggregate Report</code></li></ol><p>  <img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/20221008224122.png"></p><ol start="5"><li>运行压力测试，正常执行情况最终库存应该为0</li></ol><p>最终数据库结果如下</p><p><img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/data%20stcok.png"></p><p>此时产生了并发操作</p><p>有两种极限情况</p><ul><li><p>所有并发请求都完美的交错执行，正确地完成了数据库更新，最终库存为0</p></li><li><p>所有并发请求同一时间并发，同时执行了数据库更新操作，并发线程数为100，循环次数为50，最终库存为4950</p></li></ul><h4 id="1-2-2-加入JVM本地锁解决并发问题"><a href="#1-2-2-加入JVM本地锁解决并发问题" class="headerlink" title="1.2.2 加入JVM本地锁解决并发问题"></a>1.2.2 加入JVM本地锁解决并发问题</h4><p>修改 <code>StockService</code>。使用 <code>ReentrantLock</code> 或 <code>Synchronized</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StockMapper stockMapper;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stockMapper.selectOne(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;product_code&quot;</span>, <span class="hljs-string">&quot;1001&quot;</span>));<br>            <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>                stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">this</span>.stockMapper.updateById(stock);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动 <code>SpringBoot</code> 工程，继续进行压力测试，最终库存为0。</p><h4 id="1-2-3-JVM本地锁失效的情况"><a href="#1-2-3-JVM本地锁失效的情况" class="headerlink" title="1.2.3 JVM本地锁失效的情况"></a>1.2.3 JVM本地锁失效的情况</h4><p>共有三种情况</p><h5 id="多例模式"><a href="#多例模式" class="headerlink" title="多例模式"></a>多例模式</h5><p>修改 <code>StockService</code>，设置多例模式</p><p>添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scope(value = &quot;prototype&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br></code></pre></td></tr></table></figure><p>JDK动态代理使用 <code>INTERFACES</code>，CGLIB代理使用 <code>TARGET_CLASS</code></p><p>默认情况下使用JDK动态代理，原生Spring默认是JDK动态代理</p><p>而SpringBoot在2.0版本之后默认使用CGLIB代理</p><p>启动 <code>SpringBoot</code> 工程，继续进行压力测试，最终库存不为0，说明本地锁失效</p><h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>在 <code>service</code> 方法上添加事务注解 <code>@Transactional</code></p><p>启动 <code>SpringBoot</code> 工程，继续进行压力测试，最终库存不为0，说明本地锁失效</p><p>事务采用AOP思想实现：</p><ol><li><p>在AOP的前置方法内开启事务</p></li><li><p>进入service方法，获取锁</p></li><li><p>进行查询库存、更新库存操作</p></li><li><p>释放锁</p></li><li><p>在AOP的后置方法内提交或回滚事务</p></li></ol><p>在并发情况下，如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/tab.png"></p><p>b用户在a用户还未提交事务之前，就获取到了a用户释放的锁，读取到了库存，但该库存为旧的库存（因为a用户还未提交事务），所以b用户是在旧库存的基础上进行修改，因此产生了并发问题。</p><p>解决方案：设置事务隔离级别</p><p>将注解改为：<code>@Transactional(isolation = Isolation.READ_UNCOMMITTED)</code></p><p>即此时b用户可以读取到a用户未提交的数据，即该数据为最新数据，可以解决此问题。</p><p>但实际业务中不能这样去使用，采用事务就是为了保证原子性，要么全部成功，要么全部失败。假设b用户在这种方式下读取到了最新数据，虽然可以解决超卖问题，但是如果a回滚了事务，那么b用户读取到的数据就是错误的，又会产生新的混乱。</p><h5 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h5><p>多个服务器部署</p><p>去掉 <code>@Transactional</code> 注解，保证在单机模式下锁生效，无并发问题。</p><p>这部分看视频做</p><ol><li><p>设置两个SpringBoot启动类，设置不同的端口号，并启动</p></li><li><p>更改 <code>nginx</code> 配置文件</p></li></ol>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> distributedLock &#123;<br>    <span class="hljs-attribute">server</span> localhost:<span class="hljs-number">10086</span>;<br>    <span class="hljs-attribute">server</span> localhost:<span class="hljs-number">10010</span>;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://distributedLock;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>启动nginx</li></ol><p>任务管理器中出现两个nginx即代表启动成功，一个工作进程，一个主进程</p><p>以默认端口80进行访问：<code>localhost:80/stock/deduct</code></p><p>之后，使用JMeter进行压力测试，5000个请求成功发出，但最终库存不为0，锁失效。</p><h3 id="1-3-单SQL语句解决并发问题"><a href="#1-3-单SQL语句解决并发问题" class="headerlink" title="1.3 单SQL语句解决并发问题"></a>1.3 单SQL语句解决并发问题</h3><h4 id="1-3-1-实现过程"><a href="#1-3-1-实现过程" class="headerlink" title="1.3.1 实现过程"></a>1.3.1 实现过程</h4><p>原 <code>Service</code> 代码流程</p><ol><li><p>查询库存</p></li><li><p>判断库存是否充足</p></li><li><p>更新库存到数据库</p></li></ol><p>该流程可以使用一个SQL语句实现</p><p>为 <code>StockMapper</code> 添加方法 updateStock，</p><p>参数为商品编号 <code>productCode</code> 与减库存数量<code>count</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StockMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Stock&gt; &#123;<br>    <span class="hljs-meta">@Update(&quot;update db_stock set count = count - #&#123;count&#125; where product_code = #&#123;productCode&#125; and count &gt;= #&#123;count&#125;&quot;)</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateStock</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;productCode&quot;)</span> String productCode, <span class="hljs-meta">@Param(&quot;count&quot;)</span> Integer count)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>SQL语句如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">update</span> db_stock <span class="hljs-keyword">set</span> <span class="hljs-built_in">count</span> = <span class="hljs-built_in">count</span> - #&#123;<span class="hljs-built_in">count</span>&#125; <span class="hljs-keyword">where</span> product_code = #&#123;productCode&#125; <span class="hljs-keyword">and</span> <span class="hljs-built_in">count</span> &gt;= #&#123;<span class="hljs-built_in">count</span>&#125;<br></code></pre></td></tr></table></figure><p>在MySQL中，更新、新增、删除写操作，会加悲观锁，具有原子性，可以解决并发问题。</p><p>在 <code>StockService</code> 中调用该Mapper方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockMapper.updateStock(<span class="hljs-string">&quot;1001&quot;</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在集群部署情况下，使用JMeter进行压力测试，5000个请求成功发出，最终库存为0。</p><h4 id="1-3-2-优缺点"><a href="#1-3-2-优缺点" class="headerlink" title="1.3.2 优缺点"></a>1.3.2 优缺点</h4><p>优点：</p><ol><li>可以解决多例模式、事务、集群部署下的并发问题</li></ol><p>缺点：</p><ol><li><p>锁范围问题</p></li><li><p>同一个商品有多条库存记录（多仓库）</p></li></ol><ul><li><p>如果仍然使用该方法，则会对所有仓库库存数进行自减</p></li><li><p>正常情况应灵活从各个仓库进行减库存发货</p></li></ul><ol start="3"><li>无法记录库存变化前后的状态</li></ol><ul><li>原因：单条SQL语句</li></ul><h5 id="锁范围问题"><a href="#锁范围问题" class="headerlink" title="锁范围问题"></a>锁范围问题</h5><p>表级锁 VS 行级锁</p><ul><li><p>未添加索引之前为 <code>表级锁</code></p><ul><li><p>在用户a中，先开启事务，再去更新 <code>productCode = 1001</code> 记录，但不提交事务</p></li><li><p>这导致：在用户b中，更新 <code>productCode = 1002</code> 记录，但进入了阻塞</p></li><li><p>用户a提交了事务之后，用户b才能提交成功，证明为表级锁</p></li></ul></li><li><p>添加索引之后为 <code>行级锁</code></p><ol><li>锁的查询或更新条件必须为索引字段</li></ol><p>  e.g.：根据 <code>productCode</code> 进行查询或更新，为其添加索引</p><p>  <img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/iShot2022-10-08%2023.44.31.png"></p><ol start="2"><li><p>再次进行之前的操作，用户b不会进入阻塞，即变为了行级锁</p></li><li><p>使用行级锁的条件：</p></li></ol><p>  . 查询或者更新条件必须为索引字段</p><p>  . 查询或者更新条件必须为具体值</p><p>  . SQL语句中where条件有索引时，不能为 <code>&#39;like&#39;</code> 或者 <code>&#39;!=&#39;</code>，否则为表级锁</p></li></ul><h3 id="1-4-悲观锁"><a href="#1-4-悲观锁" class="headerlink" title="1.4 悲观锁"></a>1.4 悲观锁</h3><p>select … for update</p><h4 id="1-4-1-情景引入"><a href="#1-4-1-情景引入" class="headerlink" title="1.4.1 情景引入"></a>1.4.1 情景引入</h4><p>用户a与b并发执行</p><ol><li>用户a开启事务，并使用如下SQL语句查询库存</li></ol>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> db_stock <span class="hljs-keyword">where</span> product_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1001&#x27;</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li>用户b使用如下SQL语句</li></ol>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> db_stock <span class="hljs-keyword">set</span> count <span class="hljs-operator">=</span> count <span class="hljs-operator">-</span> <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>这时库存已经发生变化，而用户a不知情，仍会已它查出来的库存数作为标准进行下一步操作</p><p>解决方案：用户a采用如下SQL语句，进行加锁操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> db_stock <span class="hljs-keyword">where</span> product_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1001&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>加锁范围：此时满足行级锁条件，因此该悲观锁为行级锁，只锁对应的记录</p><h4 id="1-4-2-代码实现"><a href="#1-4-2-代码实现" class="headerlink" title="1.4.2 代码实现"></a>1.4.2 代码实现</h4><ol><li>在StockMapper中添加查询库存方法</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from db_stock where product_code=#&#123;productCode&#125; for update&quot;)</span><br>List&lt;Stock&gt; <span class="hljs-title function_">queryStock</span><span class="hljs-params">(String productCode)</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li>更新StockService方法</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询库存信息并锁定</span><br>    List&lt;Stock&gt; stocks = <span class="hljs-built_in">this</span>.stockMapper.queryStock(<span class="hljs-string">&quot;1001&quot;</span>);<br>    <span class="hljs-comment">// 取第一个库存</span><br>    <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> stocks.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 扣减库存</span><br>        stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">this</span>.stockMapper.updateById(stock);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>使用压力测试工具进行测试，库存数量减为0，解决了并发问题</li></ol><h4 id="1-4-3-优缺点"><a href="#1-4-3-优缺点" class="headerlink" title="1.4.3 优缺点"></a>1.4.3 优缺点</h4><p>优点：更加灵活</p><ol><li>解决同一个商品有多条库存记录的问题</li></ol><p>  可以先根据商品编号查询库存记录，查询到之后再根据现有技术分析。</p><ol start="2"><li>解决无法记录库存变化前后状态的问题</li></ol><p>缺点：</p><ol><li><p>性能问题：效率比JVM本地锁稍高一些，但比单SQL语句低</p></li><li><p>死锁问题：对多条数据加锁时，加锁顺序必须一致</p></li></ol><p>  e.g.：用户a与b执行如下顺序操作</p><ol><li><p>用户a对 <code>id=1</code> 商品加锁</p></li><li><p>用户b对 <code>id=2</code> 商品加锁</p></li><li><p>用户a想对 <code>id=2</code> 商品加锁，但陷入阻塞</p></li><li><p>用户b想对 <code>id=1</code> 商品加锁，报错 Deadlock</p></li><li><p>库存操作需要统一</p></li></ol><h3 id="1-5-乐观锁"><a href="#1-5-乐观锁" class="headerlink" title="1.5 乐观锁"></a>1.5 乐观锁</h3><p>借助时间戳、version版本号实现，利用 <code>CAS</code> 机制</p><p>CAS：Compare and Swap 比较并交换</p><p>关于CAS，可以看看这篇博客：<a href="https://www.cnblogs.com/myopensource/p/8177074.html">漫画：什么是CAS机制</a></p><ul><li><p>如果变量 <code>X</code> 等于旧值 <code>A</code>，则更新将 <code>X</code> 更新为 <code>B</code></p></li><li><p>若不等于，则放弃更新</p></li></ul><h4 id="1-5-1-实现思路"><a href="#1-5-1-实现思路" class="headerlink" title="1.5.1 实现思路"></a>1.5.1 实现思路</h4><ol><li>在 <code>db_stock</code> 表中添加 <code>version</code> 字段</li></ol><p>  类型为int，长度11，Not Null</p><ol start="2"><li>查询对应的商品库存以及 <code>version</code> 号</li></ol>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> db_stock <span class="hljs-keyword">where</span> product_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1001&#x27;</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>执行更新库存操作时，where条件中需要确认当前 <code>version</code> 是否等于之前查出来的</li></ol><p>  . 若等于，则更新库存操作成功</p><p>  . 否则，则说明存在并发操作，该条库存数据已被修改。继续查询重试</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> db_stock <span class="hljs-keyword">SET</span> count<span class="hljs-operator">=</span><span class="hljs-number">4999</span>, version<span class="hljs-operator">=</span>version<span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> version<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h4 id="1-5-2-代码实现"><a href="#1-5-2-代码实现" class="headerlink" title="1.5.2 代码实现"></a>1.5.2 代码实现</h4><p>在 Stock 实体类中添加 <code>version</code> 属性，类型为Integer</p><p>修改 StcokService 中的deduct()方法</p><h5 id="第一版代码"><a href="#第一版代码" class="headerlink" title="第一版代码"></a>第一版代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询库存信息并锁定</span><br>    List&lt;Stock&gt; stocks = <span class="hljs-built_in">this</span>.stockMapper.selectList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;product_code&quot;</span>, <span class="hljs-string">&quot;1001&quot;</span>));<br>    <span class="hljs-comment">// 取第一个库存</span><br>    <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> stocks.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 扣减库存</span><br>        stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> stock.getVersion();<br>        stock.setVersion(version + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stockMapper.update(stock, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;id&quot;</span>, stock.getId()).eq(<span class="hljs-string">&quot;version&quot;</span>, version));<br>        <span class="hljs-keyword">if</span> (update == <span class="hljs-number">0</span>) &#123;<br>            deduct();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>采用JMeter压力测试工具测试时，报错</p><p>错误分析：</p><ol><li>stack over flow：栈溢出</li></ol><p>  <img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/stackoverflow.png"></p><p>  这是由于高并发的情况下，更新失败率很高，就会不断地递归调用deduct方法，导致栈溢出。</p><p>  解决方案：调用线程类中的sleep方法，暂时睡眠，避开并发高峰</p><ol start="2"><li>连接超时错误</li></ol><p>  <img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/timeout.png"></p><p>  这是由于开启了事务注解，为手动事务。</p><p>  当执行到更新操作时，会对数据进行加锁。而当前请求无法更新，就会一直调用deduct方法，并一直持有锁。其他请求进入代码，会进入阻塞状态，直至连接超时。</p><p>  而关闭了事务注解，为自动事务。若更新操作执行失败，会放弃锁。</p><h5 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询库存信息并锁定</span><br>    List&lt;Stock&gt; stocks = <span class="hljs-built_in">this</span>.stockMapper.selectList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;product_code&quot;</span>, <span class="hljs-string">&quot;1001&quot;</span>));<br>    <span class="hljs-comment">// 取第一个库存</span><br>    <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> stocks.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 扣减库存</span><br>        stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> stock.getVersion();<br>        stock.setVersion(version + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stockMapper.update(stock, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;id&quot;</span>, stock.getId()).eq(<span class="hljs-string">&quot;version&quot;</span>, version));<br>        <span class="hljs-keyword">if</span> (update == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">20</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            deduct();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过JMeter测试，最终库存减为0</p><h4 id="1-5-3-优缺点"><a href="#1-5-3-优缺点" class="headerlink" title="1.5.3 优缺点"></a>1.5.3 优缺点</h4><p>推荐阅读：<a href="https://www.cnblogs.com/qjjazry/p/6581568.html">Java并发问题–乐观锁与悲观锁以及乐观锁的一种实现方式-CAS</a></p><p>优点：</p><ol><li>乐观锁在竞争不激烈时，较悲观锁更具有优势，因为悲观锁会锁住代码块，并且加锁、释放锁、线程上下文均占用额外资源。</li></ol><p>缺点：</p><ol><li><p>在高并发情况下，乐观锁的性能不如悲观锁，因为重试次数过多。</p></li><li><p>乐观锁存在ABA问题</p></li></ol><p>  . 在查询与更新的中间，<code>X</code> 值被多次更改，但最终又回到了查询时的值</p><ol start="3"><li>读写分离情况下，乐观锁不可靠</li></ol><p>  从数据库与主数据库进行网络传输，具有较大时延，可能主数据库内是新数据，而从数据库内是旧数据，乐观锁下会造成从数据库不断地重试，</p><h3 id="1-6-MySQL锁总结"><a href="#1-6-MySQL锁总结" class="headerlink" title="1.6 MySQL锁总结"></a>1.6 MySQL锁总结</h3><p>性能：单SQL语句 &gt; 悲观锁 &gt; JVM锁 &gt; 乐观锁</p><ul><li><p>追求极致性能、业务场景简单、无需记录数据更新前后变化的情况下 -&gt; 单SQL语句</p></li><li><p>并发量低、读多于写、竞争不激烈的情况下 -&gt; 乐观锁</p></li><li><p>并发量高、冲突激烈 -&gt; 悲观锁</p></li><li><p>不推荐JVM锁</p></li></ul><h3 id="1-7-Redis锁"><a href="#1-7-Redis锁" class="headerlink" title="1.7 Redis锁"></a>1.7 Redis锁</h3><h4 id="1-7-1-并发问题引入"><a href="#1-7-1-并发问题引入" class="headerlink" title="1.7.1 并发问题引入"></a>1.7.1 并发问题引入</h4><ol><li>在Maven工程pom.xml文件中加入依赖</li></ol>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>在application.properties文件中配置redis</li></ol>  <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.redis.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure><ol start="3"><li>更改 StockService类中的deduct方法</li></ol><p>  采用StringRedisTemplate更加方便</p><p>  而RedisTemplate需要手动设置序列化器</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询库存信息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>);<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>        <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 扣减库存</span><br>            <span class="hljs-built_in">this</span>.redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>在redis-cli命令窗口中，设置库存：<code>set stock 5000</code></li></ol><p>启动SpringBoot与压力测试工具JMeter，最终库存不为0，出现并发问题。</p><h4 id="1-7-2-解决方案"><a href="#1-7-2-解决方案" class="headerlink" title="1.7.2 解决方案"></a>1.7.2 解决方案</h4><ol><li><p>JVM本地锁机制（较简单不做演示）</p></li><li><p>Redis乐观锁：<code>watch</code> <code>multi</code> <code>exec</code></p></li><li><p>watch：监控一个或多个key的值，如果exec执行之前，如果key的值发生变化，则取消事务执行。</p></li><li><p>multi：开启事务</p></li><li><p>exec：执行事务</p></li></ol><h4 id="1-7-3-代码实现"><a href="#1-7-3-代码实现" class="headerlink" title="1.7.3 代码实现"></a>1.7.3 代码实现</h4><p>修改StockService中的deduct方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionCallback</span>&lt;Object&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">execute</span><span class="hljs-params">(RedisOperations operations)</span> <span class="hljs-keyword">throws</span> DataAccessException &#123;<br>            operations.watch(<span class="hljs-string">&quot;stock&quot;</span>);<br>            <span class="hljs-comment">// 查询库存信息</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> operations.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>            <span class="hljs-comment">// 判断库存是否充足</span><br>            <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>                <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// multi</span><br>                    operations.multi();<br>                    <span class="hljs-comment">// 扣减库存</span><br>                    operations.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>                    <span class="hljs-comment">// exec 执行事务</span><br>                    <span class="hljs-type">List</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> operations.exec();<br>                    <span class="hljs-comment">// 如果事务执行结果为空，代表操作失败，重试</span><br>                    <span class="hljs-keyword">if</span> (exec == <span class="hljs-literal">null</span> || exec.size() == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            Thread.sleep(<span class="hljs-number">40</span>);<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                        &#125;<br>                        deduct();<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> exec;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>采用JMeter进行并发测试后，库存减为0，解决了并发问题</p><p>但是吞吐量性能较低，甚至可能由于电脑性能问题，出现连接不够用的情况。</p><h2 id="2-Redis分布式锁"><a href="#2-Redis分布式锁" class="headerlink" title="2. Redis分布式锁"></a>2. Redis分布式锁</h2><h3 id="2-1-实现思路"><a href="#2-1-实现思路" class="headerlink" title="2.1 实现思路"></a>2.1 实现思路</h3><p>借助于redis中的命令 <code>setnx(key, value)</code></p><p>设置 <code>key</code> 为lock</p><ul><li>若 <code>lock</code> 存在，则说明有其他请求已经获取到锁，则当前请求重复重试</li><li>若 <code>lock</code> 不存在，则说明当前锁未被获取，当前请求获取锁成功，继续执行业务操作</li><li>设置 <code>lock</code> 之后，只有一个请求可以获取到锁并执行成功，其他请求只能等待</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/1606626611922.png"></p><h3 id="2-2-基本代码实现"><a href="#2-2-基本代码实现" class="headerlink" title="2.2 基本代码实现"></a>2.2 基本代码实现</h3><h4 id="2-2-1-递归版本"><a href="#2-2-1-递归版本" class="headerlink" title="2.2.1 递归版本"></a>2.2.1 递归版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 加锁setnx</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);<br>    <span class="hljs-comment">// 递归调用</span><br>    <span class="hljs-keyword">if</span> (!lock) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        deduct();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 查询库存信息</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>            <span class="hljs-comment">// 判断库存是否充足</span><br>            <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>                <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 扣减库存</span><br>                    redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 解锁</span><br>            <span class="hljs-built_in">this</span>.redisTemplate.delete(<span class="hljs-string">&quot;lock&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-循环版本"><a href="#2-2-2-循环版本" class="headerlink" title="2.2.2 循环版本"></a>2.2.2 循环版本</h4><p>注意：即使不采用递归版本，在重试获取锁的过程中，也可以使用线程睡眠，这样可以减小锁的竞争压力，提升性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 加锁setnx</span><br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>)) &#123;<br>        <span class="hljs-comment">// 循环重试</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 查询库存信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-comment">// 判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 解锁</span><br>        <span class="hljs-built_in">this</span>.redisTemplate.delete(<span class="hljs-string">&quot;lock&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-问题解决"><a href="#2-3-问题解决" class="headerlink" title="2.3 问题解决"></a>2.3 问题解决</h3><h4 id="2-3-1-死锁与原子性"><a href="#2-3-1-死锁与原子性" class="headerlink" title="2.3.1 死锁与原子性"></a>2.3.1 死锁与原子性</h4><p>在某一请求获取到lock锁之后，当前服务器突然宕机，造成该锁无法得到释放，此时其他请求仍然处于不断地递归或循环重试获取锁，造成死循环。</p><p>解决方案：获取到lock之后，为lock设置过期时间，<code>expire</code> 指令</p><p>但是：可能在 获取lock 与 为lock设置过期时间 之间，服务器发生宕机。</p><p>因此，需要确保两个操作的原子性：采用如下指令，将多个操作复合到一个指令中</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set</span> lock <span class="hljs-number">123</span> ex <span class="hljs-number">20</span> nx<br></code></pre></td></tr></table></figure><p>修改加锁部分的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;<br>    <span class="hljs-comment">// 循环重试</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">50</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-防误删"><a href="#2-3-2-防误删" class="headerlink" title="2.3.2 防误删"></a>2.3.2 防误删</h4><p>假设处理请求的时长大于锁的有效时间，当某一请求还未执行完当前操作时，Redis锁便会自动释放掉（删除lock），等到该请求执行完当前操作后，还会手动地将Redis锁释放掉。此时，可能别的请求已经获取到了锁，那么该锁很有可能被该请求误删掉。</p><p><strong>解决方案：</strong></p><p>为了防止出现这一情况，需要为当前锁设置唯一标识UUID，作为锁的值。</p><p>在删除锁之前，先判断当前锁是否属于自己，然后再进行删除。</p><p>修改 StockService 的 deduct方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>    <span class="hljs-comment">// 加锁setnx</span><br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, uuid, <span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;<br>        <span class="hljs-comment">// 循环重试</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 查询库存信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-comment">// 判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 先判断，再解锁</span><br>        <span class="hljs-keyword">if</span> (StringUtils.equals(<span class="hljs-built_in">this</span>.redisTemplate.opsForValue().get(<span class="hljs-string">&quot;lock&quot;</span>), uuid)) &#123;<br>            <span class="hljs-built_in">this</span>.redisTemplate.delete(<span class="hljs-string">&quot;lock&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断与删除操作需要保证原子性，否则还会出现并发问题</p><ul><li>刚判断完该锁是自己的，还没进行删除，锁就到期自动释放且被其他请求获取，此时会造成误删操作</li></ul><p>借助 <code>lua</code> 脚本实现原子性操作：<a href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程 | 菜鸟教程</a></p><p>redis-cli支持lua脚本，可以一次性给redis发送多个指令。</p><ul><li>redis为单线程，执行指令遵守 <code>one-by-one</code> 规则</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">EVAL script numkeys <span class="hljs-comment">[key <span class="hljs-comment">[key ...]</span>]</span> <span class="hljs-comment">[arg <span class="hljs-comment">[arg ...]</span>]</span><br></code></pre></td></tr></table></figure><p>删除LUA脚本：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>更改代码中finally部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先判断，再解锁</span><br><span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] &quot;</span> +<br>        <span class="hljs-string">&quot;then return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +<br>        <span class="hljs-string">&quot;else return 0 &quot;</span> +<br>        <span class="hljs-string">&quot;end&quot;</span>;<br><span class="hljs-built_in">this</span>.redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(<span class="hljs-string">&quot;lock&quot;</span>), uuid);<br></code></pre></td></tr></table></figure><h4 id="2-3-3-可重入性"><a href="#2-3-3-可重入性" class="headerlink" title="2.3.3 可重入性"></a>2.3.3 可重入性</h4><p>之前的加锁指令采用的是Redis中的 <code>setnx</code> 指令，即锁的名字固定为lock（键值固定），一旦加锁成功（键设置成功），该线程便无法继续加锁。如下即为具体情景代码：</p><p>某线程执行a方法，获取到锁之后，其又需要继续执行b方法，需要继续获取锁。但此时锁已经被自己占有，相当于自己和自己产生了死锁，这是不可重入锁带来的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>    b();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解决方案：可重入锁</strong></p><p>可重入锁可：当某一线程获得锁之后，需要再次执行加锁方法时（锁对象为同一个），将加锁次数加1即可。执行完毕之后，释放锁时对加锁次数减1。当加锁次数等于0时，说明该锁已经被完全释放。</p><p>当可重入锁需要在分布式环境实现时，需要统计加锁次数。</p><p><strong>实现方案：Redis Hash + lua脚本</strong></p><p>加锁 -&gt; 判断锁是否存在：<code>exists</code></p><ul><li><p>若不存在，则直接创建锁并获取：<code>hset key field value</code></p></li><li><p>若存在，则判断当前锁是否属于自己：<code>hexists</code></p><ul><li><p>若属于，则重入：<code>hincrby key field increment</code></p></li><li><p>若不属于，递归或循环自旋重试</p></li></ul></li></ul><p><strong>加锁脚本</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span> <br><span class="hljs-keyword">then</span><br>    redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>)<br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>解锁 -&gt; 判断锁是否属于自己：<code>hexists</code></p><ul><li><p>若不属于，说明正在恶意释放锁，返回 <code>nil</code></p></li><li><p>若属于，对加锁次数减1，并判断当前加锁次数是否为0</p><ul><li><p>若为0，则返回1，代表完全解锁成功</p></li><li><p>若不为0，则返回0</p></li></ul></li></ul><p><strong>解锁脚本</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span><br><span class="hljs-keyword">then</span> <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">elseif</span> redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>], <span class="hljs-number">-1</span>) == <span class="hljs-number">0</span><br><span class="hljs-keyword">then</span> <br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><strong>代码实现</strong></p><ol><li>创建分布式锁的工厂类方法。通过一个工厂类方法，可以获得不同的分布式锁（基于Redis、基于Zookeeper、基于MySQL）</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributedLockClient</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br>    <span class="hljs-keyword">private</span> String uuid;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistributedLockClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.uuid = UUID.randomUUID().toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> DistributedRedisLock <span class="hljs-title function_">getRedisLock</span><span class="hljs-params">(String lockName)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistributedRedisLock</span>(redisTemplate, lockName, uuid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>创建分布式Redis锁的实现类，其实现了Lock接口。通过之前编写好的加锁、解锁脚本，实现了可重入锁。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributedRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br>    <span class="hljs-keyword">public</span> String lockName;<br><br>    <span class="hljs-keyword">private</span> String uuid;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">expire</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistributedRedisLock</span><span class="hljs-params">(StringRedisTemplate redisTemplate, String lockName, String uuid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>        <span class="hljs-built_in">this</span>.lockName = lockName;<br>        <span class="hljs-built_in">this</span>.uuid = uuid;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.tryLock();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.tryLock(-<span class="hljs-number">1L</span>, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-built_in">this</span>.expire = time != -<span class="hljs-number">1</span> ? unit.toSeconds(time) : expire;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;exists&#x27;, KEYS[1]) == 0 or redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 \n&quot;</span> +<br>                        <span class="hljs-string">&quot;then\n&quot;</span> +<br>                        <span class="hljs-string">&quot;    redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1)\n&quot;</span> +<br>                        <span class="hljs-string">&quot;    redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2])\n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return 1\n&quot;</span> +<br>                        <span class="hljs-string">&quot;else\n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return 0\n&quot;</span> +<br>                        <span class="hljs-string">&quot;end&quot;</span>;<br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), getId(), String.valueOf(expire))) &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0\n&quot;</span> +<br>                        <span class="hljs-string">&quot;then \n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return nil\n&quot;</span> +<br>                        <span class="hljs-string">&quot;elseif redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1) == 0\n&quot;</span> +<br>                        <span class="hljs-string">&quot;then \n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return redis.call(&#x27;del&#x27;, KEYS[1])\n&quot;</span> +<br>                        <span class="hljs-string">&quot;else \n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return 0\n&quot;</span> +<br>                        <span class="hljs-string">&quot;end&quot;</span>;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script, Long.class), Arrays.asList(lockName), getId());<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(<span class="hljs-string">&quot;this lock does not belong to you&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> uuid + <span class="hljs-string">&quot;:&quot;</span> + Thread.currentThread().getId();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>修改StockService中的deduct方法</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">DistributedRedisLock</span> <span class="hljs-variable">redisLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.distributedLockClient.getRedisLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>    redisLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 查询库存信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-comment">// 判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.test();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        redisLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的一点是：如何去标识每一个服务中的每一个线程的锁的uuid？</p><p>这里的解决方案是：通过服务生成的uuid与每个线程的线程id拼接得到唯一标识uuid</p><ol><li>每一个服务是通过DistributedLockClient这一工厂类获得锁，由于该类交给Spring容器管理，是单例对象。即每一个服务只有一个唯一的DistributedLockClient对象。</li></ol><p>  因此可以在该类构造方法上生成一个uuid，作为当前服务的唯一标识</p><ol start="2"><li><p>每一个线程也会有一个唯一的id</p></li><li><p>将两者拼接起来（getId方法），即可唯一标识每一个服务的每一个线程。若需要进行重入操作，同一线程重复获取锁，可通过此唯一标识进行判断。</p></li></ol><p>反之，如果每次通过DistributedLockClient获取Redis分布式锁，均重新创建一个新的uuid，那么便永远无法实现可重入锁。</p><ul><li>因为在同一线程进行可重入操作获取锁时，会出现内层锁与外层锁uuid不匹配的错误情况，与理论事实相矛盾。</li></ul><h4 id="2-3-4-自动续期"><a href="#2-3-4-自动续期" class="headerlink" title="2.3.4 自动续期"></a>2.3.4 自动续期</h4><p>假设处理请求的时长大于锁的有效时间，会出现请求还未处理完，锁就被释放了，此时可能引起并发问题。</p><p><strong>解决方案：</strong></p><ul><li><p>采用Timer定时任务，每隔一段时间为锁续期</p></li><li><p>配合lua脚本执行最后的续期操作</p><p>先判断锁是否存在。若存在则重置过期时间</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span>) <br><span class="hljs-keyword">then</span> <br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renewExpire</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if(redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) \n&quot;</span> +<br>                    <span class="hljs-string">&quot;then \n&quot;</span> +<br>                    <span class="hljs-string">&quot;    redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2])\n&quot;</span> +<br>                    <span class="hljs-string">&quot;    return 1\n&quot;</span> +<br>                    <span class="hljs-string">&quot;else \n&quot;</span> +<br>                    <span class="hljs-string">&quot;    return 0\n&quot;</span> +<br>                    <span class="hljs-string">&quot;end&quot;</span>;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>().schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), uuid, String.valueOf(expire))) &#123;<br>                renewExpire();<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-built_in">this</span>.expire * <span class="hljs-number">1000</span> / <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中需要注意的点是：</p><ul><li><p>之前是通过 <code>getId()</code> 方法，将当前服务的uuid与当前线程的id拼接到一起，组成唯一标识。</p><p>而现在的问题为：Timer定时任务是子线程，它的本意是监测主线程的锁的过期时间并为其续期，但是在其内部调用getId方法，得到的锁唯一标识是拼接的Timer定时任务子线程的id。</p></li><li><p>因此，需要对代码进行进一步修改与优化，删去getId方法，修改DistributedRedisLock的构造方法，在创建该类时便生成唯一的uuid。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">DistributedRedisLock</span><span class="hljs-params">(StringRedisTemplate redisTemplate, String lockName, String uuid)</span> &#123;<br>    <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>    <span class="hljs-built_in">this</span>.lockName = lockName;<br>    <span class="hljs-built_in">this</span>.uuid = uuid + <span class="hljs-string">&quot;:&quot;</span> + Thread.currentThread().getId();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>MySQL</tag>
      
      <tag>Redis</tag>
      
      <tag>锁</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 870. Advantage Shuffle</title>
    <link href="/2022/10/08/LC-Solution-870-Advantage-Shuffle/"/>
    <url>/2022/10/08/LC-Solution-870-Advantage-Shuffle/</url>
    
    <content type="html"><![CDATA[<h1 id="870-Advantage-Shuffle"><a href="#870-Advantage-Shuffle" class="headerlink" title="870. Advantage Shuffle"></a><a href="https://leetcode.cn/problems/advantage-shuffle/">870. Advantage Shuffle</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个大小相等的数组 <code>nums1</code> 和 <code>nums2</code>，<code>nums1</code> 相对于 <code>nums</code> 的优势可以用满足 <code>nums1[i]</code> &gt; <code>nums2[i]</code> 的索引 <code>i</code> 的数目来描述。</p><p>返回 <code>nums1</code> 的任意排列，使其相对于 <code>nums2</code> 的优势最大化。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums1 = <span class="hljs-string">[2,7,11,15]</span>, nums2 = <span class="hljs-string">[1,10,4,11]</span><br>输出：<span class="hljs-string">[2,11,7,15]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums1 = <span class="hljs-string">[12,24,8,32]</span>, nums2 = <span class="hljs-string">[13,25,32,11]</span><br>输出：<span class="hljs-string">[24,32,8,12]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>1 &lt;&#x3D; nums1.length &lt;&#x3D; 105</p></li><li><p>nums2.length &#x3D;&#x3D; nums1.length</p></li><li><p>0 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 109</p></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：田忌赛马-gt-贪心-双指针"><a href="#方法一：田忌赛马-gt-贪心-双指针" class="headerlink" title="方法一：田忌赛马 -&gt; 贪心 + 双指针"></a>方法一：田忌赛马 -&gt; 贪心 + 双指针</h3><p>该方案采用的是 <a href="%5B%E5%8A%9B%E6%89%A3%5D(https://leetcode.cn/problems/advantage-shuffle/solution/tian-ji-sai-ma-by-endlesscheng-yxm6/)">灵神</a> 的题解，下面我说一下我的理解</p><p>题目要求使 <code>nums1</code> 数组 <strong>“战胜”</strong> <code>nums2</code> 数组的次数最大化</p><p>通过此很容易想到贪心思路，对 <code>nums1</code> 与 <code>nums2</code> 分别进行排序，</p><p>然后对比 <code>nums1</code> 当前最小值 与 <code>nums2</code> 当前最小值</p><ul><li><p>若 <code>nums1</code> 的当前最小值大于 <code>nums2</code> 的当前最小值，则 <code>nums1</code> 获胜</p></li><li><p>否则，说明 <code>nums1</code> 的当前最小值无法战胜 <code>nums2</code> 的所有值，所以让 <code>nums1</code> 的当前最小值与 <code>nums2</code> 的当前最大值作战（即当“炮灰”），这样可以抵消掉 <code>nums2</code> 的最大值。</p></li></ul><p>这就是典型的 <code>田忌赛马</code> 思路，用下等马去战胜上等马！</p><ul><li><code>nums1</code> 的下等马无法战胜 <code>nums2</code> 的下等马时，就让其当炮灰去对战 <code>nums2</code> 的上等马</li></ul><p>每一个 “作战回合” 结束之后，需要将本回合用过的元素摒弃掉。</p><p>而 <code>nums2</code> 的最小值（即数组尾元素）或最大值（即数组首元素）均可能被使用，所以本题采用 <code>首尾双指针</code> 思路，逐渐缩小问题规模，最终得到全部对应关系。</p><p>但在代码具体实现过程中，如果对两个数组均进行排序，则丢失了原本的 ”作战“ 顺序，所以只对 <code>nums1</code> 进行排序。用额外的下标数组 <code>ids</code>，根据 <code>nums2</code> 的元素大小，对其下标进行排序。<code>ids[0]</code> 对应 <code>nums2</code> 第一小值下标，<code>ids[1]</code> 对应 <code>nums2</code> 第二小值下标…</p><p>通过 <code>ids</code> 数组，就可以知道当前 <code>nums2</code> 下标所要对应的 <code>nums1</code> 元素。</p><p>感觉这道题直接看代码更容易理解。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">advantageCount</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums1)<br>        ans = [<span class="hljs-number">0</span>] * n<br>        nums1.sort()<br>        ids = <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">range</span>(n), key=<span class="hljs-keyword">lambda</span> i: nums2[i])<br>        left, right = <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums1:<br>            <span class="hljs-keyword">if</span> x &gt; nums2[ids[left]]:<br>                ans[ids[left]] = x  <br>                left += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                ans[ids[right]] = x  <br>                right -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>注意：Java采用比较器排序时，只能使用包装类Integer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] advantageCount(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums2.length;<br>        Integer[] ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) ids[i] = i;<br>        Arrays.sort(nums1);<br>        Arrays.sort(ids, (a, b) -&gt; nums2[a] - nums2[b]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, q = len - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : nums1) &#123;<br>            <span class="hljs-keyword">if</span>(x &gt; nums2[ids[p]]) ans[ids[p++]] = x;<br>            <span class="hljs-keyword">else</span> ans[ids[q--]] = x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第15篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1800. Maximum Ascending Subarray Sum</title>
    <link href="/2022/10/07/LC-Solution-1800-Maximum-Ascending-Subarray-Sum/"/>
    <url>/2022/10/07/LC-Solution-1800-Maximum-Ascending-Subarray-Sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-ascending-subarray-sum/">1800. 最大升序子数组和</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数组成的数组 <code>nums</code> ，返回 <code>nums</code> 中一个 <strong>升序</strong> 子数组的最大可能元素和。</p><p>子数组是数组中的一个连续数字序列。</p><p>已知子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，若对所有 <code>i</code>（<code>l &lt;= i &lt; r</code>），<code>numsi</code> &lt; <code>numsi+1</code> 都成立，则称这一子数组为 <strong>升序</strong> 子数组。注意，大小为 1 的子数组也视作 <strong>升序</strong> 子数组。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[10,20,30,5,10,50]</span><br>输出：65<br>解释：<span class="hljs-comment">[5,10,50]</span> 是元素和最大的升序子数组，最大元素和为 65 。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[10,20,30,40,50]</span><br>输出：<span class="hljs-number">150</span><br>解释：<span class="hljs-string">[10,20,30,40,50]</span> 是元素和最大的升序子数组，最大元素和为 <span class="hljs-number">150</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[12,17,15,13,10,11,12]</span><br>输出：33<br>解释：<span class="hljs-comment">[10,11,12]</span> 是元素和最大的升序子数组，最大元素和为 33 。 <br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">100,10,1</span>]<br>输出：<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：简单模拟"><a href="#方法一：简单模拟" class="headerlink" title="方法一：简单模拟"></a>方法一：简单模拟</h3><p>遍历数组，比较相邻元素之间是否满足升序条件。</p><p>用 <code>s</code> 记录当前升序子数组的和，用 <code>ans</code> 记录最终最大的和。</p><ul><li><p>若当前元素大于前一个元素（ <code>nums[i] &gt; nums[i - 1</code>] ），将当前元素 <code>nums[i]</code> 累加到 <code>s</code> 中，并更新 <code>ans = max(ans, s)</code></p></li><li><p>否则，将 <code>s</code> 重置为当前元素，即 <code>s = nums[i]</code></p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxAscendingSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = s = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[i - <span class="hljs-number">1</span>]:<br>                s += nums[i]<br>                ans = <span class="hljs-built_in">max</span>(ans, s)<br>            <span class="hljs-keyword">else</span>:<br>                s = nums[i]<br>        <span class="hljs-keyword">return</span> ans      <br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAscendingSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>], sum = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                sum += nums[i];<br>                ans = Math.max(ans, sum);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sum = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第14篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo从0到1搭建博客系列03：文章与评论模块</title>
    <link href="/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9703%EF%BC%9A%E6%96%87%E7%AB%A0%E4%B8%8E%E8%AF%84%E8%AE%BA%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9703%EF%BC%9A%E6%96%87%E7%AB%A0%E4%B8%8E%E8%AF%84%E8%AE%BA%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo从0到1搭建博客系列03：文章与评论模块"><a href="#Hexo从0到1搭建博客系列03：文章与评论模块" class="headerlink" title="Hexo从0到1搭建博客系列03：文章与评论模块"></a>Hexo从0到1搭建博客系列03：文章与评论模块</h1><h2 id="1-文章的编辑与发布"><a href="#1-文章的编辑与发布" class="headerlink" title="1. 文章的编辑与发布"></a>1. 文章的编辑与发布</h2><p>在这一部分，我们主要学习如何编辑文章，并将其发布在Hexo博客上。</p><p>这一部分我们仍然在Hexo博客根目录上操作。</p><ol><li>执行以下命令，创建一篇新的文章。引号内为博客的标题</li></ol>  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;&quot;</span><br>e.g.: hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;我的第一篇博客&quot;</span><br></code></pre></td></tr></table></figure><p>  如图所示，该博客已经被创建到 <code>source/_posts</code> 目录下啦</p><p>  <img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/first-blog.png"></p><ol start="2"><li>编辑该页面，可以看到如下信息（可以采用 <a href="https://github.com/marktext/marktext">MarkText</a> 进行编辑，这个是免费的）</li></ol>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">我的第一篇博客</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-10-05 16:00:30</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>  其中包含了博客的 <code>title</code>、<code>date</code>、<code>tags</code>信息</p><ol start="3"><li>接下来，我们编辑博客的 <code>tags</code> 与 <code>categories</code>，仍然需要注意 <code>yaml</code> 格式</li></ol>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">我的第一篇博客</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-10-05 16:00:30</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">学习感悟</span>, <span class="hljs-string">知识分享</span>, <span class="hljs-string">Java</span>]<br><span class="hljs-attr">categories:</span> [<span class="hljs-string">Java基础</span>]<br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><ol start="4"><li>在下面接着编辑博客内容（可以采用 <a href="https://github.com/marktext/marktext">MarkText</a> 进行编辑，这个是免费的）</li></ol><p>  示例如下：</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">我的第一篇博客</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-10-05 16:00:30</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">学习感悟</span>, <span class="hljs-string">知识分享</span>, <span class="hljs-string">Java</span>]<br><span class="hljs-attr">categories:</span> [<span class="hljs-string">Java基础</span>]<br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-comment"># 我的第一篇博客</span><br><br><span class="hljs-comment">## 1. Java基础</span><br><br><span class="hljs-string">Java是一门后端语言，我爱Java。</span><br><br><span class="hljs-comment">## 2. Java实战</span><br><br><span class="hljs-string">第一行代码</span><br><br><span class="hljs-string">```java</span><br><span class="hljs-string">System.out.println(&quot;Hello</span> <span class="hljs-string">World!&quot;);</span><br></code></pre></td></tr></table></figure><ol start="5"><li><code>Ctrl + S</code> 保存，然后将博客运行到本地服务器。</li></ol>  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>这样一来就可以完成博客的编辑与发布啦，看看成品吧~</p><p>下面那一篇是 <code>Hexo</code> 初始化的文章</p><p><img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/blog-content1.png" alt="https//cdnjsdelivrnet/gh/ltyzzzxxx/ltyzzzImageBed/blogimg/blogcontentpng"></p><p>进入 <code>分类</code>、<code>标签</code> 页可以看到相应的内容</p><h2 id="2-引入评论模块"><a href="#2-引入评论模块" class="headerlink" title="2. 引入评论模块"></a>2. 引入评论模块</h2><p>引入评论听起来非常高大上。如果自己手动搭建一个评论系统，将是需要一定技术的工作，而在<code>Hexo-Fluid</code> 中，这仅仅只是一个简单的配置</p><ol><li>打开之前粘贴好的 <code>_config.fluid.yml</code> 文件，找到以下内容。</li></ol>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">comments:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">disqus</span><br></code></pre></td></tr></table></figure><p>  这里我推荐使用另外一个评论插件 <code>Valine</code>，所以将type进行相应的更改。</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">comments:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">valine</span><br></code></pre></td></tr></table></figure><p>  其他评论插件官方文档有详细的写，如果想尝试其他的，请点击[这里](<a href="https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA">配置指南 | Hexo Fluid 用户手册</a>)查找~</p><ol start="2"><li><p>进入 <a href="https://valine.js.org/quickstart.html">Valine</a> 主页，注册一个 <code>LeanCloud</code> 账号，然后完成相应的实名认证。这一部分就比较简单啦，不再赘述。</p></li><li><p>进入 <code>LeanCloud</code> 个人主页控制台，左上角创建应用。</p></li></ol><p>  我已经创建过啦，就不再创建了。</p><p>  <img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/leadcloud-page.png"></p><ol start="4"><li>点击进入创建好的应用，点击左侧菜单 设置 - 应用凭证，就可以看到相应的配置信息啦</li></ol><p>  <img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/leancloud-key.png"></p><ol start="5"><li>将 <code>AppID</code> 与 <code>AppKey</code> 复制并粘贴到 <code>_config.fluid.yml</code> 文件中如下相应的位置</li></ol>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">valine:</span><br>  <span class="hljs-attr">appId:</span> <span class="hljs-string">xxxxx</span><br>  <span class="hljs-attr">appKey:</span> <span class="hljs-string">xxxxx</span><br></code></pre></td></tr></table></figure><ol start="6"><li>保存配置文件，再次运行博客到本地服务器</li></ol>  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>打开之前发布的博客页，拉到最底部，即可看到评论界面啦~</p><p><img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/comment.png"></p><p>由于 <code>Valine</code> 是一个无后端评论系统，想要管理评论的话，得去 <code>LeanCloud</code> 后台数据存储进行管理相关评论数据。</p><h2 id="3-后记"><a href="#3-后记" class="headerlink" title="3. 后记"></a>3. 后记</h2><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>Hexo搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo从0到1搭建博客系列02：引入Fluid</title>
    <link href="/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9702%EF%BC%9A%E5%BC%95%E5%85%A5Fluid/"/>
    <url>/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9702%EF%BC%9A%E5%BC%95%E5%85%A5Fluid/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo从0到1搭建博客系列02：引入Fluid"><a href="#Hexo从0到1搭建博客系列02：引入Fluid" class="headerlink" title="Hexo从0到1搭建博客系列02：引入Fluid"></a>Hexo从0到1搭建博客系列02：引入Fluid</h1><h2 id="1-Fluid简介"><a href="#1-Fluid简介" class="headerlink" title="1. Fluid简介"></a>1. Fluid简介</h2><blockquote><p>Fluid [官网](<a href="https://hexo.fluid-dev.com/docs/start/">开始使用 | Hexo Fluid 用户手册</a>)</p><p>Fluid 是基于 Hexo 的一款 Material Design 风格的主题，由 Fluid-dev 负责开发与维护。</p><p>主题 GitHub: <a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>预览网站：<a href="https://hexo.fluid-dev.com/">Fluid’s blog</a> <a href="https://zkqiang.cn/">zkqiang’s blog</a></p></blockquote><p>Fluid其实就是基于Hexo现有功能，进行了更进一步的配置、美化，引入了很多新的功能，使我们的博客变得更加美观、简洁与高效。</p><p>在进行Fluid实战之前，必须得先搭建好Hexo基础博客。</p><h2 id="2-Fluid简单实战"><a href="#2-Fluid简单实战" class="headerlink" title="2. Fluid简单实战"></a>2. Fluid简单实战</h2><ol><li>进入之前搭建好的 <code>Hexo</code> 博客目录，执行以下命令，安装 <code>fluid</code> 主题</li></ol>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid</span><br></code></pre></td></tr></table></figure><p>  <img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/fluid-install.png"></p><ol start="2"><li>在博客目录下创建 <code>_config.fluid.yml</code>，将 <code>fluid</code> 主题自己的 <code>_config.yml</code> 粘贴进去。</li></ol><p>  这一步很重要，一定要进入<a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml%E8%BF%99%E4%B8%80%E7%BD%91%E9%A1%B5%EF%BC%8C">https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml这一网页，</a> 将对应的文件粘贴到之前创建好的空的<code>_config.fluid.yml</code>文件中。这个文件很长，所以没办法贴在这里，见谅~</p><ol start="3"><li>打开创建好的 <code>Hexo</code> 博客目录下的 <code>_config.yml</code> ，将对应配置项修改为以下内容</li></ol><p>  一定要注意这是 <code>yaml</code> 格式文件，冒号后一定要有空格。</p><p>  灵活使用 <code>Ctrl + F</code> 搜索关键字</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><p>仍然是使用 <code>hexo server</code> 命令运行到本地</p><p>展示一下成品吧~</p><p><img src="file:///Users/lty/Downloads/hexo-fluid-page.png?msec=1664956366776"></p><p>是不是瞬间比之前Hexo基础博客提升了一个档次？</p><p>之后我们的大部分功能将在 <code>_config.fluid.yml</code> 文件里完成配置~</p><h2 id="3-后记"><a href="#3-后记" class="headerlink" title="3. 后记"></a>3. 后记</h2><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>Hexo搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo从0到1搭建博客系列01：浅尝Hexo.md</title>
    <link href="/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9701%EF%BC%9A%E6%B5%85%E5%B0%9DHexo-md/"/>
    <url>/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9701%EF%BC%9A%E6%B5%85%E5%B0%9DHexo-md/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo从0到1搭建博客系列01：浅尝Hexo"><a href="#Hexo从0到1搭建博客系列01：浅尝Hexo" class="headerlink" title="Hexo从0到1搭建博客系列01：浅尝Hexo"></a>Hexo从0到1搭建博客系列01：浅尝Hexo</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>作为一个程序员，我们总是想记录一些自己日常学习的东西、自己对于技术的思考以及自己平时折腾的一些小项目。但是自己手动搭建一个博客是很费时费力的一件事情，我们需要考虑一下几点难题：</p><ol><li><p>制作一个博客网站需要这些技术：后端采用 <code>SpringBoot</code> 全家桶，前端采用 <code>Vue/React</code> 。如果追求快速搭建一个博客，可以使用全栈 <code>nodejs</code>（ <code>egg.js</code>、<code>express</code>、<code>koa</code> 等）。如果想让博客功能更强大，需要引入更多的技术。但这些技术的学习都很耗时费力，极可能劝退。</p></li><li><p>如果想让博客页面更好看，需要自己设计 <code>UI</code>。</p></li><li><p>博客最终展示给别人，需要部署到服务器上才能让大家看到。需要买服务器、买域名、域名备案、学习部署知识等等。</p></li><li><p>服务器后期需要维护，一年维护费用可能几百至上千不等。</p></li><li><p>服务器被人恶意攻击（ <code>DDOS</code>、 <code>SQL注入</code> 等），需要自己手动解决或花钱升级服务器。</p></li></ol><p>如果你想要通过博客项目，以此学习前后端的知识、提升自己的编程水平甚至是将其作为一个简历上可以拿得出手的项目，我强烈建议你将以上步骤逐一完成，甚至可以将个人博客延伸为社交博客论坛（类似 <code>CSDN</code>、<code>掘金</code> 等），引入微服务与分布式技术。将这些做完，绝对会有明显的技术提升。</p><p>但是，如果你只想有一个自己的网站去记录一些日常的学习等内容，继续往下看，我将会使用 <code>Hexo</code> 简化以上流程，从0到1实现一个美观精致高效的博客。</p><h2 id="2-Hexo简介"><a href="#2-Hexo简介" class="headerlink" title="2. Hexo简介"></a>2. Hexo简介</h2><p>首先简单介绍一下 <code>Hexo</code></p><blockquote><p>引自[官方](<a href="https://hexo.io/zh-cn/docs/index.html">文档 | Hexo</a>)</p><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p>其实 <code>Hexo</code> 就是帮我们完成了大部分与书写博客无关的事情，我们只需要根据 <code>Hexo</code> 现有的框架，做一些简单的配置，即可做出一个博客网站。之后，我们就可以专注地写自己的博客啦</p><p>在接下来的部分中，你只需要有以下几点前置知识，即可快速完成之后系列的全部内容：</p><ol><li><code>Node.js</code>：主要用于安装<code>Hexo</code>、发布文章、部署等操作</li></ol><p>  安装 <code>Node.js</code> ：</p><ol><li><p><a href="https://nodejs.org/en/download/">官网</a>安装</p></li><li><p>Mac可采用 <code>Homebrew</code> 安装</p></li><li><p><code>Git</code> 及 <code>Github</code>：最后的博客网站将发布到 <code>Github</code> 中</p></li><li><p><code>Markdown</code>：这个很简单，在 <code>CSDN</code> 或者用Typora写过博客的人都知道怎么用</p></li></ol><p>之后全部的实战部分，均采用 <code>VSCode</code> 编辑器完成。如果你熟练使用命令行操作，也可以直接在命令行上完成全部操作。</p><h2 id="3-Hexo简单实战"><a href="#3-Hexo简单实战" class="headerlink" title="3. Hexo简单实战"></a>3. Hexo简单实战</h2><ol><li>首先打开命令行窗口，执行以下命令，安装Hexo。</li></ol>  <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>  <img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/hexo-install.png"></p><ol start="2"><li>选择一个合适的位置（之后博客全部文件所在的地方），执行以下命令。</li></ol><p>  这里我博客命名为ltyzzz-blog</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init ltyzzz<span class="hljs-literal">-blog</span><br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> ltyzzz<span class="hljs-literal">-blog</span><br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><ol start="3"><li>通过 <code>VSCode</code> 打开创建好的博客目录</li></ol><p>  <img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/hexo-file.png" alt="https//cdnjsdelivrnet/gh/ltyzzzxxx/ltyzzzImageBed/blogimg/hexofilepng"></p><p>  介绍其中几个重要的文件：</p><ul><li><p>_config.yml：博客相关的配置均在这个文件中（之后引入Fluid主题后有所变化）</p></li><li><p>source：用来存放用户资源的位置（我们写的文章就存储在这里）</p></li></ul><ol start="4"><li>执行以下命令，生成静态网页文件 <code>public</code></li></ol>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><ol start="5"><li>执行以下命令，在本地服务器（默认为：<code>http://localhost:4000/</code>）启动博客</li></ol>  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>最终Hexo基础博客页面如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ltyzzzxxx/ltyzzz-ImageBed/blog-img/hexo-page.png"></p><p>看到这里，是不是感觉Hexo页面十分的简陋甚至有点丑？</p><p>没关系，之前的部分只是带大家简单尝试一下Hexo，了解一下基本的框架与命令使用。</p><p>我们的重头戏将放在Fluid主题，通过该主题熟悉Hexo核心功能以及Fluid新增的功能。</p><p>接下来的内容包括有：</p><ol><li>博客文章的编辑与发布</li><li>评论区功能模块引入</li><li>图床的最佳实践</li><li>新增留言板界面</li><li>将博客部署到Github</li></ol><h2 id="4-后记"><a href="#4-后记" class="headerlink" title="4. 后记"></a>4. 后记</h2><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>Hexo搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 811. Subdomain Visit Count</title>
    <link href="/2022/10/05/LC-Solution-811-Subdomain-Visit-Count/"/>
    <url>/2022/10/05/LC-Solution-811-Subdomain-Visit-Count/</url>
    
    <content type="html"><![CDATA[<h1 id="811-子域名访问计数"><a href="#811-子域名访问计数" class="headerlink" title="811. 子域名访问计数"></a><a href="https://leetcode.cn/problems/subdomain-visit-count/">811. 子域名访问计数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>网站域名 <code>&quot;discuss.leetcode.com&quot;</code> 由多个子域名组成。顶级域名为 <code>&quot;com&quot;</code> ，二级域名为 <code>&quot;leetcode.com&quot;</code> ，最低一级为 <code>&quot;discuss.leetcode.com&quot;</code> 。当访问域名 <code>&quot;discuss.leetcode.com&quot;</code> 时，同时也会隐式访问其父域名 <code>&quot;leetcode.com&quot;</code> 以及 <code>&quot;com&quot;</code> 。</p><p><strong>计数配对域名</strong> 是遵循 <code>&quot;rep d1.d2.d3&quot;</code> 或 <code>&quot;rep d1.d2&quot;</code> 格式的一个域名表示，其中 <code>rep</code> 表示访问域名的次数，<code>d1.d2.d3</code> 为域名本身。</p><p>例如，<code>&quot;9001 discuss.leetcode.com&quot;</code> 就是一个 <strong>计数配对域名</strong> ，表示 <code>discuss.leetcode.com</code> 被访问了 <code>9001</code> 次。<br>给你一个 <strong>计数配对域名</strong> 组成的数组 <code>cpdomains</code> ，解析得到输入中每个子域名对应的 <strong>计数配对域名</strong> ，并以数组形式返回。可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：cpdomains = [<span class="hljs-string">&quot;9001 discuss.leetcode.com&quot;</span>]<br>输出：[<span class="hljs-string">&quot;9001 leetcode.com&quot;</span>,<span class="hljs-string">&quot;9001 discuss.leetcode.com&quot;</span>,<span class="hljs-string">&quot;9001 com&quot;</span>]<br>解释：例子中仅包含一个网站域名：<span class="hljs-string">&quot;discuss.leetcode.com&quot;</span>。<br>按照前文描述，子域名 <span class="hljs-string">&quot;leetcode.com&quot;</span> 和 <span class="hljs-string">&quot;com&quot;</span> 都会被访问，所以它们都被访问了 <span class="hljs-number">9001</span> 次。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：cpdomains = [<span class="hljs-string">&quot;900 google.mail.com&quot;</span>, <span class="hljs-string">&quot;50 yahoo.com&quot;</span>, <span class="hljs-string">&quot;1 intel.mail.com&quot;</span>, <span class="hljs-string">&quot;5 wiki.org&quot;</span>]<br>输出：[<span class="hljs-string">&quot;901 mail.com&quot;</span>,<span class="hljs-string">&quot;50 yahoo.com&quot;</span>,<span class="hljs-string">&quot;900 google.mail.com&quot;</span>,<span class="hljs-string">&quot;5 wiki.org&quot;</span>,<span class="hljs-string">&quot;5 org&quot;</span>,<span class="hljs-string">&quot;1 intel.mail.com&quot;</span>,<span class="hljs-string">&quot;951 com&quot;</span>]<br>解释：按照前文描述，会访问 <span class="hljs-string">&quot;google.mail.com&quot;</span> <span class="hljs-number">900</span> 次，<span class="hljs-string">&quot;yahoo.com&quot;</span> <span class="hljs-number">50</span> 次，<span class="hljs-string">&quot;intel.mail.com&quot;</span> <span class="hljs-number">1</span> 次，<span class="hljs-string">&quot;wiki.org&quot;</span> <span class="hljs-number">5</span> 次。<br>而对于父域名，会访问 <span class="hljs-string">&quot;mail.com&quot;</span> <span class="hljs-number">900</span> + <span class="hljs-number">1</span> = <span class="hljs-number">901</span> 次，<span class="hljs-string">&quot;com&quot;</span> <span class="hljs-number">900</span> + <span class="hljs-number">50</span> + <span class="hljs-number">1</span> = <span class="hljs-number">951</span> 次，和 <span class="hljs-string">&quot;org&quot;</span> <span class="hljs-number">5</span> 次。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><p><code>1 &lt;= cpdomain.length &lt;= 100</code></p></li><li><p><code>1 &lt;= cpdomain[i].length &lt;= 100</code></p></li><li><p><code>cpdomain[i]</code> 会遵循 <code>&quot;repi d1i.d2i.d3i&quot;</code> 或 <code>&quot;repi d1i.d2i&quot;</code> 格式</p></li><li><p><code>repi</code> 是范围 <code>[1, 104]</code> 内的一个整数</p></li><li><p><code>d1i</code>、<code>d2i</code> 和 <code>d3i</code> 由小写英文字母组成</p></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h3><p>通过哈希表统计 <code>cpdomains</code> 中所有的子域名的频率。</p><p>以 <code>google.mail.com</code> 为例，<code>google.mail.com</code> 为三级域名，<code>mail.com</code> 为二级域名，<code>com</code>为顶级域名。</p><p>思路如下：</p><ol><li><p>遍历 <code>cpdomains</code> 列表，获取每一个 <code>cpdomain</code> 的访问次数 <code>cnt</code> 与其域名 <code>domain</code></p></li><li><p>将 <code>domain</code> 的访问次数累加至原哈希表</p></li><li><p>继续遍历 <code>domain</code>的子域名字符串</p></li><li><p>若 <code>domain[i] == &#39;.&#39;</code>，说明其之后为一个完整的子域名，将其访问次数累加到哈希表中。</p></li><li><p>遍历结束之后，将哈希表的 <code>K</code> 与 <code>V</code> 以列表的形式返回</p></li></ol><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subdomainVisits</span>(<span class="hljs-params">self, cpdomains: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        dic = defaultdict(<span class="hljs-built_in">int</span>)<br>        <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> cpdomains:<br>            ds = d.split()<br>            cnt, domain = <span class="hljs-built_in">int</span>(ds[<span class="hljs-number">0</span>]), ds[<span class="hljs-number">1</span>]<br>            dic[domain] += cnt<br>            <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(domain):<br>                <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;.&#x27;</span>:<br>                    dic[domain[i+<span class="hljs-number">1</span>:]] += cnt<br>        <span class="hljs-keyword">return</span> [<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;v&#125;</span> <span class="hljs-subst">&#123;k&#125;</span>&quot;</span> <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> dic.items()]<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第13篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 921. Minumum Add to Make Parentheses Valid</title>
    <link href="/2022/10/04/LC-Solution-921-Minumum-Add-to-Make-Parentheses-Valid/"/>
    <url>/2022/10/04/LC-Solution-921-Minumum-Add-to-Make-Parentheses-Valid/</url>
    
    <content type="html"><![CDATA[<h1 id="921-使括号有效的最少添加"><a href="#921-使括号有效的最少添加" class="headerlink" title="921. 使括号有效的最少添加"></a><a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/">921. 使括号有效的最少添加</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>只有满足下面几点之一，括号字符串才是有效的：</p><ul><li><p>它是一个空字符串，或者</p></li><li><p>它可以被写成 <code>AB</code> （<code>A</code> 与 <code>B</code> 连接）, 其中 <code>A</code> 和 <code>B</code> 都是有效字符串，或者</p></li><li><p>它可以被写作 <code>(A)</code>，其中 <code>A</code> 是有效字符串。</p></li></ul><p>给定一个括号字符串 <code>s</code> ，移动N次，你就可以在字符串的任何位置插入一个括号。</p><p>例如，如果 <code>s = &quot;()))&quot;</code> ，你可以插入一个开始括号为 <code>&quot;(()))&quot;</code> 或结束括号为 <code>&quot;())))&quot;</code> 。<br>返回 为使结果字符串 <code>s</code> 有效而必须添加的最少括号数。</p><p><strong>示例1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;())&quot;</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(((&quot;</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 字符。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：栈"><a href="#方法一：栈" class="headerlink" title="方法一：栈"></a>方法一：栈</h3><p>对于成对出现的括号题，合法的每一对括号是具有顺序的，可以直观地想到用栈解决。</p><p>将成对的括号移除出栈，最后栈中保留的一定是无法成对的括号数量，最终栈的大小即为需要添加的括号次数。</p><p>遍历字符串 <code>s</code>：</p><ul><li><p>若 <code>s[i] == &#39;(&#39;</code>，直接入栈。</p></li><li><p>若 <code>s[i] == &#39;)&#39;</code>，且当前栈不为空 and 栈顶元素为 <code>&#39;(&#39;</code>，说明此时构成了一对合法括号，可以将栈顶的 <code>&#39;(&#39;</code>出栈。若不满足此条件，则将 <code>s[i]</code> 入栈</p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minAddToMakeValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        q = deque() <br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                q.append(x)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> q[-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                    q.pop()<br>                <span class="hljs-keyword">else</span>:<br>                    q.append(x)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(q)<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minAddToMakeValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Character&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> x : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span>(x == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                d.addLast(x);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(!d.isEmpty() &amp;&amp; d.peekLast() == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    d.pollLast();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    d.addLast(x);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> d.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：模拟计数"><a href="#方法二：模拟计数" class="headerlink" title="方法二：模拟计数"></a>方法二：模拟计数</h3><p>根据题意进行模拟，用 <code>cnt</code> 表示 <code>&#39;(&#39;</code>的个数。</p><p>遍历字符串 <code>s</code></p><ul><li><p>若 <code>s[i] == &#39;(&#39;</code>，cnt++</p></li><li><p>若 <code>s[i] == &#39;)&#39;</code>，cnt–，相当于消除一个 <code>&#39;(&#39;</code></p><ul><li>若此时进行 <code>cnt--</code> 操作之后，cnt变为-1，说明 <code>&#39;(&#39;</code>数量不足，需要添加一个 <code>&#39;(&#39;</code>进行额外配对，并将 <code>cnt</code> 重新置为0</li></ul></li></ul><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minAddToMakeValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        cnt, ans = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                cnt -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cnt == -<span class="hljs-number">1</span>:<br>                cnt = <span class="hljs-number">0</span><br>                ans += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans + cnt<br></code></pre></td></tr></table></figure><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minAddToMakeValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> x : s.toCharArray()) &#123;<br>            cnt += x == <span class="hljs-string">&#x27;(&#x27;</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(cnt == -<span class="hljs-number">1</span>) &#123;<br>                cnt = <span class="hljs-number">0</span>;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans + cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第12篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 926. Flip String to Monotone Increasing</title>
    <link href="/2022/10/03/LC-Solution-926-Flip-String-to-Monotone-Increasing/"/>
    <url>/2022/10/03/LC-Solution-926-Flip-String-to-Monotone-Increasing/</url>
    
    <content type="html"><![CDATA[<h1 id="926-Flip-String-to-Monotone-Increasing"><a href="#926-Flip-String-to-Monotone-Increasing" class="headerlink" title="926. Flip String to Monotone Increasing"></a><a href="https://leetcode.cn/problems/flip-string-to-monotone-increasing/">926. Flip String to Monotone Increasing</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如果一个二进制字符串，是以一些 <code>0</code>（可能没有 <code>0</code>）后面跟着一些 <code>1</code>（也可能没有 <code>1</code>）的形式组成的，那么该字符串是 <strong>单调递增</strong> 的。</p><p>给你一个二进制字符串 <code>s</code>，你可以将任何 <code>0</code> 翻转为 <code>1</code> 或者将 <code>1</code> 翻转为 <code>0</code> 。</p><p>返回使 <code>s</code> 单调递增的最小翻转次数。</p><p><strong>示例1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;00110&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：翻转最后一位得到 <span class="hljs-number">00111</span>.<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;010110&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：翻转得到 <span class="hljs-number">011111</span>，或者是 <span class="hljs-number">000111</span>。<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;00011000&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：翻转得到 <span class="hljs-number">00000000</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：前缀和"><a href="#方法一：前缀和" class="headerlink" title="方法一：前缀和"></a>方法一：前缀和</h3><p>题目要求通过翻转 <code>0</code> 与 <code>1</code> 使得最后得到的二进制字符串为单调递增，</p><p>通过此可以想到：统计字符 <code>s[i]</code> 左边 <code>1</code> 数目，右边 <code>0</code> 的数目。将这些 <code>1</code> 与 <code>0</code> 翻转，最终的字符串 <code>s</code> 即可满足单调递增，翻转次数 &#x3D; 左边 <code>1</code> 的数目 + 右边 <code>0</code> 的数目</p><p>因此，该问题可以采用前缀和的思路解决。</p><ul><li><p>设置 <code>sum</code> 数组统计前缀和（长度为 <code>len(s) + 1</code> ）</p></li><li><p><code>sum[i]</code> 代表字符 <code>s[i]</code> 左边 <code>1</code> 的数目（不包含 <code>i</code> ）</p></li><li><p>通过 <code>sum[i]</code> 可计算得到 <code>s[i]</code> 右边 <code>0</code> 的数目（包含 <code>i</code>）</p><ul><li>右边 <code>0</code> 的数目为：<code>(len(s) - i) - (sum[len(s)] - sum[i])</code></li></ul></li></ul><p>遍历两次字符串 <code>s</code> ，求得最终答案</p><ul><li><p>第一次遍历：求得前缀和数组 <code>sum</code></p></li><li><p>第二次遍历：计算当前翻转次数（左边 <code>1</code> 的数目 + 右边 <code>0</code> 的数目）并与 <code>ans</code> 比较，取最小值。</p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minFlipsMonoIncr</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n, ans = <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-built_in">sum</span> = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-built_in">sum</span>[i] = <span class="hljs-built_in">sum</span>[i - <span class="hljs-number">1</span>] + (s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>):<br>            l_ones, r_zeros = <span class="hljs-built_in">sum</span>[i], n - i - (<span class="hljs-built_in">sum</span>[n] - <span class="hljs-built_in">sum</span>[i])<br>            ans = <span class="hljs-built_in">min</span>(ans, l_ones + r_zeros)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFlipsMonoIncr</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            sum[i] = sum[i - <span class="hljs-number">1</span>] + (cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftOnes</span> <span class="hljs-operator">=</span> sum[i], rightZeros = n - i - (sum[n] - sum[i]);<br>            ans = Math.min(ans, leftOnes + rightZeros);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：优化前缀和"><a href="#方法二：优化前缀和" class="headerlink" title="方法二：优化前缀和"></a>方法二：优化前缀和</h3><p>方法一种提到：</p><ul><li><p><code>s[i]</code> 左边 <code>1</code> 的数目为 <code>sum[i]</code></p></li><li><p><code>s[i]</code> 右边 <code>0</code> 的数目为 <code>(len(s) - i) - (sum[len(s)] - sum[i])</code></p></li><li><p>遍历一轮 <code>s</code>，二者求和的最小值即为答案</p></li></ul><p>即 <code>left_ones + right_zeros = 2 * sum[i] - i + len(s) - sum[len(s)]</code></p><p>因此，只需保证 <code>2 * sum[i] - i</code> 为最小值，然后求得所有 <code>1</code> 的数目，即可得到最终的翻转次数，采用常数级空间复杂度即可实现。</p><p>注意：根据之前的定义，这里 <code>i</code> 的最大值仍然为 <code>len(s)</code></p><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minFlipsMonoIncr</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n, ans, l_ones = <span class="hljs-built_in">len</span>(s), inf, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>):<br>            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-number">2</span> * l_ones - i)<br>            <span class="hljs-comment"># 防止越界</span><br>            <span class="hljs-keyword">if</span> i &lt; n:<br>                l_ones += s[i] == <span class="hljs-string">&#x27;1&#x27;</span><br>        <span class="hljs-keyword">return</span> ans + n - l_ones;<br></code></pre></td></tr></table></figure><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFlipsMonoIncr</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), ans = Integer.MAX_VALUE, leftOnes = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            ans = Math.min(ans, <span class="hljs-number">2</span> * leftOnes - i);<br>            <span class="hljs-keyword">if</span>(i &lt; n) &#123;<br>                leftOnes += s.charAt(i) == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans + n - leftOnes;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第11篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 881. Boats to Save People</title>
    <link href="/2022/10/03/LC-Solution-881-Boats-to-Save-People/"/>
    <url>/2022/10/03/LC-Solution-881-Boats-to-Save-People/</url>
    
    <content type="html"><![CDATA[<h1 id="881-救生艇"><a href="#881-救生艇" class="headerlink" title="881. 救生艇"></a><a href="https://leetcode.cn/problems/boats-to-save-people/">881. 救生艇</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定数组 <code>people</code> 。<code>people[i]</code>表示第 <code>i</code> 个人的体重 ，<strong>船的数量不限</strong>，每艘船可以承载的最大重量为 <code>limit</code>。</p><p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 <code>limit</code>。</p><p>返回 <em>承载所有人所需的最小船数</em> 。</p><p><strong>示例1：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：people = [1,2], <span class="hljs-built_in">limit</span> = 3<br>输出：1<br>解释：1 艘船载 (1, 2)<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：people = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], limit = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-number">3</span> 艘船分别载 <span class="hljs-comment">(1, 2)</span>, <span class="hljs-comment">(2)</span> 和 <span class="hljs-comment">(3)</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：people = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], limit = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">4</span><br>解释：<span class="hljs-number">4</span> 艘船分别载 <span class="hljs-comment">(3)</span>, <span class="hljs-comment">(3)</span>, <span class="hljs-comment">(4)</span>, <span class="hljs-comment">(5)</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= people.length &lt;= 5 * 104</code></li><li><code>1 &lt;= people[i] &lt;= limit &lt;= 3 * 104</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：贪心-双指针"><a href="#方法一：贪心-双指针" class="headerlink" title="方法一：贪心 + 双指针"></a>方法一：贪心 + 双指针</h3><p>通过分析题意可以得出以下几点关键的信息：</p><ol><li><p>可用船数不限制</p></li><li><p>每艘船限乘2人，每搜船限制总重为<code>limit</code></p></li><li><p>返回结果与<code>people</code>数组的顺序无关</p></li></ol><p>为使得使用的船数最少，每搜船上的两个人的总重量最好 <strong>等于或尽可能接近</strong> <code>limit</code></p><p>因此，不难得出本题的思路：对<code>people</code>数组进行升序排序，双指针遍历<code>people</code>数组。</p><p>需要注意的一点：双指针<code>i</code>与<code>j</code>重合时，此时只剩余一个人，所以他单独乘一艘船。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numRescueBoats</span>(<span class="hljs-params">self, people: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], limit: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        people.sort()<br>        i, j, ans = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(people) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt;= j:<br>            <span class="hljs-keyword">if</span> i == j:<br>                ans += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> people[i] + people[j] &lt;= limit:<br>                ans, i, j = ans + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                ans, j = ans + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numRescueBoats</span><span class="hljs-params">(<span class="hljs-type">int</span>[] people, <span class="hljs-type">int</span> limit)</span> &#123;<br>        Arrays.sort(people);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = people.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-keyword">if</span>(i == j) &#123;<br>                ans++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(people[i] + people[j] &lt;= limit) &#123;<br>                ans++; i++; j--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans++; j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第10篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1784 Check if Binary String Has at Most One Segment of Ones</title>
    <link href="/2022/10/03/LC-Solution-1784-Check-if-Binary-String-Has-at-Most-One-Segment-of-Ones/"/>
    <url>/2022/10/03/LC-Solution-1784-Check-if-Binary-String-Has-at-Most-One-Segment-of-Ones/</url>
    
    <content type="html"><![CDATA[<h1 id="1784-检查二进制字符串字段"><a href="#1784-检查二进制字符串字段" class="headerlink" title="1784. 检查二进制字符串字段"></a><a href="https://leetcode.cn/problems/check-if-binary-string-has-at-most-one-segment-of-ones/">1784. 检查二进制字符串字段</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二进制字符串 <code>s</code> ，该字符串 <strong>不含前导零</strong> 。</p><p>如果 <code>s</code> 包含 <strong>零个或一个由连续的 ‘1’ 组成的字段</strong> ，返回 <code>true</code>​​​ 。否则，返回 <code>false</code></p><p>如果 <code>s</code> 中 <strong>由连续若干个 ‘1’ 组成的字段 数量不超过 1</strong>，返回 <code>true</code>​​​ 。否则，返回 <code>false</code></p><p><strong>示例1：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;1001&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：由连续若干个 <span class="hljs-string">&#x27;1&#x27;</span> 组成的字段数量为 <span class="hljs-number">2</span>，返回 <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;110&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s[i]</code>​​​​ 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li><li><code>s[0]</code> 为 <code>&#39;1&#39;</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：简单模拟"><a href="#方法一：简单模拟" class="headerlink" title="方法一：简单模拟"></a>方法一：简单模拟</h3><p>题目已经明确给定<code>s[0] = &#39;1&#39;</code>，所以我们只需要找出<code>s</code>中的第一个字符<code>&#39;0&#39;</code>的下标。</p><ul><li><p>若字符串<code>s</code>中不存在<code>&#39;0&#39;</code>，那么一定全为<code>&#39;1&#39;</code>，返回<code>True</code></p></li><li><p>若字符串<code>s</code>中存在<code>&#39;0&#39;</code>，但是在它的后面不存在<code>&#39;1&#39;</code>，说明<code>s</code>中只有一个由连续的<code>&#39;1&#39;</code>组成的字段（因为<code>s[0] = &#39;1&#39;</code>），返回<code>True</code></p></li></ul><p>若不满足以上两点条件，直接返回<code>False</code></p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkOnesSegment</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        idx = s.find(<span class="hljs-string">&#x27;0&#x27;</span>)<br>        <span class="hljs-keyword">if</span> idx == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s[idx:]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>采用三元表达式写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkOnesSegment</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> s.find(<span class="hljs-string">&#x27;0&#x27;</span>) == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s[s.find(<span class="hljs-string">&#x27;0&#x27;</span>):] <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkOnesSegment</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> s.indexOf(<span class="hljs-string">&quot;0&quot;</span>);<br>        <span class="hljs-keyword">if</span>(idx == -<span class="hljs-number">1</span> || s.substring(idx).indexOf(<span class="hljs-string">&quot;1&quot;</span>) == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure><p>采用三元表达式写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkOnesSegment</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> s.indexOf(<span class="hljs-string">&quot;0&quot;</span>) == -<span class="hljs-number">1</span> || s.substring(s.indexOf(<span class="hljs-string">&quot;0&quot;</span>)).indexOf(<span class="hljs-string">&quot;1&quot;</span>) == -<span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第9篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 807. Max Increase to Keep City Skyline</title>
    <link href="/2022/10/03/LC-Solution-807-Max-Increase-to-Keep-City-Skyline/"/>
    <url>/2022/10/03/LC-Solution-807-Max-Increase-to-Keep-City-Skyline/</url>
    
    <content type="html"><![CDATA[<h1 id="807-保持城市天际线"><a href="#807-保持城市天际线" class="headerlink" title="807. 保持城市天际线"></a><a href="https://leetcode.cn/problems/max-increase-to-keep-city-skyline/">807. 保持城市天际线</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一座由 <code>n x n</code> 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 <strong>0</strong> 开始的 <code>n x n</code> 整数矩阵 <code>grid</code> ，其中 <code>grid[r][c]</code> 表示坐落于 <code>r</code> 行 <code>c</code> 列的建筑物的 <strong>高度</strong> 。</p><p>城市的 <strong>天际线</strong> 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 <strong>天际线</strong> 可能不同。</p><p>我们被允许为 <strong>任意数量的建筑物</strong> 的高度增加 <strong>任意增量（不同建筑物的增量可能不同）</strong> 。 高度为 0 的建筑物的高度也可以增加。然而，增加的建筑物高度 <strong>不能影响</strong> 从任何主要方向观察城市得到的 <strong>天际线</strong> 。</p><p>在 <strong>不改变</strong> 从任何主要方向观测到的城市 <strong>天际线</strong> 的前提下，返回建筑物可以增加的 <strong>最大高度增量总和</strong></p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：grid = <span class="hljs-comment">[<span class="hljs-comment">[3,0,8,4]</span>,<span class="hljs-comment">[2,4,5,7]</span>,<span class="hljs-comment">[9,2,6,3]</span>,<span class="hljs-comment">[0,3,1,0]</span>]</span><br>输出：35<br>解释：建筑物的高度如上图中心所示。<br>用红色绘制从不同方向观看得到的天际线。<br>在不影响天际线的情况下，增加建筑物的高度：<br>gridNew = <span class="hljs-comment">[ <span class="hljs-comment">[8, 4, 8, 7]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[7, 4, 7, 7]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[9, 4, 8, 7]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[3, 3, 3, 3]</span> ]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[0,0,0],[0,0,0],[0,0,0]]</span><br>输出：<span class="hljs-number">0</span><br>解释：增加任何建筑物的高度都会导致天际线的变化。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == grid.length</code></li><li><code>n == grid[r].length</code></li><li><code>2 &lt;= n &lt;= 50</code></li><li><code>0 &lt;= grid[r][c] &lt;= 100</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：贪心算法"><a href="#方法一：贪心算法" class="headerlink" title="方法一：贪心算法"></a>方法一：贪心算法</h3><p>分析题意不难得出，东南西北的视图即<code>天际线</code>是由每行每列的最大值决定的。</p><p>因此，每个建筑最终达到的高度不能超过其所在行与列的最大高度，更加具体地说，不能超过<code>min(该行最大高度, 该列最大高度)</code>。</p><ul><li><p>第一遍遍历：提前预处理出每一行与每一列对应的最大高度值</p></li><li><p>第二遍遍历：往<code>ans</code>结果中累加当前遍历的建筑可以增加的最大高度</p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxIncreaseKeepingSkyline</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans, n = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(grid)<br>        rowMax, colMax = [<span class="hljs-number">0</span>] * n, [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                rowMax[i] = <span class="hljs-built_in">max</span>(rowMax[i], grid[i][j])<br>                colMax[j] = <span class="hljs-built_in">max</span>(colMax[j], grid[i][j])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                ans += <span class="hljs-built_in">min</span>(rowMax[i], colMax[j]) - grid[i][j]<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxIncreaseKeepingSkyline</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span>[] rowMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], colMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                rowMax[i] = Math.max(rowMax[i], grid[i][j]);<br>                colMax[j] = Math.max(colMax[j], grid[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                ans += Math.min(rowMax[i], colMax[j]) - grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第8篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 781. Rabbits in Forest</title>
    <link href="/2022/10/03/LC-Solution-781-Rabbits-in-Forest/"/>
    <url>/2022/10/03/LC-Solution-781-Rabbits-in-Forest/</url>
    
    <content type="html"><![CDATA[<h1 id="781-森林中的兔子"><a href="#781-森林中的兔子" class="headerlink" title="781. 森林中的兔子"></a><a href="https://leetcode.cn/problems/rabbits-in-forest/">781. 森林中的兔子</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>森林中有未知数量的兔子。提问其中若干只兔子 “<strong>还有多少只兔子与你（指被提问的兔子）颜色相同?</strong>“ ，将答案收集到一个整数数组 <code>answers</code> 中，其中 <code>answers[i]</code> 是第 <code>i</code> 只兔子的回答。</p><p>给你数组 <code>answers</code> ，返回森林中兔子的最少数量。</p><p><strong>示例1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：answers = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">5</span><br>解释：<br>两只回答了 <span class="hljs-string">&quot;1&quot;</span> 的兔子可能有相同的颜色，设为红色。 <br>之后回答了 <span class="hljs-string">&quot;2&quot;</span> 的兔子不会是红色，否则他们的回答会相互矛盾。<br>设回答了 <span class="hljs-string">&quot;2&quot;</span> 的兔子为蓝色。 <br>此外，森林中还应有另外 <span class="hljs-number">2</span> 只蓝色兔子的回答没有包含在数组中。 <br>因此森林中兔子的最少数量是 <span class="hljs-number">5</span> 只：<span class="hljs-number">3</span> 只回答的和 <span class="hljs-number">2</span> 只没有回答的。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：answers </span>=<span class="hljs-string"> [10,10,10]</span><br><span class="hljs-string">输出：11</span><br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：找规律"><a href="#方法一：找规律" class="headerlink" title="方法一：找规律"></a>方法一：找规律</h3><p>举例分析：</p><ol><li><p>当数组为<code>[2, 2 ,2]</code>时，1种颜色 - 3只兔子</p></li><li><p>当数组为<code>[2, 2, 2, 2]</code>时，2种颜色 - 6只兔子（前三只兔子为一种颜色，最后一只兔子以及未被问到的另外两只不知名兔子为另一种颜色）</p></li><li><p>当数组为<code>[2, 2, 2, 2, 2, 2]</code>时，2种颜色 - 6只兔子（前三只兔子为一种颜色，后三只兔子为另一种颜色）</p></li><li><p>当数组为<code>[2, 2, 2, 2, 2, 2, 2]</code>时，3种颜色 - 9只兔子（1,2,3号兔子为色号1，4,5,6号兔子为色号2，7号兔子以及另外两只不知名兔子为色号3）</p></li><li><p>以此类推…</p></li></ol><p>经过分析，抽象为数学找规律的题目。</p><p>用哈希表统计同一个数字出现的频率。设<code>num</code>为哈希表的key，<code>freq</code>为哈希表的值。</p><p>将<code>freq</code>分为<code>freq // (num + 1)</code>个组，余数再单独分到另一个组。</p><p>举例：<code>[1, 1, 2, 2, 2, 2, 2]</code>数组统计存入哈希表后。一个键值对为<code>&#123;1: 2&#125;</code>，可以被分为<code>2 // (1 + 1) = 1</code>个组，正好整除。另一个键值对为<code>&#123;2: 4&#125;</code>，可以被分为<code>4 // (2 + 1) = 1</code>个组，剩余的2组成一个组。答案为每个键值对对应的组数乘以<code>num + 1</code>求和</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numRabbits</span>(<span class="hljs-params">self, answers: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        dic = Counter(answers)<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> num, freq <span class="hljs-keyword">in</span> dic.items():<br>            ans += freq // (num + <span class="hljs-number">1</span>) * (num + <span class="hljs-number">1</span>) <br>            <span class="hljs-keyword">if</span> freq % (num + <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>:<br>                ans += num + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第7篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 777. Swap Adjacent in LR String</title>
    <link href="/2022/10/03/LC-Solution-777-Swap-Adjacent-in-LR-String/"/>
    <url>/2022/10/03/LC-Solution-777-Swap-Adjacent-in-LR-String/</url>
    
    <content type="html"><![CDATA[<h1 id="777-在LR字符串中交换相邻字符"><a href="#777-在LR字符串中交换相邻字符" class="headerlink" title="777. 在LR字符串中交换相邻字符"></a><a href="https://leetcode.cn/problems/swap-adjacent-in-lr-string/">777. 在LR字符串中交换相邻字符</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个由 <code>&#39;L&#39;</code> , <code>&#39;R&#39;</code> 和 <code>&#39;X&#39;</code> 三个字符组成的字符串（例如<code>&quot;RXXLRXRXL&quot;</code>）中进行移动操作。一次移动操作指用一个<code>&quot;LX&quot;</code>替换一个<code>&quot;XL&quot;</code>，或者用一个<code>&quot;XR&quot;</code>替换一个<code>&quot;RX&quot;</code>。现给定起始字符串<code>start</code>和结束字符串<code>end</code>，请编写代码，当且仅当存在一系列移动操作使得<code>start</code>可以转换成<code>end</code>时， 返回<code>True</code>。</p><p><strong>示例：</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coq">输入: start = <span class="hljs-string">&quot;RXXLRXRXL&quot;</span>, <span class="hljs-keyword">end</span> = <span class="hljs-string">&quot;XRLXXRRLX&quot;</span><br>输出: True<br>解释:<br>我们可以通过以下几步将start转换成<span class="hljs-keyword">end</span>:<br>RXXLRXRXL -&gt;<br>XRXLRXRXL -&gt;<br>XRLXRXRXL -&gt;<br>XRLXXRRXL -&gt;<br>XRLXXRRLX<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= len(start) = len(end) &lt;= 10000</code>。</li><li><code>start</code>和<code>end</code>中的字符串仅限于<code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>和<code>&#39;X&#39;</code>。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h3><p>根据题意进行分析模拟，题目将每一个<code>XL</code>都替换成了<code>LX</code>，将每一个<code>RX</code>都替换成了<code>XR</code></p><p>通过找规律可发现，替换的过程可以理解为<code>L</code>与<code>R</code>移动的过程。</p><ul><li><p>当<code>L</code>的左边为<code>X</code>时，<code>L</code>可向左移动</p></li><li><p>当<code>R</code>的右边为<code>X</code>时，<code>R</code>可向右移动</p></li><li><p><code>L</code>与<code>R</code>无法互相穿过（因为<code>L</code>左和<code>R</code>右必须为<code>X</code>）</p><ul><li>可得知当<code>start</code>与<code>end</code>去掉<code>X</code>后，剩余字符必须相同，否则返回False</li></ul></li></ul><p>根据此规律，使用双指针<code>i</code>与<code>j</code>从头到尾遍历<code>start</code>与<code>end</code></p><p>找到<code>start</code>与<code>end</code>中<code>非X</code>的字符时则停止移动，进行判断</p><p>判断条件为：</p><ul><li><p>若<code>start[i] == L and i &lt; j</code>，又因<code>L</code>无法向右移动，直接返回False</p></li><li><p>若<code>start[i] == R and i &gt; j</code>，又因<code>R</code>无法向左移动，直接返回False</p></li></ul><p>当双指针遍历字符串结束后，说明中途未返回False，则最终返回True</p><p>注意：</p><p><code>if i != j and (start[i] == &#39;L&#39;) != (i &gt; j)</code>该行代码摘自<a href="https://leetcode.cn/u/endlesscheng/">灵山茶艾府</a>大佬的题解，相当于将两个<code>if</code>判断条件揉为一个，其本质为：</p><ul><li><p><code>if i &lt; j and start[i] == &#39;L&#39;: return False</code></p></li><li><p><code>if i &gt; j and start[i] == &#39;R&#39;: return False</code></p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canTransform</span>(<span class="hljs-params">self, start: <span class="hljs-built_in">str</span>, end: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> start.replace(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>) != end.replace(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        n = <span class="hljs-built_in">len</span>(start)<br>        i = j = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; n <span class="hljs-keyword">and</span> j &lt; n:<br>            <span class="hljs-keyword">while</span> i &lt; n <span class="hljs-keyword">and</span> start[i] == <span class="hljs-string">&#x27;X&#x27;</span>: i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> j &lt; n <span class="hljs-keyword">and</span> end[j] == <span class="hljs-string">&#x27;X&#x27;</span>: j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> i != j <span class="hljs-keyword">and</span> (start[i] == <span class="hljs-string">&#x27;L&#x27;</span>) != (i &gt; j): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            i, j = i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canTransform</span><span class="hljs-params">(String start, String end)</span> &#123;<br>        <span class="hljs-keyword">if</span>(!start.replace(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).equals(end.replace(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> start.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; j &lt; n) &#123;<br>            <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; start.charAt(i) == <span class="hljs-string">&#x27;X&#x27;</span>) i += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(j &lt; n &amp;&amp; end.charAt(j) == <span class="hljs-string">&#x27;X&#x27;</span>) j += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> ((i != j) &amp;&amp; ((start.charAt(i) == <span class="hljs-string">&#x27;L&#x27;</span>) != (i &gt; j))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            i++; j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第5篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1694. Reformat Phone Number</title>
    <link href="/2022/10/03/LC-Solution-1694-Reformat-Phone-Number/"/>
    <url>/2022/10/03/LC-Solution-1694-Reformat-Phone-Number/</url>
    
    <content type="html"><![CDATA[<h1 id="1694-重新格式化电话号码"><a href="#1694-重新格式化电话号码" class="headerlink" title="1694. 重新格式化电话号码"></a><a href="https://leetcode.cn/problems/reformat-phone-number/">1694. 重新格式化电话号码</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串形式的电话号码 <code>number</code> 。<code>number</code> 由数字、空格 <code>&#39; &#39;</code>、和破折号<code>&#39;-&#39;</code>组成。</p><p>请你按下述方式重新格式化电话号码。</p><ul><li><p>首先，删除 所有的空格和破折号。</p></li><li><p>其次，将数组从左到右 每 3 个一组 分块，直到 剩下 4 个或更少数字。剩下的数字将按下述规定再分块：</p><ul><li><p>2 个数字：单个含 2 个数字的块。</p></li><li><p>3 个数字：单个含 3 个数字的块。</p></li><li><p>4 个数字：两个分别含 2 个数字的块。</p></li></ul></li><li><p>最后用破折号将这些块连接起来。注意，重新格式化过程中 不应该 生成仅含 1 个数字的块，并且 最多 生成两个含 2 个数字的块。</p></li></ul><p>返回格式化后的电话号码。</p><p><strong>示例1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：number <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1-23-45 6&quot;</span><br>输出：<span class="hljs-string">&quot;123-456&quot;</span><br>解释：数字是 <span class="hljs-string">&quot;123456&quot;</span><br>步骤 <span class="hljs-number">1</span>：共有超过 <span class="hljs-number">4</span> 个数字，所以先取 <span class="hljs-number">3</span> 个数字分为一组。第 <span class="hljs-number">1</span> 个块是 <span class="hljs-string">&quot;123&quot;</span> 。<br>步骤 <span class="hljs-number">2</span>：剩下 <span class="hljs-number">3</span> 个数字，将它们放入单个含 <span class="hljs-number">3</span> 个数字的块。第 <span class="hljs-number">2</span> 个块是 <span class="hljs-string">&quot;456&quot;</span> 。<br>连接这些块后得到 <span class="hljs-string">&quot;123-456&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：number <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123 4-567&quot;</span><br>输出：<span class="hljs-string">&quot;123-45-67&quot;</span><br>解释：数字是 <span class="hljs-string">&quot;1234567&quot;</span>.<br>步骤 <span class="hljs-number">1</span>：共有超过 <span class="hljs-number">4</span> 个数字，所以先取 <span class="hljs-number">3</span> 个数字分为一组。第 <span class="hljs-number">1</span> 个块是 <span class="hljs-string">&quot;123&quot;</span> 。<br>步骤 <span class="hljs-number">2</span>：剩下 <span class="hljs-number">4</span> 个数字，所以将它们分成两个含 <span class="hljs-number">2</span> 个数字的块。这 <span class="hljs-number">2</span> 块分别是 <span class="hljs-string">&quot;45&quot;</span> 和 <span class="hljs-string">&quot;67&quot;</span> 。<br>连接这些块后得到 <span class="hljs-string">&quot;123-45-67&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：number <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123 4-5678&quot;</span><br>输出：<span class="hljs-string">&quot;123-456-78&quot;</span><br>解释：数字是 <span class="hljs-string">&quot;12345678&quot;</span> 。<br>步骤 <span class="hljs-number">1</span>：第 <span class="hljs-number">1</span> 个块 <span class="hljs-string">&quot;123&quot;</span> 。<br>步骤 <span class="hljs-number">2</span>：第 <span class="hljs-number">2</span> 个块 <span class="hljs-string">&quot;456&quot;</span> 。<br>步骤 <span class="hljs-number">3</span>：剩下 <span class="hljs-number">2</span> 个数字，将它们放入单个含 <span class="hljs-number">2</span> 个数字的块。第 <span class="hljs-number">3</span> 个块是 <span class="hljs-string">&quot;78&quot;</span> 。<br>连接这些块后得到 <span class="hljs-string">&quot;123-456-78&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：number <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12&quot;</span><br>输出：<span class="hljs-string">&quot;12&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例5：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：number = &quot;-<span class="hljs-string">-17</span><span class="hljs-string">-5</span> 229 35<span class="hljs-string">-39475</span> &quot;<br>输出：&quot;175<span class="hljs-string">-229</span><span class="hljs-string">-353</span><span class="hljs-string">-94</span><span class="hljs-string">-75</span>&quot;<br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：简单模拟"><a href="#方法一：简单模拟" class="headerlink" title="方法一：简单模拟"></a>方法一：简单模拟</h3><p>先预处理<code>number</code>字符串，去除字符串中除数字之外的字符。</p><p>定义<code>res</code>为字符串列表，其中的每一个字符串最终需要以<code>&#39;-&#39;</code>分割。</p><p>根据题意分析循环过程中的if条件（<code>i</code>表示当前遍历位置，<code>s</code>表示预处理后的字符串）：</p><ul><li><p>若当前位置<code>i + 4 == len(s)</code>，将<code>s[i:i+2]</code>与<code>s[i+2:i+4]</code>切片追加到<code>res</code>列表</p></li><li><p>否则，直接将<code>s[i:i+3]</code>切片追加到<code>res</code>列表</p><ul><li><p>这里隐藏了一点：<code>i + 2 == len(s)</code>的特殊情况已经考虑在else情况中：</p><ul><li>巧妙利用了Python的切片性质：右边界超出字符串长度时，直接将字符串长度作为右边界。</li></ul></li></ul></li></ul><p>理清模拟逻辑后，开始编写代码，注意循环的<code>step</code>为3，最后用<code>&#39;-&#39;</code>将res拼接。</p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reformatNumber</span>(<span class="hljs-params">self, number: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        s = number.replace(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>        res = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-number">3</span>):<br>            <span class="hljs-keyword">if</span> i + <span class="hljs-number">4</span> == <span class="hljs-built_in">len</span>(s):<br>                res.append(s[i:i + <span class="hljs-number">2</span>])<br>                res.append(s[i + <span class="hljs-number">2</span>:i + <span class="hljs-number">4</span>])   <br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                res.append(s[i: i + <span class="hljs-number">3</span>])<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;-&#x27;</span>.join(res)<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第4篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution Interview Questions 01.08</title>
    <link href="/2022/10/03/LC-Solution-Interview-Questions-01-08/"/>
    <url>/2022/10/03/LC-Solution-Interview-Questions-01-08/</url>
    
    <content type="html"><![CDATA[<h1 id="01-08-Zero-Matrix-LCCI"><a href="#01-08-Zero-Matrix-LCCI" class="headerlink" title="01.08. Zero Matrix LCCI"></a><a href="https://leetcode.cn/problems/zero-matrix-lcci/">01.08. Zero Matrix LCCI</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,1,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,0,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,1,1]</span></span><br><span class="hljs-comment">]</span><br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,0,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[0,0,0]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,0,1]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[0,1,2,0]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4,5,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3,1,5]</span></span><br><span class="hljs-comment">]</span><br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[0,0,0,0]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[0,4,5,0]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[0,3,1,0]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h3><p>题目要求当二维数组中的某个元素值为0时，将其所在的行和列的全部元素置为0。</p><p>通过分析题意，可以想到采用标记数组存储符合题意的行与列。</p><ul><li><p>第一次遍历：标记行与列</p></li><li><p>第二次遍历：对标记的行与列中的元素进行修改</p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setZeroes</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        row = [<span class="hljs-literal">False</span>] * <span class="hljs-built_in">len</span>(matrix)<br>        col = [<span class="hljs-literal">False</span>] * <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span>:<br>                    row[i] = col[j] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>                matrix[i][j] = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> row[i] == <span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> col[j] == <span class="hljs-literal">True</span> <span class="hljs-keyword">else</span> matrix[i][j]<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[] row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m], col = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    row[i] = col[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span>(row[i] == <span class="hljs-literal">true</span> || col[j] == <span class="hljs-literal">true</span>) &#123;<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第3篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 3. Longest Substring Without Repeating Characters</title>
    <link href="/2022/10/03/LC-Solution-3-Longest-Substring-Without-Repeating-Characters/"/>
    <url>/2022/10/03/LC-Solution-3-Longest-Substring-Without-Repeating-Characters/</url>
    
    <content type="html"><![CDATA[<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><h3 id="方法一：滑动窗口"><a href="#方法一：滑动窗口" class="headerlink" title="方法一：滑动窗口"></a>方法一：滑动窗口</h3><p>题目要求从给定字符串<code>s</code>中找出不包含重复字符的最长子串的长度</p><p>由于子串是连续的，可以想到采用滑动窗口解决该问题。</p><p>思路如下：</p><ul><li><p>采用双指针<code>i</code>与<code>j</code>作为滑动窗口的左端点与右端点，初始值为0</p></li><li><p>采用哈希表记录已经遍历过的字符。其<code>key</code>为字符本身，<code>value</code>为当前字符对应的下标</p></li><li><p>设<code>maxLen</code>为不包含重复字符的最长子串的长度</p></li><li><p>从头到尾遍历字符串<code>s</code></p><ol><li>判断哈希表是否存储当前字符<code>c</code></li></ol><ul><li><p>若哈希表已存储当前字符<code>c</code></p><ul><li><p>需要收缩滑动窗口，即更新滑动窗口左端点<code>i</code>的位置</p><ul><li><p>此时，左端点<code>i</code>有两种选择，第一种为保持<code>i</code>不变，第二种为将其更新为哈希表中当前字符<code>c</code>对应的下标再加1</p><ol><li><p>如果当前滑动窗口不包含当前字符<code>c</code>但哈希表中却存储着<code>c</code>，则需要选择第一种更新方案。例如<code>abba</code>字符串。</p></li><li><p>如果当前滑动窗口包含当前字符<code>c</code>，则需要选择第二种更新方案。例如<code>abca</code>字符串。</p></li></ol></li></ul><p>. 为综合以上两种更新方案，左端点<code>i</code>更新时区二者最大值即可。</p></li></ul></li></ul><ol start="2"><li><p>更新哈希表</p></li><li><p>比较当前滑动窗口长度与<code>maxLen</code>的大小，并为<code>maxLen</code>赋值</p></li><li><p>滑动窗口向右滑动，<code>j</code>自增</p></li></ol></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dic = defaultdict(<span class="hljs-built_in">int</span>)<br>        maxlen, left = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">in</span> dic:<br>                left = <span class="hljs-built_in">max</span>(dic[s[i]] + <span class="hljs-number">1</span>, left)<br>            dic[s[i]] = i<br>            maxlen = <span class="hljs-built_in">max</span>(maxlen, i - left + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> maxlen<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, curLen = <span class="hljs-number">0</span>;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            curLen++;<br>            <span class="hljs-keyword">while</span>(set.contains(s.charAt(i))) &#123;<br>                set.remove(s.charAt(left));<br>                left++;<br>                curLen--;<br>            &#125;<br>            maxLen = Math.max(curLen, maxLen);<br>            set.add(s.charAt(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第6篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 2. Add Two Nums</title>
    <link href="/2022/10/03/LC-Solution-2-Add-Two-Nums/"/>
    <url>/2022/10/03/LC-Solution-2-Add-Two-Nums/</url>
    
    <content type="html"><![CDATA[<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[2,4,3]</span>, l2 = <span class="hljs-comment">[5,6,4]</span><br>输出：<span class="hljs-comment">[7,0,8]</span><br>解释：342 + 465 = 807.<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[0]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：l1 = [<span class="hljs-number">9,9,9,9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>], l2 = [<span class="hljs-number">9,9,9,9</span>]<br>输出：[<span class="hljs-number">8,9,9,9</span>,<span class="hljs-number">0,0,0,1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：链表-数学-模拟"><a href="#方法一：链表-数学-模拟" class="headerlink" title="方法一：链表 + 数学 + 模拟"></a>方法一：链表 + 数学 + 模拟</h3><p>此题可直接理解为数学中的竖式相加</p><p>链表从左至右可以理解为从低位到高位，因此依次遍历链表，同一位置直接相加即可</p><p>设当前两个链表相同位置上的数分别为<code>x1</code>与<code>x2</code>，其进位值为<code>carry</code></p><p>进行相加之后，<code>sum</code>为<code>x1 + x2 + carry</code>，则</p><ul><li><p>结果链表的当前值<code>head.val = sum % 10</code>，添加至结果链表，链表前移</p></li><li><p>新的进位值<code>carry = sum // 10</code></p></li></ul><p>依次类推，继续前移链表节点，直至两链表遍历结束。</p><p>注意：遍历结束之后，需要判断最后的<code>carry</code>是否为1</p><ul><li>若最后的<code>carry == 1</code>，则说明需要再向上进一位</li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        res = head = <span class="hljs-literal">None</span><br>        carry = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2:<br>            v1 = l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            v2 = l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-built_in">sum</span> = v1 + v2 + carry<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res:<br>                res = head = ListNode(<span class="hljs-built_in">sum</span> % <span class="hljs-number">10</span>)<br>            <span class="hljs-keyword">else</span>:<br>                head.<span class="hljs-built_in">next</span> = ListNode(<span class="hljs-built_in">sum</span> % <span class="hljs-number">10</span>)<br>                head = head.<span class="hljs-built_in">next</span><br>            carry = <span class="hljs-built_in">sum</span> // <span class="hljs-number">10</span><br>            <span class="hljs-keyword">if</span> l1:<br>                l1 = l1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> l2:<br>                l2 = l2.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">if</span> carry &gt; <span class="hljs-number">0</span>:<br>            head.<span class="hljs-built_in">next</span> = ListNode(carry)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, head = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> v1 + v2 + carry;<br>            <span class="hljs-keyword">if</span>(res == <span class="hljs-literal">null</span>) &#123;<br>                res = head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                head.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>                head = head.next;<br>            &#125;<br>            carry = sum / <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">null</span>) l1 = l1.next;<br>            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">null</span>) l2 = l2.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry &gt; <span class="hljs-number">0</span>) &#123;<br>            head.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第2篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1. Two Sum</title>
    <link href="/2022/10/03/LC-Solution-1-Two-Sum/"/>
    <url>/2022/10/03/LC-Solution-1-Two-Sum/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1.两数之和</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重lt复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p>进阶：你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h3><p>对数组进行遍历，用哈希表存放数组值及其对应的下标值。</p><ul><li><code>key</code> &#x3D;&gt; 元素值， <code>value</code> &#x3D;&gt; 元素值对应的下标值</li></ul><p>当发现<code>target - nums[i]</code> 即 <code>目标值与当前值之差</code> 是否在哈希表中出现过</p><ul><li><p>若出现过，则说明找到了目标值，直接返回即可</p></li><li><p>若未出现，继续遍历</p></li></ul><p>核心思路为<code>空间换时间</code>，若不采用哈希表，则双重for循环朴素解法时间复杂度为<code>O(n^2)</code></p><p>在循环遍历的过程中确定<code>nums[i]</code>为当前数，然后在哈希表中查找该数之前是否存在一个数为<code>target - nums[i]</code>。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], t: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        dic = defaultdict(<span class="hljs-built_in">int</span>)<br>        <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            x = t - v<br>            <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> dic:<br>                <span class="hljs-keyword">return</span> [dic[x], i]<br>            dic[v] = i<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> t) &#123;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(t - nums[i])) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;map.get(t - nums[i]), i&#125;;<br>            map.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第1篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
