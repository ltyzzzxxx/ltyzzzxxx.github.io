<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LC Solution 1668. Maximum Repeating Substring</title>
    <link href="/2022/11/03/LC-Solution-1668-Maximum-Repeating-Substring/"/>
    <url>/2022/11/03/LC-Solution-1668-Maximum-Repeating-Substring/</url>
    
    <content type="html"><![CDATA[<h1 id="1668-最大重复子字符串"><a href="#1668-最大重复子字符串" class="headerlink" title="1668. 最大重复子字符串"></a><a href="https://leetcode.cn/problems/maximum-repeating-substring/">1668. 最大重复子字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 <code>sequence</code> ，如果字符串 <code>word</code> 连续重复 <code>k</code> 次形成的字符串是 <code>sequence</code> 的一个子字符串，那么单词 <code>word</code> 的 <strong>重复值为 <code>k</code></strong> 。单词 <code>word</code> 的 <strong>最****大重复值</strong> 是单词 <code>word</code> 在 <code>sequence</code> 中最大的重复值。如果 <code>word</code> 不是 <code>sequence</code> 的子串，那么重复值 <code>k</code> 为 <code>0</code> 。</p><p>给你一个字符串 <code>sequence</code> 和 <code>word</code> ，请你返回 <strong>最大重复值 <code>k</code></strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：sequence = <span class="hljs-string">&quot;ababc&quot;</span>, <span class="hljs-built_in">word</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-string">&quot;abab&quot;</span> 是 <span class="hljs-string">&quot;ababc&quot;</span> 的子字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：sequence = <span class="hljs-string">&quot;ababc&quot;</span>, <span class="hljs-built_in">word</span> = <span class="hljs-string">&quot;ba&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：<span class="hljs-string">&quot;ba&quot;</span> 是 <span class="hljs-string">&quot;ababc&quot;</span> 的子字符串，但 <span class="hljs-string">&quot;baba&quot;</span> 不是 <span class="hljs-string">&quot;ababc&quot;</span> 的子字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：sequence = <span class="hljs-string">&quot;ababc&quot;</span>, <span class="hljs-built_in">word</span> = <span class="hljs-string">&quot;ac&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-string">&quot;ac&quot;</span> 不是 <span class="hljs-string">&quot;ababc&quot;</span> 的子字符串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= sequence.length &lt;= 100</code></li><li><code>1 &lt;= word.length &lt;= 100</code></li><li><code>sequence</code> 和 <code>word</code> 都只包含小写英文字母。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h3><p>题目要求当 <code>word</code> 重复出现 <code>k</code> 次时形成的字符串为 <code>sequence</code> 的子字符串。要求返回最大的 <code>k</code> 值。</p><p>我们可以假设理想情况下，即 <code>word</code> 重复 <code>k</code> 次之后与 <code>sequence</code> 相同。</p><p>不难得出：理想情况下，当 <code>k</code> 最大时，应当满足 <code>ceil(len(word) * k) == len(sequence)</code>。其中 <code>ceil</code> 表示向上取整。</p><p>因此，我们可以先通过 <code>len(sequence) // len(word)</code> 求得初始理论上最大的 <code>k</code>，然后循环递减 <code>k</code>，直到 <code>word</code> 重复 <code>k</code> 次后形成的字符串为 <code>sequence</code> 的子字符串</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python3">class Solution:<br>    def maxRepeating(self, sequence: str, word: str) -&gt; int:<br>        s_len, w_len = len(sequence), len(word)<br>        cnt = s_len // w_len<br>        while cnt:<br>            if sequence.find(word * cnt) != -1:<br>                return cnt<br>            cnt -= 1<br>        return 0<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxRepeating</span><span class="hljs-params">(String sequence, String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sLen</span> <span class="hljs-operator">=</span> sequence.length(), wLen = word.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> sLen / wLen;<br>        <span class="hljs-keyword">while</span>(cnt &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">repeatWord</span> <span class="hljs-operator">=</span> repeatK(word, cnt);<br>            <span class="hljs-keyword">if</span>(sequence.indexOf(repeatWord) != -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> cnt;<br>            &#125;<br>            cnt--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">repeatK</span><span class="hljs-params">(String word, <span class="hljs-type">int</span> cnt)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cnt; i++) &#123;<br>            sb.append(word);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxRepeating</span><span class="hljs-params">(sequence <span class="hljs-type">string</span>, word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sLen, wLen := <span class="hljs-built_in">len</span>(sequence), <span class="hljs-built_in">len</span>(word)<br>    cnt := sLen / wLen<br>    <span class="hljs-keyword">for</span> cnt &gt; <span class="hljs-number">0</span> &#123;<br>        repeatWord := repeatK(word, cnt)<br>        <span class="hljs-keyword">if</span> strings.Contains(sequence, repeatWord) &#123;<br>            <span class="hljs-keyword">return</span> cnt<br>        &#125;<br>        cnt--<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">repeatK</span><span class="hljs-params">(word <span class="hljs-type">string</span>, cnt <span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; cnt; i++ &#123;<br>        ans += word<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第34篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC Solution 1620. Coordinate With Maximum Network Quality</title>
    <link href="/2022/11/02/LC-Solution-1620-Coordinate-With-Maximum-Network-Quality/"/>
    <url>/2022/11/02/LC-Solution-1620-Coordinate-With-Maximum-Network-Quality/</url>
    
    <content type="html"><![CDATA[<h1 id="1620-网络信号最好的坐标"><a href="#1620-网络信号最好的坐标" class="headerlink" title="1620. 网络信号最好的坐标"></a><a href="https://leetcode.cn/problems/coordinate-with-maximum-network-quality/">1620. 网络信号最好的坐标</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个数组 <code>towers</code> 和一个整数 <code>radius</code> 。</p><p>数组 <code>towers</code> 中包含一些网络信号塔，其中 <code>towers[i] = [xi, yi, qi]</code> 表示第 <code>i</code> 个网络信号塔的坐标是 <code>(xi, yi)</code> 且信号强度参数为 <code>qi</code> 。所有坐标都是在 X-Y 坐标系内的 <strong>整数</strong> 坐标。两个坐标之间的距离用 <strong>欧几里得距离</strong> 计算。</p><p>整数 <code>radius</code> 表示一个塔 <strong>能到达</strong> 的 <strong>最远距离</strong> 。如果一个坐标跟塔的距离在 <code>radius</code> 以内，那么该塔的信号可以到达该坐标。在这个范围以外信号会很微弱，所以 <code>radius</code> 以外的距离该塔是 <strong>不能到达的</strong> 。</p><p>如果第 <code>i</code> 个塔能到达 <code>(x, y)</code> ，那么该塔在此处的信号为 <code>⌊qi / (1 + d)⌋</code> ，其中 <code>d</code> 是塔跟此坐标的距离。一个坐标的 <strong>信号强度</strong> 是所有 <strong>能到达</strong> 该坐标的塔的信号强度之和。</p><p>请你返回数组 <code>[cx, cy]</code> ，表示 <strong>信号强度</strong> 最大的 <strong>整数</strong> 坐标点 <code>(cx, cy)</code> 。如果有多个坐标网络信号一样大，请你返回字典序最小的 <strong>非负</strong> 坐标。</p><p><strong>注意：</strong></p><ul><li>坐标 <code>(x1, y1)</code> 字典序比另一个坐标 <code>(x2, y2)</code> 小，需满足以下条件之一：<ul><li>要么 <code>x1 &lt; x2</code> ，</li><li>要么 <code>x1 == x2</code> 且 <code>y1 &lt; y2</code> 。</li></ul></li><li><code>⌊val⌋</code> 表示小于等于 <code>val</code> 的最大整数（向下取整函数）。</li></ul><p>示例 1：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：towers = <span class="hljs-string">[[1,2,5],[2,1,7],[3,1,9]]</span>, radius = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>解释：<br>坐标 (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) 信号强度之和为 <span class="hljs-number">13</span><br>- 塔 (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) 强度参数为 <span class="hljs-number">7</span> ，在该点强度为 ⌊<span class="hljs-number">7</span> / (<span class="hljs-number">1</span> + <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">0</span>)⌋ = ⌊<span class="hljs-number">7</span>⌋ = <span class="hljs-number">7</span><br>- 塔 (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) 强度参数为 <span class="hljs-number">5</span> ，在该点强度为 ⌊<span class="hljs-number">5</span> / (<span class="hljs-number">1</span> + <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>)⌋ = ⌊<span class="hljs-number">2.07</span>⌋ = <span class="hljs-number">2</span><br>- 塔 (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>) 强度参数为 <span class="hljs-number">9</span> ，在该点强度为 ⌊<span class="hljs-number">9</span> / (<span class="hljs-number">1</span> + <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span>)⌋ = ⌊<span class="hljs-number">4.5</span>⌋ = <span class="hljs-number">4</span><br>没有别的坐标有更大的信号强度。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：towers = <span class="hljs-string">[[23,11,21]]</span>, radius = <span class="hljs-number">9</span><br>输出：[<span class="hljs-number">23</span>,<span class="hljs-number">11</span>]<br>解释：由于仅存在一座信号塔，所以塔的位置信号强度最大。<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：towers = <span class="hljs-comment">[<span class="hljs-comment">[1,2,13]</span>,<span class="hljs-comment">[2,1,7]</span>,<span class="hljs-comment">[0,1,9]</span>]</span>, radius = 2<br>输出：<span class="hljs-comment">[1,2]</span><br>解释：坐标 (1, 2) 的信号强度最大。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= towers.length &lt;= 50</code></li><li><code>towers[i].length == 3</code></li><li><code>0 &lt;= xi, yi, qi &lt;= 50</code></li><li><code>1 &lt;= radius &lt;= 50</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：枚举"><a href="#方法一：枚举" class="headerlink" title="方法一：枚举"></a>方法一：枚举</h3><p>题目要求找到一个坐标，使得该点到所有信号塔的信号强度之和最大。</p><p>题目给出的坐标范围最小为 <code>(0, 0)</code>，最大为 <code>(50, 50)</code>，而灯塔数量最多为50。即使采用三重 <code>for</code> 循环去遍历求解，计算次数也不会超过10e8，不存在TLE问题。因此选择枚举求解。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python3">class Solution:<br>    def bestCoordinate(self, towers: List[List[int]], radius: int) -&gt; List[int]:<br>        max_v = 0<br>        ans = [0, 0]<br>        for i in range(51):<br>            for j in range(51):<br>                cur = 0<br>                for x, y, q in towers:<br>                    d = ((x - i) ** 2 + (y - j) ** 2) ** 0.5<br>                    if d &lt;= radius:<br>                        cur += floor(q / (1 + d))<br>                if cur &gt; max_v:<br>                    ans = [i, j]<br>                    max_v = cur<br>        return ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] bestCoordinate(<span class="hljs-type">int</span>[][] towers, <span class="hljs-type">int</span> radius) &#123;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">50</span>; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] v : towers) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> v[<span class="hljs-number">0</span>], y = v[<span class="hljs-number">1</span>], q = v[<span class="hljs-number">2</span>];<br>                    <span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> Math.sqrt((x - i) * (x - i) + (y - j) * (y - j));<br>                    <span class="hljs-keyword">if</span>(d &lt;= radius) &#123;<br>                        cur += (<span class="hljs-type">int</span>)(q / (<span class="hljs-number">1</span> + d));<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(max &lt; cur) &#123;<br>                    ans[<span class="hljs-number">0</span>] = i; ans[<span class="hljs-number">1</span>] = j;<br>                    max = cur;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bestCoordinate</span><span class="hljs-params">(towers [][]<span class="hljs-type">int</span>, radius <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    ans := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br>    max := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">50</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">50</span>; j++ &#123;<br>            cur := <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> towers &#123;<br>                x, y, q := v[<span class="hljs-number">0</span>], v[<span class="hljs-number">1</span>], v[<span class="hljs-number">2</span>]<br>                d := math.Sqrt(<span class="hljs-type">float64</span>((x - i) * (x - i) + (y - j) * (y - j)))<br>                <span class="hljs-keyword">if</span> d &lt;= <span class="hljs-type">float64</span>(radius) &#123;<br>                    cur += <span class="hljs-type">int</span>(<span class="hljs-type">float64</span>(q) / (<span class="hljs-number">1</span> + d))<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> cur &gt; max &#123;<br>                max = cur<br>                ans[<span class="hljs-number">0</span>] = i<br>                ans[<span class="hljs-number">1</span>] = j<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第33篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC Solution 784. Letter Case Permutation</title>
    <link href="/2022/10/30/LC-Solution-784-Letter-Case-Permutation/"/>
    <url>/2022/10/30/LC-Solution-784-Letter-Case-Permutation/</url>
    
    <content type="html"><![CDATA[<h1 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a><a href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 <code>s</code> ，通过将字符串 <code>s</code> 中的每个字母转变大小写，我们可以获得一个新的字符串。</p><p>返回 <em>所有可能得到的字符串集合</em> 。以 <strong>任意顺序</strong> 返回输出。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;a1b2&quot;</span><br>输出：[<span class="hljs-string">&quot;a1b2&quot;</span>, <span class="hljs-string">&quot;a1B2&quot;</span>, <span class="hljs-string">&quot;A1b2&quot;</span>, <span class="hljs-string">&quot;A1B2&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: s = <span class="hljs-string">&quot;3z4&quot;</span><br>输出: [<span class="hljs-string">&quot;3z4&quot;</span>,<span class="hljs-string">&quot;3Z4&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 12</code></li><li><code>s</code> 由小写英文字母、大写英文字母和数字组成</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h3><p>遇到全排列问题时，第一反应便是回溯解决。</p><p>题目要求遇到字母时，将其转换为大写或者小写字母，从而得到新的字符串。</p><p>从中可以想到，可以构造一个二叉树，二叉树的深度便是字符串 <code> s</code> 中字母的数量。每个父节点是当前的字母，其两个子节点对应下一个字母的大小写。</p><p>构造回溯方法，其包含三个参数，第一个参数为题目给定的字符串 <code>s</code>， 第二个参数为当前正在构造的字符串 <code>cur</code>，第三个参数记录下标位置。遍历到的字符若为数字，则跳到下一位置；若为字母，则分别对字母的大小写进行递归遍历。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCasePermutation</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">s, cur, begin</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cur) == <span class="hljs-built_in">len</span>(s):<br>                ans.append(cur)<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">if</span> s[begin].isalpha():<br>                traverse(s, cur + s[begin].swapcase(), begin + <span class="hljs-number">1</span>)<br>            traverse(s, cur + s[begin], begin + <span class="hljs-number">1</span>)<br>        ans = []<br>        traverse(s, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; ans;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCasePermutation</span><span class="hljs-params">(String s)</span> &#123;<br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        traverse(s, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(String s, String cur, <span class="hljs-type">int</span> begin)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s.length() == cur.length()) &#123;<br>            ans.add(cur);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        traverse(s, cur + s.charAt(begin), begin + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(Character.isLetter(s.charAt(begin))) &#123;<br>            traverse(s, cur + (<span class="hljs-type">char</span>)(s.charAt(begin) ^ <span class="hljs-number">32</span>), begin + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">letterCasePermutation</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(<span class="hljs-type">string</span>, <span class="hljs-type">string</span>, <span class="hljs-type">int</span>)</span></span><br>    f = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>, cur <span class="hljs-type">string</span>, begin <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-built_in">len</span>(cur) &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, cur)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        f(s, cur + <span class="hljs-type">string</span>(s[begin]), begin + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> unicode.IsLetter(<span class="hljs-type">rune</span>(s[begin])) &#123;<br>            f(s, cur + <span class="hljs-type">string</span>(s[begin] ^ <span class="hljs-number">32</span>), begin + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    f(s, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第32篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC Solution 915. Partition Array into Disjoint Intervals</title>
    <link href="/2022/10/24/LC-Solution-915-Partition-Array-into-Disjoint-Intervals/"/>
    <url>/2022/10/24/LC-Solution-915-Partition-Array-into-Disjoint-Intervals/</url>
    
    <content type="html"><![CDATA[<h1 id="915-分割数组"><a href="#915-分割数组" class="headerlink" title="915. 分割数组"></a><a href="https://leetcode.cn/problems/partition-array-into-disjoint-intervals/">915. 分割数组</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 <code>nums</code> ，将其划分为两个连续子数组 <code>left</code> 和 <code>right</code>， 使得：</p><ul><li><code>left</code> 中的每个元素都小于或等于 <code>right</code> 中的每个元素。</li><li><code>left</code> 和 <code>right</code> 都是非空的。</li><li><code>left</code> 的长度要尽可能小。</li></ul><p><em>在完成这样的分组后返回 <code>left</code> 的 <strong>长度</strong></em> 。</p><p>用例可以保证存在这样的划分方法。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,0,3,8,6]</span><br>输出：3<br>解释：left = <span class="hljs-comment">[5,0,3]</span>，right = <span class="hljs-comment">[8,6]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,1,0,6,12]</span><br>输出：4<br>解释：left = <span class="hljs-comment">[1,1,1,0]</span>，right = <span class="hljs-comment">[6,12]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 106</code></li><li>可以保证至少有一种方法能够按题目所描述的那样对 <code>nums</code> 进行划分。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案一：前缀与后缀"><a href="#方案一：前缀与后缀" class="headerlink" title="方案一：前缀与后缀"></a>方案一：前缀与后缀</h3><p>分析题意，核心思想就是找出分界点，且该分界点满足：<strong>左侧子数组的最大值</strong> 小于等于 <strong>右侧子数组的最小值</strong></p><p>而且根据题目数据量 <code>10e5</code> 可知，无法使用O(n2)复杂度的算法即暴力解法。</p><p>据此便想到：两次遍历统计前缀子数组的最大值与后缀子数组的最小值，分别记录在两个数组中。最后再遍历一次统计好的数组，找出分界点。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partitionDisjoint</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:    <br>        n = <span class="hljs-built_in">len</span>(nums)<br>        min_nums, max_nums = [<span class="hljs-number">0</span>] * n, [<span class="hljs-number">0</span>] * n <span class="hljs-comment"># 初始化前后缀数组</span><br>        min_num, max_num = <span class="hljs-number">10</span> ** <span class="hljs-number">7</span>, -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            max_num = <span class="hljs-built_in">max</span>(nums[i], max_num)<br>            max_nums[i] = max_num<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            min_num = <span class="hljs-built_in">min</span>(nums[i], min_num)<br>            min_nums[i] = min_num<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># 小于等于的情况下，找到第一个满足的分界点，题目要求left尽可能小，于是直接返回</span><br>            <span class="hljs-keyword">if</span> max_nums[i] &lt;= min_nums[i + <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partitionDisjoint</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] minNums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], maxNums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minNum</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE, maxNum = Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            maxNum = Math.max(nums[i], maxNum);<br>            maxNums[i] = maxNum;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            minNum = Math.min(nums[i], minNum);<br>            minNums[i] = minNum;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(maxNums[i] &lt;= minNums[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partitionDisjoint</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    minNums, maxNums := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n), <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    minNum, maxNum := math.MaxInt32, <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] &gt; maxNum &#123;<br>            maxNum = nums[i]<br>        &#125;<br>        maxNums[i] = maxNum<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> nums[i] &lt; minNum &#123;<br>            minNum = nums[i]<br>        &#125;<br>        minNums[i] = minNum<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> maxNums[i] &lt;= minNums[i + <span class="hljs-number">1</span>] &#123;<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方案二：优化前缀与后缀"><a href="#方案二：优化前缀与后缀" class="headerlink" title="方案二：优化前缀与后缀"></a>方案二：优化前缀与后缀</h3><p>我们可以在第一次遍历的时候，统计后缀子数组的最小值，将其保存在一个数组中。</p><p>第二次从前向后遍历，一边保存当前前缀子数组的最大值，一边判断并寻找分界点。</p><p>优化之后，时间效率上可以提升25%左右。</p><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partitionDisjoint</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:    <br>        n = <span class="hljs-built_in">len</span>(nums)<br>        min_nums = [<span class="hljs-number">0</span>] * n<br>        min_num, max_num = <span class="hljs-number">10</span> ** <span class="hljs-number">7</span>, -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            min_num = <span class="hljs-built_in">min</span>(nums[i], min_num)<br>            min_nums[i] = min_num<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>            max_num = <span class="hljs-built_in">max</span>(nums[i], max_num)<br>            <span class="hljs-keyword">if</span> max_num &lt;= min_nums[i + <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partitionDisjoint</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] minNums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minNum</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE, maxNum = Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            minNum = Math.min(nums[i], minNum);<br>            minNums[i] = minNum;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            maxNum = Math.max(nums[i], maxNum);<br>            <span class="hljs-keyword">if</span>(maxNum &lt;= minNums[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partitionDisjoint</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    minNums := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    minNum, maxNum := math.MaxInt32, <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> nums[i] &lt; minNum &#123;<br>            minNum = nums[i]<br>        &#125;<br>        minNums[i] = minNum<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] &gt; maxNum &#123;<br>            maxNum = nums[i]<br>        &#125;<br>        <span class="hljs-keyword">if</span> maxNum &lt;= minNums[i + <span class="hljs-number">1</span>] &#123;<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第31篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC Solution 1768. Merge Strings Alternately</title>
    <link href="/2022/10/23/LC-Solution-1768-Merge-Strings-Alternately/"/>
    <url>/2022/10/23/LC-Solution-1768-Merge-Strings-Alternately/</url>
    
    <content type="html"><![CDATA[<h1 id="1768-交替合并字符串"><a href="#1768-交替合并字符串" class="headerlink" title="1768. 交替合并字符串"></a><a href="https://leetcode.cn/problems/merge-strings-alternately/">1768. 交替合并字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个字符串 <code>word1</code> 和 <code>word2</code> 。请你从 <code>word1</code> 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。</p><p>返回 <strong>合并后的字符串</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：word1 = <span class="hljs-string">&quot;abc&quot;</span>, word2 = <span class="hljs-string">&quot;pqr&quot;</span><br>输出：<span class="hljs-string">&quot;apbqcr&quot;</span><br>解释：字符串合并情况如下所示：<br>word1：  <span class="hljs-selector-tag">a</span>   <span class="hljs-selector-tag">b</span>   c<br>word2：    <span class="hljs-selector-tag">p</span>   <span class="hljs-selector-tag">q</span>   r<br>合并后：  <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">q</span> c r<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：word1 = <span class="hljs-string">&quot;ab&quot;</span>, word2 = <span class="hljs-string">&quot;pqrs&quot;</span><br>输出：<span class="hljs-string">&quot;apbqrs&quot;</span><br>解释：注意，word2 比 word1 长，<span class="hljs-string">&quot;rs&quot;</span> 需要追加到合并后字符串的末尾。<br>word1：  <span class="hljs-selector-tag">a</span>   <span class="hljs-selector-tag">b</span> <br>word2：    <span class="hljs-selector-tag">p</span>   <span class="hljs-selector-tag">q</span>   r   s<br>合并后：  <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">q</span>   r   s<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：word1 = <span class="hljs-string">&quot;abcd&quot;</span>, word2 = <span class="hljs-string">&quot;pq&quot;</span><br>输出：<span class="hljs-string">&quot;apbqcd&quot;</span><br>解释：注意，word1 比 word2 长，<span class="hljs-string">&quot;cd&quot;</span> 需要追加到合并后字符串的末尾。<br>word1：  <span class="hljs-selector-tag">a</span>   <span class="hljs-selector-tag">b</span>   c   d<br>word2：    <span class="hljs-selector-tag">p</span>   <span class="hljs-selector-tag">q</span> <br>合并后：  <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">q</span> c   d<br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：简单模拟"><a href="#方法一：简单模拟" class="headerlink" title="方法一：简单模拟"></a>方法一：简单模拟</h3><p>根据题意，从 <code>word1</code> 与 <code>word2</code> 中获取每一位字符，拼接到结果字符串中。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><p>普通解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeAlternately</span>(<span class="hljs-params">self, word1: <span class="hljs-built_in">str</span>, word2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        ans = []<br>        n = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">len</span>(word1), <span class="hljs-built_in">len</span>(word2))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            ans.append(word1[i])<br>            ans.append(word2[i])<br>        ans = <span class="hljs-string">&quot;&quot;</span>.join(ans)<br>        <span class="hljs-keyword">return</span> ans + word1[n:] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(word1) &gt; <span class="hljs-built_in">len</span>(word2) <span class="hljs-keyword">else</span> ans + word2[n:]<br></code></pre></td></tr></table></figure><p>一行解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeAlternately</span>(<span class="hljs-params">self, word1: <span class="hljs-built_in">str</span>, word2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(a + b <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> zip_longest(word1, word2, fillvalue=<span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">mergeAlternately</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> word1.length(), n2 = word2.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n1 || i &lt; n2; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i &lt; n1) ans.append(word1.charAt(i));<br>            <span class="hljs-keyword">if</span>(i &lt; n2) ans.append(word2.charAt(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeAlternately</span><span class="hljs-params">(word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">0</span>)<br>    n1, n2 := <span class="hljs-built_in">len</span>(word1), <span class="hljs-built_in">len</span>(word2)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n1 || i &lt; n2; i++ &#123;<br>        <span class="hljs-keyword">if</span> i &lt; n1 &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, word1[i])<br>        &#125;<br>        <span class="hljs-keyword">if</span> i &lt; n2 &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, word2[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(ans)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第30篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解JDK锁02:AQS</title>
    <link href="/2022/10/21/%E8%AF%A6%E8%A7%A3JDK%E9%94%8102%EF%BC%9AAQS/"/>
    <url>/2022/10/21/%E8%AF%A6%E8%A7%A3JDK%E9%94%8102%EF%BC%9AAQS/</url>
    
    <content type="html"><![CDATA[<h1 id="详解JDK锁02：AQS"><a href="#详解JDK锁02：AQS" class="headerlink" title="详解JDK锁02：AQS"></a>详解JDK锁02：AQS</h1><h2 id="1-AQS简述"><a href="#1-AQS简述" class="headerlink" title="1.  AQS简述"></a>1.  AQS简述</h2><p>这一部分，我将从是什么、干什么、怎么用三个角度简单讲述一下AQS</p><h3 id="1-1-是什么？"><a href="#1-1-是什么？" class="headerlink" title="1.1 是什么？"></a>1.1 是什么？</h3><p>AQS全称为AbstractQueuedSynchronizer，中文名称为队列同步器。</p><p>拆分一下中文就可知，一定离不开 <strong>队列</strong> 与 <strong>同步</strong> 这两个概念，下面进一步讲解其作用。</p><h3 id="1-2-干什么？"><a href="#1-2-干什么？" class="headerlink" title="1.2 干什么？"></a>1.2 干什么？</h3><p>AQS是用来构建锁或者其他同步组件的基础框架。</p><p>学Java并发的话就重点关住于AQS是如何构建锁的，因为同步器是实现锁的关键！</p><ol><li><p>AQS用一个 <code>int</code> 成员变量来表示同步状态。通过修改同步状态，以此达到获取锁与释放锁的目的。</p><p>比如说一个线程获取到了锁，那么就相当于它此时获取到了同步状态。</p><p>一个线程执行完了它的任务，它去释放锁，就相当于释放同步状态。</p></li><li><p>AQS通过内置的 <code>FIFO队列</code> 完成线程的排队工作。</p><p>这一点其实并不难理解。当一个线程获取锁失败之后，可以选择陷入阻塞状态，也可以进行非阻塞地自旋重试；当有多个线程独占式地去获取锁时，只有一个线程可以获取成功，其它均会失败。那么应当如何管理这些竞争失败的锁呢？这便是队列的作用。</p><ul><li>线程获取锁失败时，便进行入队列操作，成为队列的尾结点，进入等待状态</li></ul></li></ol><h3 id="1-3-怎么用？"><a href="#1-3-怎么用？" class="headerlink" title="1.3 怎么用？"></a>1.3 怎么用？</h3><p>AQS的实现方式是继承：子类通过继承同步器并实现它的抽象方法来管理同步状态。</p><p>AQS支持独占式地获取同步状态与共享式地获取同步状态</p><p>其实AQS的精髓就在于它简化了锁的实现方式，我们不需要关心同步状态管理、线程排队、等待与唤醒等底层操作逻辑，我们只需要将精力放在锁的核心功能：加锁与解锁。</p><p>可以这样理解：</p><ul><li>锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节</li><li>AQS是面向锁的实现者，它定义了锁的实现者与同步器交互的接口，隐藏了实现细节</li></ul><p>之后会写一个实战案例去用AQS实现一个锁。</p><h2 id="2-AQS方法简述"><a href="#2-AQS方法简述" class="headerlink" title="2. AQS方法简述"></a>2. AQS方法简述</h2><p>下面三个方法是用于管理同步状态</p><ol><li><code>getState()</code>：用于获取同步状态</li><li><code>setState(int newState)</code>：用于设置同步状态</li><li><code>compareAndSetState(int expect, int update)</code>：使用CAS设置同步状态，保证原子性</li></ol><p>之前第一部分提到：AQS已经帮我们实现了队列的维护逻辑，我们实现锁时只需要重写获取锁的方法</p><ol><li><code>tryAcquire(int arg)</code>：独占式地获取同步状态，返回值为布尔类型，true为获取成功，false为获取失败。</li><li><code>tryRelease(int arg)</code>：独占式地释放同步状态，返回值为布尔类型，true为释放成功，false为释放失败。</li><li><code>tryAcquireShared(int arg)</code>：共享式地获取同步状态，返回值为int类型。<ul><li>返回0表示成功，且没有剩余资源</li><li>返回大于0的值表示成功，仍有剩余资源</li><li>返回负数代表获取失败</li></ul></li><li><code>tryReleaseShared(int arg)</code>：共享式地释放同步状态，返回值为布尔类型。<ul><li>如果释放后允许唤醒后续等待节点时，返回true；否则返回false</li></ul></li><li><code>isHeldExclusively()</code>：当前同步器是否被线程独占</li></ol><p>通过对于这些方法进行简单理解，便能初步体会到：</p><ul><li><p>当同步状态state为0时，其他线程才有可能获取到同步状态，即获取到锁。</p></li><li><p>对于可重入锁，当线程独占锁之后，会将同步状态state进行自增。如果该线程一直重复地获取该锁，则state会一直累加；该线程去释放该锁时，必须将state自减到0，才算是完全释放成功。</p></li></ul><h2 id="3-AQS实战案例"><a href="#3-AQS实战案例" class="headerlink" title="3. AQS实战案例"></a>3. AQS实战案例</h2><p>通过使用AQS，简单地实现一个独占不可重入锁，也就是说该锁的state只有0与1两种状态。</p><p>重点关注继承自AQS的Sync内部类，这里面自定义了获取同步状态与释放同步状态的核心逻辑。</p><p>这个案例印证了这句话：AQS是面向锁的实现者，它定义了锁的实现者与同步器交互的接口，隐藏了实现细节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExclusiveLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            <span class="hljs-comment">// 当通过CAS设置state为1时，代表加锁成功</span><br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span> ,<span class="hljs-number">1</span>)) &#123;<br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            <span class="hljs-comment">// 释放锁时如果发现该锁已被释放，说明有异常</span><br>            <span class="hljs-keyword">if</span> (getState() == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            setState(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 当state==1时表示处于占用状态</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.newCondition();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-AQS源码详解"><a href="#4-AQS源码详解" class="headerlink" title="4. AQS源码详解"></a>4. AQS源码详解</h2><h3 id="4-1-同步队列"><a href="#4-1-同步队列" class="headerlink" title="4.1 同步队列"></a>4.1 同步队列</h3><p>之前提到，同步器通过同步队列实现了对于线程与同步状态的管理。</p><p>进一步解释：</p><ol><li>当当前线程获取同步状态（锁）失败时，同步器会将当前线程构造为一个节点Node，并加入到同步队列中，阻塞当前线程</li><li>当同步状态（锁）被释放后，会将队列首节点线程唤醒，然后使该线程再次去尝试获取同步状态</li></ol><p>如下图所示：<code>head</code> 指向当前队列的头节点，其已获取到同步状态（锁）。</p><p>获取同步状态失败的节点，会将其依次添加到队列中，<code>tail</code> 维护尾节点。</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221017231708935.png" alt="image-20221017231708935"></p><p>队列节点状态：</p><ol><li>CANCELLED(1)：值为1，表示当前节点由于等待超时或被中断，需要取消等待，节点进入该状态后将不会再变化。</li><li>SIGNAL(-1)：值为-1，表示后继节点线程处于等待状态，等待当前节点唤醒。</li><li>CONDITION(-2)：值为-2，表示节点等待在Condition上，如果其他线程对Condition调用了signal方法后，CONDITION状态的节点会从等待队列转移到同步队列中。</li><li>PROPAGATE(-3)：值为-3，共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li><li>INITIAL(0)：值为0，代表初始状态</li></ol><p>观察节点状态发现：负值表示处于有效等待状态，而正值表示节点已被取消。</p><h3 id="4-2-独占式获取"><a href="#4-2-独占式获取" class="headerlink" title="4.2 独占式获取"></a>4.2 独占式获取</h3><p>核心方法为 <code>acquire()</code> ，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>而该方法又由 <code>tryAcquire</code> 、 <code>acquireQueued</code> 与 <code>addWaiter</code>  三个方法组成。</p><p>这里先给出该方法的执行流程：</p><ol><li>调用 <code>tryAcquire</code> 方法尝试去获取同步状态，其返回值为boolean类型：<ul><li>若返回True，代表获取同步状态成功。而其取反后，为False，该方法便到此为止了，直接返回</li><li>若返回False，代表获取同步状态失败，取反后为True，则需要进一步执行之后的方法</li></ul></li><li><code>tryAcquire</code> 返回False之后，继续执行 <code>addWaiter</code> 方法，构造同步节点，并通过该方法，将构造好的Node节点以独占模式加入到队列的尾部</li><li><code>acquireQueued</code> 方法使得该节点以死循环方式获取同步状态，一直到获取到才返回<ul><li>如果在死循环的过程中被中断过，则返回True，否则返回False</li></ul></li><li>如果线程节点在等待过程中被中断，是不会响应的。只有等到获取到同步状态后，才会执行 <code>selfInterrupt</code> 方法</li></ol><p>接着，一起来看一看这三个核心方法的源码</p><ul><li><p><code>tryAcquire</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个核心方法竟然只有一行代码，而且是抛出异常的代码。如果只看源码，确实很让人疑惑。</p><p>但是结合之前第一部分的内容以及实战案例：我们在实现一个锁时，需要在锁的内部创建一个内部类，并让其继承AQS，重写AQS中的核心方法。而这些核心方法中就包括 <code>tryAcquire</code>。这个获取同步状态（锁）的逻辑需要我们自己实现。</p><p>这也就进一步解释了：AQS简化了锁的实现方式，我们不需要关心同步状态管理、线程排队、等待与唤醒等底层操作逻辑，我们只需要将精力放在锁的核心功能加锁与解锁。</p></li><li><p><code>addWaiter</code>：直接看注释</p><p>其中if块中执行的内容就是将当前节点添加队列尾部</p><ul><li><p>注意需要使用 <code>compareAndSetTail</code> 方法来确保节点以线程安全的方式被添加到尾部。</p><p>如果仅使用简单的LinkedList来处理节点关系，则会导致多个线程并发地被添加到链表中，造成节点数量和顺序混乱。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">// 将当前线程构造为同步队列中的节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// 获取尾结点，tail为AQS类的成员变量</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-comment">// 若尾节点不为空</span><br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 将当前节点的prev设为尾结点</span><br>        node.prev = pred;<br>        <span class="hljs-comment">// 将当前节点设置为新的尾结点</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            <span class="hljs-comment">// 将旧的尾结点的next设为当前节点</span><br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 若尾节点为空，则调用enq自旋进行入队列操作</span><br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>enq</code>：直接看注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-comment">// 这是一种自旋方式。一直自旋，直到Node被添加到队尾</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 获取当前队列的尾结点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果tail为空，表示队列为空，需要新创建一个空节点作为head与tail节点</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果tail不为空，说明队列中存在线程节点，进行入队列操作</span><br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是：当 <code>addWaiter</code> 中尾结点为空时，又调用了 <code>enq</code> 方法以自旋方式添加节点，这样可以保证节点被添加成功</p></li></ul></li><li><p><code>acquireQueued</code>：直接看注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// failed表示是否获取同步状态（锁）失败</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// interrupted表示在获取过程中是否被打断</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 通过node.predecessor()拿到其前驱节点</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// 如果前驱节点为头节点head，代表当前节点可以尝试去获取同步状态（锁）</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">// 如果获取成功，则当前节点成为新的头节点head</span><br>            <span class="hljs-comment">// setHead方法会将当前节点的prev设置为null</span><br>                setHead(node);<br>                <span class="hljs-comment">// 将旧的头节点的next设置为null，有助于gc回收旧的head节点</span><br>                p.next = <span class="hljs-literal">null</span>; <br>                <span class="hljs-comment">// 代表成功获取到同步状态（锁）</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">// 返回是否被中断</span><br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 如果当前线程节点可以休息，那就进入等待状态，直至被unpark</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-comment">// 如果等待过程被中断，则标记为true</span><br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 如果等待过程中没有成功获取到同步状态（被中断或超时），则将该线程节点设置为CANCELLED状态</span><br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>shouldParkAfterFailedAcquire：该方法用于检查状态，判断当前线程节点的前驱节点是否仍然有效。看注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>    <span class="hljs-comment">// 前驱节点状态有效，返回true，当前线程节点便可进入等待状态，等待唤醒</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 前驱节点状态大于0，说明无效。</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// while循环继续寻找前驱节点之前的有效节点</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 将当前线程节点排到有效节点的后面</span><br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果前驱节点有效，将其状态以CAS方式设置为SIGNAL，以便于释放同步状态后通知当前线程节点</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-comment">// 返回false，在acquireQueued方法内继续自旋检查状态</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>parkAndCheckInterrupt：该方法用于进入等待状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4-3-独占式释放"><a href="#4-3-独占式释放" class="headerlink" title="4.3 独占式释放"></a>4.3 独占式释放</h3><p>release方法用于释放同步状态，并且会唤醒当前线程节点的后继节点，使得后继节点尝试去获取同步状态。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 唤醒后继节点</span><br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>其中tryRelease的设计模式与tryAcquire一样，均需要我们自己去实现</p></li><li><p>unparkSuccessor：唤醒后继节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// node为当前线程节点，获取其状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-comment">// 如果状态小于0，需要将其置为0（从有效到无效），该过程允许失败</span><br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 获取当前节点的后继节点，一般节点不为空且有效</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-comment">// 但如果该节点为空或无效（处于CANCELLED状态），则需要找到有效节点</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-4-共享式获取"><a href="#4-4-共享式获取" class="headerlink" title="4.4 共享式获取"></a>4.4 共享式获取</h3><p>先来看看共享式与独占式地获取同步状态的区别：</p><ul><li>在同一时刻，共享式获取允许多个线程同时获取到同步状态，而独占式则只有一个线程可以获取到，其他线程均阻塞</li></ul><p>共享式获取的一个经典应用便是Semaphore，其作用为控制同时访问某一特定资源的线程数量。</p><p>因此，在接下来的解释中，用 <code>资源</code> 代替 <code>同步状态</code>。</p><p>调用acquireShared方法共享式地获取资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中tryAcquireShared需要我们自己去手动实现，但是返回结果类型已经被定义好了：</p><ul><li>返回负数时，代表获取失败，剩余资源不足</li><li>返回非负数时，代表获取成功。如果为0，说明已没有剩余资源了；如果为正数，则代表还有剩余资源。</li></ul><p>当为负数时，需要调用doAcquireShared方法，进入等待队列，直到获取到资源时才返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 将当前线程节点添加到队列尾部</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 自旋重复尝试获取资源</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// 当前线程节点的前驱节点为头节点时</span><br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-comment">// 再次尝试获取资源</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-comment">// 资源数大于等于0，说明获取成功</span><br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 设置头节点，若r &gt; 0即还有剩余资源，则唤醒之后的线程节点</span><br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt();<br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-共享式释放"><a href="#4-5-共享式释放" class="headerlink" title="4.5 共享式释放"></a>4.5 共享式释放</h3><p>共享式释放会调用releaseShared方法，释放指定数量的资源。其中tryReleaseShared方法仍然需要我们自己去实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中doReleaseShared方法主要用于释放完资源后，去唤醒后续处于等待状态的各个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 通过循环与CAS操作确保资源被线程安全地释放</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-写在后面"><a href="#5-写在后面" class="headerlink" title="5. 写在后面"></a>5. 写在后面</h2><p>参考文献：</p><blockquote><ol><li><p>JDK5.0源码</p></li><li><p>《Java并发编程的艺术》</p></li><li><p><a href="https://www.bilibili.com/video/BV16J411h7Rd/?spm_id_from=333.337.search-card.all.click&vd_source=4e7654633e4719c03a8fb6c6b524ddc2">黑马Java并发编程教程</a></p></li></ol></blockquote><p>这个系列大概会有5篇左右的样子，我尽可能把自己对于JUC的理解通俗易懂地写出来</p><p>但如果有错误的地方，请大家指出来，我会及时去学习与改进~</p><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
      <tag>Java</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 901. Online Stock Span</title>
    <link href="/2022/10/21/LC-Solution-901-Online-Stock-Span/"/>
    <url>/2022/10/21/LC-Solution-901-Online-Stock-Span/</url>
    
    <content type="html"><![CDATA[<h1 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901. 股票价格跨度"></a><a href="https://leetcode.cn/problems/online-stock-span/">901. 股票价格跨度</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个 <code>StockSpanner</code> 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。</p><p>今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p><p>例如，如果未来7天股票的价格是 <code>[100, 80, 60, 70, 60, 75, 85]</code>，那么股票跨度将是 <code>[1, 1, 1, 2, 1, 4, 6]</code>。</p><p><strong>示例：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;StockSpanner&quot;</span>,<span class="hljs-string">&quot;next&quot;</span>,<span class="hljs-string">&quot;next&quot;</span>,<span class="hljs-string">&quot;next&quot;</span>,<span class="hljs-string">&quot;next&quot;</span>,<span class="hljs-string">&quot;next&quot;</span>,<span class="hljs-string">&quot;next&quot;</span>,<span class="hljs-string">&quot;next&quot;</span>]</span>, <span class="hljs-selector-attr">[[]</span>,<span class="hljs-selector-attr">[100]</span>,<span class="hljs-selector-attr">[80]</span>,<span class="hljs-selector-attr">[60]</span>,<span class="hljs-selector-attr">[70]</span>,<span class="hljs-selector-attr">[60]</span>,<span class="hljs-selector-attr">[75]</span>,<span class="hljs-selector-attr">[85]</span>]<br>输出：<span class="hljs-selector-attr">[null,1,1,1,2,1,4,6]</span><br>解释：<br>首先，初始化 S = <span class="hljs-built_in">StockSpanner</span>()，然后：<br>S<span class="hljs-selector-class">.next</span>(<span class="hljs-number">100</span>) 被调用并返回 <span class="hljs-number">1</span>，<br>S<span class="hljs-selector-class">.next</span>(<span class="hljs-number">80</span>) 被调用并返回 <span class="hljs-number">1</span>，<br>S<span class="hljs-selector-class">.next</span>(<span class="hljs-number">60</span>) 被调用并返回 <span class="hljs-number">1</span>，<br>S<span class="hljs-selector-class">.next</span>(<span class="hljs-number">70</span>) 被调用并返回 <span class="hljs-number">2</span>，<br>S<span class="hljs-selector-class">.next</span>(<span class="hljs-number">60</span>) 被调用并返回 <span class="hljs-number">1</span>，<br>S<span class="hljs-selector-class">.next</span>(<span class="hljs-number">75</span>) 被调用并返回 <span class="hljs-number">4</span>，<br>S<span class="hljs-selector-class">.next</span>(<span class="hljs-number">85</span>) 被调用并返回 <span class="hljs-number">6</span>。<br><br>注意 (例如) S<span class="hljs-selector-class">.next</span>(<span class="hljs-number">75</span>) 返回 <span class="hljs-number">4</span>，因为截至今天的最后 <span class="hljs-number">4</span> 个价格<br>(包括今天的价格 <span class="hljs-number">75</span>) 小于或等于今天的价格。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>调用 <code>StockSpanner.next(int price)</code> 时，将有 <code>1 &lt;= price &lt;= 10^5</code>。</li><li>每个测试用例最多可以调用 <code>10000</code> 次 <code>StockSpanner.next</code>。</li><li>在所有测试用例中，最多调用 <code>150000</code> 次 <code>StockSpanner.next</code>。</li><li>此问题的总时间限制减少了 50%。</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：单调栈"><a href="#方法一：单调栈" class="headerlink" title="方法一：单调栈"></a>方法一：单调栈</h3><p>题目要求我们返回比不超过当前股票价格的最大连续天数：进一步分析可知，我们只要找到之前第一个大于当前股票价格的下标，两个天数对应的下标相减，便是答案。</p><p>因此我们可以运用单调栈，按照股票的价格以降序入栈。</p><p>每个单调栈中存放形如 <code>[prices, days]</code>这样的数组：</p><ul><li>prices：当前股票的价格</li><li>days：股票价格的跨度（即在此之前，不超过当前股票价格的最大连续天数）</li></ul><p>next方法被调用时，我们便进行入栈操作。在入栈之前，我们需要循环判断当前栈顶元素的 <code>price</code> 是否小于等于当前股票的 <code>price</code>:</p><ul><li>若小于等于，则对栈顶元素进行出栈，并且将栈顶元素的 <code>days</code> 累加到当前股票的 <code>days</code> 上</li></ul><p>循环判断完毕后，当前股票的 <code>price</code> 为最小股票价格，满足单调递减，即可入栈。并将当前股票对应的 <code>days</code> 返回。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python3">class StockSpanner:<br>    def __init__(self):<br>        self.stack = []<br><br>    def next(self, price: int) -&gt; int:<br>        stack = self.stack<br>        days = 1 # days要初始化为1，因为最大连续天数中包含其自身<br>        while stack and stack[-1][0] &lt;= price:<br>            days += stack[-1][1]<br>            stack.pop(-1)<br>        stack.append([price, days])<br>        return days<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StockSpanner</span> &#123;<br>    Deque&lt;<span class="hljs-type">int</span>[]&gt; d;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StockSpanner</span><span class="hljs-params">()</span> &#123;<br>        d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">(<span class="hljs-type">int</span> price)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">days</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// days要初始化为1，因为最大连续天数中包含其自身</span><br>        <span class="hljs-keyword">while</span> (!d.isEmpty() &amp;&amp; d.peekLast()[<span class="hljs-number">0</span>] &lt;= price) &#123;<br>            days += d.pollLast()[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;price, days&#125;;<br>        d.addLast(arr);<br>        <span class="hljs-keyword">return</span> days;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StockSpanner <span class="hljs-keyword">struct</span> &#123;<br>    stack [][<span class="hljs-number">2</span>] <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> StockSpanner &#123;<br>    <span class="hljs-keyword">return</span> StockSpanner&#123;[][<span class="hljs-number">2</span>] <span class="hljs-type">int</span> &#123;&#125;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *StockSpanner)</span></span> Next(price <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    days := <span class="hljs-number">1</span> <span class="hljs-comment">// days要初始化为1，因为最大连续天数中包含其自身</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.stack) &gt; <span class="hljs-number">0</span> &amp;&amp; price &gt;= this.stack[<span class="hljs-built_in">len</span>(this.stack) - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &#123;<br>        days += this.stack[<span class="hljs-built_in">len</span>(this.stack) - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<br>        this.stack = this.stack[:<span class="hljs-built_in">len</span>(this.stack) - <span class="hljs-number">1</span>]<br>    &#125;<br>    this.stack = <span class="hljs-built_in">append</span>(this.stack, [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;price, days&#125;)<br>    <span class="hljs-keyword">return</span> days<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第29篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 779. K-th Symbol in Grammar</title>
    <link href="/2022/10/20/LC-Solution-779-K-th-Symbol-in-Grammar/"/>
    <url>/2022/10/20/LC-Solution-779-K-th-Symbol-in-Grammar/</url>
    
    <content type="html"><![CDATA[<h1 id="779-K-th-Symbol-in-Grammar"><a href="#779-K-th-Symbol-in-Grammar" class="headerlink" title="779. K-th Symbol in Grammar"></a><a href="https://leetcode.cn/problems/k-th-symbol-in-grammar/">779. K-th Symbol in Grammar</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们构建了一个包含 <code>n</code> 行( <strong>索引从 1 开始</strong> )的表。首先在第一行我们写上一个 <code>0</code>。接下来的每一行，将前一行中的<code>0</code>替换为<code>01</code>，<code>1</code>替换为<code>10</code>。</p><ul><li>例如，对于 <code>n = 3</code> ，第 <code>1</code> 行是 <code>0</code> ，第 <code>2</code> 行是 <code>01</code> ，第3行是 <code>0110</code> 。</li></ul><p>给定行数 <code>n</code> 和序数 <code>k</code>，返回第 <code>n</code> 行中第 <code>k</code> 个字符。（ <code>k</code> <strong>从索引 1 开始</strong>）</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 1, k = 1</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 第一行：0</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 2, k = 1</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: </span><br><span class="hljs-section">第一行: 0 </span><br><span class="hljs-section">第二行: 01</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 2, k = 2</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释:</span><br><span class="hljs-section">第一行: 0</span><br><span class="hljs-section">第二行: 01</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= n &lt;= 30</code></li><li><code>1 &lt;= k &lt;= 2n - 1</code></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方法一：找规律-二分迭代"><a href="#方法一：找规律-二分迭代" class="headerlink" title="方法一：找规律 + 二分迭代"></a>方法一：找规律 + 二分迭代</h4><p>以n&#x3D;5，k&#x3D;10为例</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">n</span> = <span class="hljs-number">1</span> -&gt; <span class="hljs-number">0</span><br><span class="hljs-attribute">n</span> = <span class="hljs-number">2</span> -&gt; <span class="hljs-number">01</span><br><span class="hljs-attribute">n</span> = <span class="hljs-number">3</span> -&gt; <span class="hljs-number">0110</span><br><span class="hljs-attribute">n</span> = <span class="hljs-number">4</span> -&gt; <span class="hljs-number">0110</span> <span class="hljs-number">1001</span><br><span class="hljs-attribute">n</span> = <span class="hljs-number">5</span> -&gt; <span class="hljs-number">0110</span> <span class="hljs-number">1001</span> <span class="hljs-number">1001</span> <span class="hljs-number">0110</span><br></code></pre></td></tr></table></figure><p>从中我们很容易发现，每一个 <code>n</code> 对应的长度为：<code>len = 2 ^ (n-1)</code>，用 <code>s</code> 表示每个 <code>n</code> 对应的字符串</p><p>因此我们发现这样一个规律：</p><ul><li>如果 <code>k &gt; len / 2</code>，那么 <code>s[k] = !s[k - len / 2]</code>。换句话说如果 <code>s[k]</code> 为1，那么 <code>s[k - len / 2]</code>为0，互为取反。</li></ul><p>借助此规律，我们可以首先计算出对应的长度，用 <code>flag</code> 表示当前位置是否取反（很容易得知取反次数为偶数次时，保持不变）</p><p>循环迭代：</p><ul><li>通过长度 <code>len</code> 判断是当前位置 <code>k</code> 是在左半边还是在右半边，以此决定是否取反。<ul><li>若 <code>k</code> 在右半边，则取反 <code>flag = !flag</code>，并将 <code>k -= len / 2</code></li></ul></li><li>每次对当前字符串进行二分，即长度 <code>len</code> 进行折半</li><li>每次对 <code>n</code> 进行自减</li></ul><p>最终当 <code>n = 2</code> 时，停止迭代。此时 <code>k = 1</code>或 <code>k = 2</code>，便可根据 <code>flag</code> 得出最终答案</p><h5 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthGrammar</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        length = <span class="hljs-number">2</span> ** (n - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> length &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> k - <span class="hljs-number">1</span><br>        flag = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">if</span> k &gt; length // <span class="hljs-number">2</span>:<br>                k -= length // <span class="hljs-number">2</span><br>                flag = <span class="hljs-keyword">not</span> flag<br>            n -= <span class="hljs-number">1</span><br>            length //= <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> flag:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthGrammar</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">2</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(len &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> k - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span>(k &gt; len / <span class="hljs-number">2</span>) &#123;<br>                k -= len / <span class="hljs-number">2</span>;<br>                flag = !flag;<br>            &#125;<br>            n--;<br>            len /= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) &#123;<br>            <span class="hljs-keyword">return</span> k == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> k == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">kthGrammar</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-built_in">len</span> := <span class="hljs-type">int</span>(math.Pow(<span class="hljs-number">2</span>, <span class="hljs-type">float64</span>(n - <span class="hljs-number">1</span>)))<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span> &lt;= <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> k - <span class="hljs-number">1</span><br>    &#125;<br>    flag := <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">if</span> k &gt; <span class="hljs-built_in">len</span> / <span class="hljs-number">2</span> &#123;<br>            k -= <span class="hljs-built_in">len</span> / <span class="hljs-number">2</span><br>            flag = !flag<br>        &#125;<br>        n--<br>        <span class="hljs-built_in">len</span> /= <span class="hljs-number">2</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> flag &#123;<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125; <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第28篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1700. Number of Students Unable to Eat Lunch</title>
    <link href="/2022/10/19/LC-Solution-1700-Number-of-Students-Unable-to-Eat-Lunch/"/>
    <url>/2022/10/19/LC-Solution-1700-Number-of-Students-Unable-to-Eat-Lunch/</url>
    
    <content type="html"><![CDATA[<h1 id="1700-无法吃午餐的学生数量"><a href="#1700-无法吃午餐的学生数量" class="headerlink" title="1700. 无法吃午餐的学生数量"></a><a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/">1700. 无法吃午餐的学生数量</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>学校的自助午餐提供圆形和方形的三明治，分别用数字 <code>0</code> 和 <code>1</code> 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。</p><p>餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 <strong>栈</strong> 里，每一轮：</p><ul><li>如果队列最前面的学生 <strong>喜欢</strong> 栈顶的三明治，那么会 <strong>拿走它</strong> 并离开队列。</li><li>否则，这名学生会 <strong>放弃这个三明治</strong> 并回到队列的尾部。</li></ul><p>这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。</p><p>给你两个整数数组 <code>students</code> 和 <code>sandwiches</code> ，其中 <code>sandwiches[i]</code> 是栈里面第 <code>i</code> 个三明治的类型（<code>i = 0</code> 是栈的顶部）， <code>students[j]</code> 是初始队列里第 <code>j</code> 名学生对三明治的喜好（<code>j = 0</code> 是队列的最开始位置）。请你返回无法吃午餐的学生数量。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：students = [<span class="hljs-number">1,1,0,0</span>], sandwiches = [<span class="hljs-number">0,1,0,1</span>]<br>输出：<span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：students = <span class="hljs-string">[1,1,1,0,0,1]</span>, sandwiches = <span class="hljs-string">[1,0,0,0,1,1]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= students.length, sandwiches.length &lt;= 100</code></li><li><code>students.length == sandwiches.length</code></li><li><code>sandwiches[i]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li><li><code>students[i]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：队列-栈模拟"><a href="#方法一：队列-栈模拟" class="headerlink" title="方法一：队列 + 栈模拟"></a>方法一：队列 + 栈模拟</h3><ol><li>学生以队列形式取三明治<ul><li>如果队列头的学生喜欢当前三明治，则取走三明治之后出队列</li><li>否则，该学生返回队列尾，继续排队取三明治</li></ul></li><li>三明治以栈的形式被取走<ul><li>如果栈顶三明治被学生喜欢，则出栈</li><li>否则，保持不变</li></ul></li></ol><p>如此分析不难得出，如果队列中没有一个学生喜欢栈顶的三明治，那么循环将终止，当前队列中的所有学生将无法吃到三明治。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countStudents</span>(<span class="hljs-params">self, sts: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], sas: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">while</span> sts <span class="hljs-keyword">and</span> sas <span class="hljs-keyword">and</span> sas[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> sts:<br>            <span class="hljs-keyword">if</span> sts[<span class="hljs-number">0</span>] == sas[<span class="hljs-number">0</span>]:<br>                sts.pop(<span class="hljs-number">0</span>)<br>                sas.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">else</span>:<br>                st = sts.pop(<span class="hljs-number">0</span>)<br>                sts.append(st)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(sts)<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countStudents</span><span class="hljs-params">(<span class="hljs-type">int</span>[] sts, <span class="hljs-type">int</span>[] sas)</span> &#123;<br>        Deque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : sts) queue.addLast(v);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : sas) stack.addLast(v);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty() &amp;&amp; !stack.isEmpty() &amp;&amp; queue.contains(stack.peekFirst())) &#123;<br>            <span class="hljs-keyword">if</span>(queue.peekFirst() == stack.peekFirst()) &#123;<br>                queue.pollFirst();<br>                stack.pollFirst();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> queue.pollFirst();<br>                queue.addLast(v);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：计数"><a href="#方法二：计数" class="headerlink" title="方法二：计数"></a>方法二：计数</h3><p>根据之前方法一中的分析，发现关键在于栈顶的三明治是否被队列中的学生所喜欢，如果没有一个学生喜欢，则可以得出最终答案</p><p>于是可以采用计数方式，用 <code>cnt</code> 统计喜欢两种三明治的学生人数。</p><p>遍历三明治数组，递减 <code>cnt[v]</code>，当 <code>cnt[v] == -1</code>，也就是没有学生喜欢当前三明治，则直接返回剩余学生数量即可。</p><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countStudents</span>(<span class="hljs-params">self, sts: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], sas: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        cnt = Counter(sts)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(sas)):<br>            cnt[sas[i]] -= <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 这里是先减后判断，所以是-1</span><br>            <span class="hljs-keyword">if</span> cnt[sas[i]] == -<span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> cnt[sas[i] ^ <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countStudents</span><span class="hljs-params">(<span class="hljs-type">int</span>[] sts, <span class="hljs-type">int</span>[] sas)</span> &#123;<br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v : sts) cnt[v]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sas.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(--cnt[sas[i]] == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> sas.length - i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countStudents</span><span class="hljs-params">(sts []<span class="hljs-type">int</span>, sas []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    cnt := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> sts &#123;<br>        cnt[v]++<br>    &#125;<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> sas &#123;<br>        cnt[v]--<br>        <span class="hljs-keyword">if</span> cnt[v] == <span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(sas) - i<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第27篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 904. Fruit Into Baskets</title>
    <link href="/2022/10/17/LC-Solution-904-Fruit-Into-Baskets/"/>
    <url>/2022/10/17/LC-Solution-904-Fruit-Into-Baskets/</url>
    
    <content type="html"><![CDATA[<h1 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><ul><li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ul><p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：fruits </span>=<span class="hljs-string"> [1,2,1]</span><br><span class="hljs-string">输出：3</span><br><span class="hljs-string">解释：可以采摘全部 3 棵树。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：fruits = <span class="hljs-comment">[0,1,2,2]</span><br>输出：3<br>解释：可以采摘 <span class="hljs-comment">[1,2,2]</span> 这三棵树。<br>如果从第一棵树开始采摘，则只能采摘 <span class="hljs-comment">[0,1]</span> 这两棵树。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：fruits = <span class="hljs-comment">[1,2,3,2,2]</span><br>输出：4<br>解释：可以采摘 <span class="hljs-comment">[2,3,2,2]</span> 这四棵树。<br>如果从第一棵树开始采摘，则只能采摘 <span class="hljs-comment">[1,2]</span> 这两棵树。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：fruits = [<span class="hljs-number">3,3,3,1</span>,<span class="hljs-number">2,1,1,2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">5</span><br>解释：可以采摘 [<span class="hljs-number">1,2,1,1</span>,<span class="hljs-number">2</span>] 这五棵树。<br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：滑动窗口"><a href="#方法一：滑动窗口" class="headerlink" title="方法一：滑动窗口"></a>方法一：滑动窗口</h3><p>题目意思就是用两个篮子摘水果，每个篮子一旦确定好水果类型之后就不能更改，如果碰到了水果种类与两个篮子里的水果种类不同的树，就停止，此时摘到水果的数量等于开始位置到终止位置的长度。</p><p>采用滑动窗口：设 <code>i</code> 为滑动窗口的终止位置，<code>j</code> 为滑动窗口的起始位置，<code>i</code> 与 <code>j</code> 之间的水果种类只有两种。</p><p>使用哈希表记录某个种类水果对应的采摘数量。当哈希表长度超过2时，说明此时有3个水果种类，需要剔除掉其中一个。也就是说，此时需要滑动左端点 <code>j</code> 并减少 <code>j</code> 所对应水果的数量，直到哈希表长度为2，也就是剩余2个水果种类。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python3">class Solution:<br>    def totalFruit(self, fruits: List[int]) -&gt; int:<br>        dic = defaultdict(int)<br>        j, ans = 0, 0<br>        for i, v in enumerate(fruits):<br>            dic[v] += 1<br>            while len(dic) &gt; 2:<br>                dic[fruits[j]] -= 1<br>                if dic[fruits[j]] == 0:<br>                    dic.pop(fruits[j])<br>                j += 1<br>            ans = max(ans, i - j + 1)<br>        return ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">totalFruit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] fruits)</span> &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fruits.length; i++) &#123;<br>            map.put(fruits[i], map.getOrDefault(fruits[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span>(map.size() &gt; <span class="hljs-number">2</span>) &#123;<br>                map.put(fruits[j], map.get(fruits[j]) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(map.get(fruits[j]) == <span class="hljs-number">0</span>) &#123;<br>                    map.remove(fruits[j]);<br>                &#125;<br>                j++;<br>            &#125;<br>            ans = Math.max(ans, i - j + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(fruits []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    cnt := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    ans, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> fruits &#123;<br>        cnt[x] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> ; <span class="hljs-built_in">len</span>(cnt) &gt; <span class="hljs-number">2</span>; j++ &#123;<br>            cnt[fruits[j]] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cnt[fruits[j]] == <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-built_in">delete</span>(cnt, fruits[j])<br>            &#125;<br>        &#125;<br>        ans = max(ans, i - j + <span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a <br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第26篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo从0到1搭建博客系列04：图床的最佳实践</title>
    <link href="/2022/10/15/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9704%EF%BC%9A%E5%9B%BE%E5%BA%8A%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/10/15/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9704%EF%BC%9A%E5%9B%BE%E5%BA%8A%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo从0到1搭建博客系列04：图床的最佳实践"><a href="#Hexo从0到1搭建博客系列04：图床的最佳实践" class="headerlink" title="Hexo从0到1搭建博客系列04：图床的最佳实践"></a>Hexo从0到1搭建博客系列04：图床的最佳实践</h1><h2 id="1-前言：为什么要使用图床？"><a href="#1-前言：为什么要使用图床？" class="headerlink" title="1. 前言：为什么要使用图床？"></a>1. 前言：为什么要使用图床？</h2><p>之前我们已经讲过如何用Hexo发表文章。但是，一篇优秀的知识分享与技术博客，怎么能少得了图片呢？</p><p>但是，文章中的图片存储在哪里？</p><ol><li>当我们在本地写博客做笔记（用Typora或MarkText）时，我们一般会把图片存在当前文章的路径下</li><li>当我们在CSDN、掘金或知乎等平台上写博客时，我们的图片会被存储到这些网站对应的服务器中</li><li>而当我们的博客发布在Hexo上时，图片的加载路径有以下两种方式：<ol><li>参照我们本地写博客的方式，将图片存储到Hexo下的public资源文件夹下</li><li>参照在技术论坛写博客的方式，将图片存储到服务器上</li></ol></li></ol><p>如果将图片资源都存储到Hexo的文件中，会变得很臃肿，所以不采用该方案。</p><p>我们这里所要说的就是将图片存储到服务器上，即图床这种方式。</p><p>但这时候你会想，本来使用Hexo做博客就是为了省事省钱、不买服务器，而为了存图片，再买服务器吗？</p><p>不必担心，各大云服务商平台都提供了图片存储，也是对象存储的云服务器！而且价格远低于服务器！</p><p>接下来进入正题！</p><h2 id="2-方案选择"><a href="#2-方案选择" class="headerlink" title="2. 方案选择"></a>2. 方案选择</h2><p>以下几种方案都极其简单，原理都很类似</p><h3 id="方案一：Github仓库-Picgo-jsDelivr-CDN"><a href="#方案一：Github仓库-Picgo-jsDelivr-CDN" class="headerlink" title="方案一：Github仓库 + Picgo + jsDelivr CDN"></a>方案一：Github仓库 + Picgo + jsDelivr CDN</h3><p>这一种方案我在实操之后，发现国内用户无法访问，是因为最近国内将jsDelivrCDN给墙了，无法通过其对Github进行加速</p><p>但是我还是简单介绍一下，</p><ol><li><p>创建Github公共仓库，名字随便，注意一定要是公共的，否则别人无法访问到图片资源。</p></li><li><p>下载 <a href="https://github.com/Molunerfinn/PicGo/releases">Picgo</a></p><blockquote><p>  <strong>PicGo: 一个用于快速上传图片并获取图片 URL 链接的工具</strong></p></blockquote></li><li><p>将Github创建仓库信息配置到Picgo中。打开Picgo，点击图床设置，选择Github图床，填写如下信息。</p><p>仓库名就写你之前创建好的仓库名</p><p>分支填现有的分支就可以</p><p>其中的Token可以在Github - Settings - Personal access tokens 中生成，只选择repo选项就可以</p><ul><li>如果不知道如何生成的话，可以查看现成的相关<a href="https://www.cnblogs.com/leon-2016/p/9284837.html">攻略</a></li></ul><p>指定存储路径可填可不填</p><p>自定义域名这里填写：<code>https://cdn.jsdelivr.net/gh/用户名/仓库名</code>，因为我们采用了jsDelivr CDN进行加速，虽然现在没有任何卵用</p><p>最后保存为默认图床即可</p></li></ol><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015200744589.png" alt="image-20221015200744589"></p><h3 id="方案二：Gitee仓库-Picgo"><a href="#方案二：Gitee仓库-Picgo" class="headerlink" title="方案二：Gitee仓库 + Picgo"></a>方案二：Gitee仓库 + Picgo</h3><p>Gitee虽然说是国内平台，访问是没问题的。但是听说它经常崩，我有点担心，就没有去尝试。</p><p>其方法和Github几乎一模一样，只是选择了用Gitee创建仓库。</p><p>在这里我也不推荐使用这种方案</p><h3 id="方案三：阿里云对象存储-Picgo"><a href="#方案三：阿里云对象存储-Picgo" class="headerlink" title="方案三：阿里云对象存储 + Picgo"></a>方案三：阿里云对象存储 + Picgo</h3><p>之前没有使用过阿里云的小伙伴可以仔细学一学啦，</p><p>以后搭建个人网站都需要用到服务器，网站上的图片视频资源也肯定需要用到云存储，所以不可避免要和各类云服务商打交道。</p><p>而阿里云应该是国内最知名的几家云服务商之一了</p><ol><li>登录阿里云网站，进入工作台页面，搜索对象存储，进入该页面，然后点击bucket列表</li></ol><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015202120960.png" alt="image-20221015202120960"></p><ol start="2"><li><p>进入页面，点击创建bucket.</p><ul><li>Bucket名称和地域必填。地域选择一个距离自己近一些的地方。</li><li>读写权限选择为公共读，其余均默认</li></ul><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015202336953.png" alt="image-20221015202336953"></p></li><li><p>点击网页右上角的头像，再点击AccessKey管理，进入该页面</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015202601913.png" alt="image-20221015202601913"></p></li><li><p>点击创建AccessKey，将创建号的key复制保存下来，之后在Picgo上需要用到</p></li><li><p>打开Picgo，点击图床设置，选择阿里云OSS，填写如下信息。</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015202826913.png" alt="image-20221015202826913"></p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>结合历史经验，为了网站图片存储的稳定，我们还是选择方案三作为我们图床实践的最佳选择</p><p>可能后期图片访问量大的话，需要充一点钱，但是也很便宜，大概一年40GB只需要9块钱，相当划算啦</p><h2 id="3-结合Typora使用"><a href="#3-结合Typora使用" class="headerlink" title="3. 结合Typora使用"></a>3. 结合Typora使用</h2><p>当我们成功搭建好图床之后，每次写Markdown文档时，都需要先截图，再保存，然后手动打开Picgo完成上传，最后将图片地址复制到Markdown文档中。</p><p>如何做到更加高效地上传图片到图床呢？</p><p>用Typora写笔记，只需要先截图，再粘贴到Markdown文档，即可直接跳过上传操作，Typora帮我们自动完成。</p><p>操作为：打开Typora的设置，点击图像，按照我给的图片进行设置</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015203547504.png" alt="image-20221015203547504"></p><p>之后，我们便可以愉快地用Hexo写图文并茂的博客啦~</p><h2 id="4-后记"><a href="#4-后记" class="headerlink" title="4. 后记"></a>4. 后记</h2><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>Hexo搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1441. Build an Array With Stack Operations</title>
    <link href="/2022/10/15/LC-Solution-1441-Build-an-Array-With-Stack-Operations/"/>
    <url>/2022/10/15/LC-Solution-1441-Build-an-Array-With-Stack-Operations/</url>
    
    <content type="html"><![CDATA[<h1 id="1441-用栈操作构建数组"><a href="#1441-用栈操作构建数组" class="headerlink" title="1441. 用栈操作构建数组"></a><a href="https://leetcode.cn/problems/build-an-array-with-stack-operations/">1441. 用栈操作构建数组</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个数组 <code>target</code> 和一个整数 <code>n</code>。每次迭代，需要从 <code>list = &#123; 1 , 2 , 3 ..., n &#125;</code> 中依次读取一个数字。</p><p>请使用下述操作来构建目标数组 <code>target</code> ：</p><ul><li><code>&quot;Push&quot;</code>：从 <code>list</code> 中读取一个新元素， 并将其推入数组中。</li><li><code>&quot;Pop&quot;</code>：删除数组中的最后一个元素。</li><li>如果目标数组构建完成，就停止读取更多元素。</li></ul><p>题目数据保证目标数组严格递增，并且只包含 <code>1</code> 到 <code>n</code> 之间的数字。</p><p>请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：target = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], n = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;Push&quot;</span>,<span class="hljs-string">&quot;Push&quot;</span>,<span class="hljs-string">&quot;Pop&quot;</span>,<span class="hljs-string">&quot;Push&quot;</span>]<br>解释： <br>读取 <span class="hljs-number">1</span> 并自动推入数组 -&gt; [<span class="hljs-number">1</span>]<br>读取 <span class="hljs-number">2</span> 并自动推入数组，然后删除它 -&gt; [<span class="hljs-number">1</span>]<br>读取 <span class="hljs-number">3</span> 并自动推入数组 -&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：target = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], n = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;Push&quot;</span>,<span class="hljs-string">&quot;Push&quot;</span>,<span class="hljs-string">&quot;Push&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：target = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], n = <span class="hljs-number">4</span><br>输出：[<span class="hljs-string">&quot;Push&quot;</span>,<span class="hljs-string">&quot;Push&quot;</span>]<br>解释：只需要读取前 <span class="hljs-number">2</span> 个数字就可以停止。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target.length &lt;= 100</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= target[i] &lt;= n</code></li><li><code>target</code> 严格递增</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：简单模拟"><a href="#方法一：简单模拟" class="headerlink" title="方法一：简单模拟"></a>方法一：简单模拟</h3><p>题目给定的条件：<code>target</code> 数组严格递增升序且只包含1~n之间的数字</p><ol><li>对于 <code>target</code> 中缺少的数字，分类讨论<ol><li>该数字小于 <code>target[-1]</code>（数组最后一个元素），需要进行 ‘Push’ + ‘Pop’ 操作</li><li>该数字大于 <code>target[-1]</code>（数组最后一个元素），无需进行操作，因为该数已经不在 <code>target</code> 内了</li></ol></li><li>对于 <code>target</code> 中存在的数字，我只需要进行 ‘Push’ 操作</li></ol><p>根据上述分析可知，我们根本不需要用到题目给定的 n，因为 n 中大于 <code>target[-1]</code> 的数不需要处理，而小于 <code>target[-1]</code> 的数只需要遍历 <code>target</code> 数组即可</p><p>因此，遍历 <code>target</code> 数组，找出 <code>target</code> 缺少的数字。通过初始化 <code>j = 1</code>，判断当前遍历的数是否等于 <code>j</code> 来判断是否缺少该数。</p><p>直接看代码更好理解！</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python3">class Solution:<br>    def buildArray(self, target: List[int], n: int) -&gt; List[str]:<br>        ans = []<br>        j = 1<br>        for i in range(len(target)):<br>            while target[i] != j:<br>                ans.append(&#x27;Push&#x27;)<br>                ans.append(&#x27;Pop&#x27;)<br>                j += 1<br>            ans.append(&#x27;Push&#x27;)<br>            j += 1 # 当target[i] == j时，处理完之后还需要在自增一次j<br>        return ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">buildArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] target, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> target.length;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">while</span>(target[i] != j) &#123;<br>                ans.add(<span class="hljs-string">&quot;Push&quot;</span>);<br>                ans.add(<span class="hljs-string">&quot;Pop&quot;</span>);<br>                j++;<br>            &#125;<br>            ans.add(<span class="hljs-string">&quot;Push&quot;</span>)<br>            j++; <span class="hljs-comment">// 当target[i] == j时，处理完之后还需要在自增一次j</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第25篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 5. Longest Palindromic Substring</title>
    <link href="/2022/10/14/LC-Solution-5-Longest-Palindromic-Substring/"/>
    <url>/2022/10/14/LC-Solution-5-Longest-Palindromic-Substring/</url>
    
    <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;babad&quot;</span><br>输出：<span class="hljs-string">&quot;bab&quot;</span><br>解释：<span class="hljs-string">&quot;aba&quot;</span> 同样是符合题意的答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cbbd&quot;</span><br>输出：<span class="hljs-string">&quot;bb&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：中心扩散法-双指针"><a href="#方法一：中心扩散法-双指针" class="headerlink" title="方法一：中心扩散法 + 双指针"></a>方法一：中心扩散法 + 双指针</h3><p>思路为：从 <code>s</code> 中选取一个位置作为中心，从该中心位置向两边扩散，如果两边元素不相等的时候停止。</p><p>举个🌰：如 <code>abbac</code>，假设选取第一个’b’作为中心位置，<code>i = 2</code>。设左指针 <code>l == i - 1</code> ，右指针<code>r == i + 1</code> </p><ol><li>先向左扩散。<code>l</code> 一直自减，直到遇到与中心位置不相等的字符。此时 <code>s[l] = &#39;a&#39;</code> <code>l = 1</code> </li><li>再向右扩散。<code>r</code> 一直自增，直到遇到与中心位置不相等的字符。此时 <code>s[r] = &#39;a&#39;</code> <code>r = 3</code></li><li>左指针与右指针同时开始双向扩散，直到左和右不相等</li></ol><p>一开始之所以要执行第1步和第2步，就是要进一步确定中心块。因为定义的中心可能只有一个元素，但可能由多个相同元素组成。</p><p>遍历 <code>s</code>， 执行完上述流程后，需要更新最长回文子串的左端点与长度，以便于最后返回结果</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        maxLen, maxLeft = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            l, r = i - <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span><br>            curLen = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> l &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[l] == s[i]:<br>                curLen, l = curLen + <span class="hljs-number">1</span>, l - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> r &lt; n <span class="hljs-keyword">and</span> s[r] == s[i]:<br>                curLen, r = curLen + <span class="hljs-number">1</span>, r + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> l &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> r &lt; n <span class="hljs-keyword">and</span> s[l] == s[r]:<br>                curLen += <span class="hljs-number">2</span><br>                l, r = l - <span class="hljs-number">1</span>, r + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> curLen &gt;= maxLen:<br>                maxLen = curLen<br>                maxLeft = l<br>        <span class="hljs-keyword">return</span> s[maxLeft + <span class="hljs-number">1</span>: maxLeft + maxLen + <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxLeft = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>, r = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(l &gt;= <span class="hljs-number">0</span> &amp;&amp; cs[l] == cs[i]) &#123;<br>                curLen++;<br>                l--;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(r &lt; n &amp;&amp; cs[r] == cs[i]) &#123;<br>                curLen++;<br>                r++;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; n &amp;&amp; cs[l] == cs[r]) &#123;<br>                l--;<br>                r++;<br>                curLen += <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(curLen &gt; maxLen) &#123;<br>                maxLen = curLen;<br>                maxLeft = l;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(maxLeft + <span class="hljs-number">1</span>, maxLeft + <span class="hljs-number">1</span> + maxLen);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p>中心扩散法做了很多重复的计算。其实可以在计算的过程中将这些值存储起来，即记忆化搜索。可以采用动态规划实现。</p><p>设 <code>dp[i][j]</code>，其为<code>True</code> 代表 <code>[i, j]</code> 区间字符串为回文字符串</p><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        n = <span class="hljs-built_in">len</span>(s)<br>        maxLen, maxLeft, maxRight = <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        dp = [[<span class="hljs-literal">False</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r):<br>                <span class="hljs-keyword">if</span> s[l] == s[r] <span class="hljs-keyword">and</span> (r - l &lt;= <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> dp[l+<span class="hljs-number">1</span>][r-<span class="hljs-number">1</span>]):<br>                    dp[l][r] = <span class="hljs-literal">True</span><br>                    <span class="hljs-keyword">if</span> r - l + <span class="hljs-number">1</span> &gt; maxLen:<br>                        maxLen = r - l + <span class="hljs-number">1</span><br>                        maxLeft, maxRight = l, r<br>        <span class="hljs-keyword">return</span> s[maxLeft: maxRight + <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxLeft = <span class="hljs-number">0</span>, maxRight = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; r &lt; n; r++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l &lt; r; l++) &#123;<br>                <span class="hljs-keyword">if</span>(cs[l] == cs[r] &amp;&amp; (r - l &lt;= <span class="hljs-number">2</span> || dp[l + <span class="hljs-number">1</span>][r - <span class="hljs-number">1</span>])) &#123;<br>                    dp[l][r] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span>(r - l + <span class="hljs-number">1</span>&gt; maxLen) &#123;<br>                        maxLen = r - l + <span class="hljs-number">1</span>;<br>                        maxLeft = l;<br>                        maxRight = r;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(maxLeft, maxRight + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第24篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 817. Linked List Components</title>
    <link href="/2022/10/12/LC-Solution-817-Linked-List-Components/"/>
    <url>/2022/10/12/LC-Solution-817-Linked-List-Components/</url>
    
    <content type="html"><![CDATA[<h1 id="817-链表组件"><a href="#817-链表组件" class="headerlink" title="817. 链表组件"></a><a href="https://leetcode.cn/problems/linked-list-components/">817. 链表组件</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定链表头结点 <code>head</code>，该链表上的每个结点都有一个 <strong>唯一的整型值</strong> 。同时给定列表 <code>nums</code>，该列表是上述链表中整型值的一个子集。</p><p>返回列表 <code>nums</code> 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 <code>nums</code> 中）构成的集合。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: head = <span class="hljs-comment">[0,1,2,3]</span>, nums = <span class="hljs-comment">[0,1,3]</span><br>输出: 2<br>解释: 链表中,0 和 1 是相连接的，且 nums 中不包含 2，所以 <span class="hljs-comment">[0, 1]</span> 是 nums 的一个组件，同理 <span class="hljs-comment">[3]</span> 也是一个组件，故返回 2。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: head = <span class="hljs-comment">[0,1,2,3,4]</span>, nums = <span class="hljs-comment">[0,3,1,4]</span><br>输出: 2<br>解释: 链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 <span class="hljs-comment">[0, 1]</span> 和 <span class="hljs-comment">[3, 4]</span> 是两个组件，故返回 2。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数为<code>n</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>0 &lt;= Node.val &lt; n</code></li><li><code>Node.val</code> 中所有值 <strong>不同</strong></li><li><code>1 &lt;= nums.length &lt;= n</code></li><li><code>0 &lt;= nums[i] &lt; n</code></li><li><code>nums</code> 中所有值 <strong>不同</strong></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：模拟-哈希表-链表遍历"><a href="#方法一：模拟-哈希表-链表遍历" class="headerlink" title="方法一：模拟 + 哈希表 + 链表遍历"></a>方法一：模拟 + 哈希表 + 链表遍历</h3><p>分析题意可知，需要返回链表中连通量的个数（连通量中的值必须在 <code>nums</code> 中）</p><p>因此我们可以通过遍历列表，判断当前节点 <code>cur.val</code> 以及其前驱节点 <code>pre.val</code> 是否存在于 <code>nums</code> 中，如下分类讨论：</p><ol><li>若 <code>cur.val</code> 在 <code>nums</code> 中，但 <code>pre.val</code> 不在 <code>nums</code> 中：</li></ol><p>  说明此时产生了新的连通分量，需要进行计数</p><ol start="2"><li><p>若 <code>cur.val</code> 不在 <code>nums</code> 中，<code>pre.val</code> 也不在 <code>nums</code> 中：没有新的连通分量产生</p></li><li><p>若 <code>cur.val</code> 不在 <code>nums</code> 中，但<code>pre.val</code> 在 <code>nums</code> 中：没有新的连通分量产生</p></li><li><p>若 <code>cur.val</code> 在 <code>nums</code> 中，<code>pre.val</code> 也在 <code>nums</code> 中：</p></li></ol><p>  没有新的连通分量产生，<code>cur</code> 归属于前一个连通分量集合中</p><p>因此，只有第一种情况下，我们需要进行计数，其他情况不用体现在代码中。</p><p>为了提高判断链表节点值是否在 <code>nums</code> 中，我们将其转换为 <code>set</code> 集合，更加高效。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numComponents</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        cur = head<br>        ans, pre = <span class="hljs-number">0</span>, ListNode(-<span class="hljs-number">1</span>)<br>        s = <span class="hljs-built_in">set</span>(nums)<br>        <span class="hljs-keyword">while</span> cur:<br>            <span class="hljs-keyword">if</span> cur.val <span class="hljs-keyword">in</span> s <span class="hljs-keyword">and</span> pre.val <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s:<br>                    ans += <span class="hljs-number">1</span><br>            pre, cur = cur, cur.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numComponents</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : nums) set.add(n);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head, pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(set.contains(cur.val) &amp;&amp; !set.contains(pre.val)) &#123;<br>                ans++;<br>            &#125;<br>            pre = cur;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第23篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解JDK锁01:Lock接口</title>
    <link href="/2022/10/12/%E8%AF%A6%E8%A7%A3JDK%E9%94%8101-Lock%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/10/12/%E8%AF%A6%E8%A7%A3JDK%E9%94%8101-Lock%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="详解JDK锁01：Lock接口"><a href="#详解JDK锁01：Lock接口" class="headerlink" title="详解JDK锁01：Lock接口"></a>详解JDK锁01：Lock接口</h1><h2 id="1-Lock简介"><a href="#1-Lock简介" class="headerlink" title="1. Lock简介"></a>1. Lock简介</h2><p>先引用Lock接口源码中作者贴的一段话</p><blockquote><p>Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more <code>flexible structuring</code>, may have quite <code>different properties</code>, and may support <code>multiple associated Condition objects</code>.</p></blockquote><p>其实这段话就简单概括了Lock的三大优点：</p><ol><li><p>灵活的结构：可以显式地获取与释放锁</p></li><li><p>多种不同的属性与方法</p></li><li><p>引入了 <code>Condition</code> 对象</p></li></ol><p>接下来的部分将着重介绍这几点</p><h2 id="2-Lock锁的灵活性"><a href="#2-Lock锁的灵活性" class="headerlink" title="2. Lock锁的灵活性"></a>2. Lock锁的灵活性</h2><h3 id="2-1-Lock接口方法"><a href="#2-1-Lock接口方法" class="headerlink" title="2.1 Lock接口方法"></a>2.1 Lock接口方法</h3><p>在 JDK5.0 之前，Java是借助于 <code>Synchronized</code> 关键字实现加锁功能，而这个功能是通过JVM实现的。而在 JDK5.0 之后，JUC包中新增了Lock接口实现锁功能。</p><p>虽然该Lock接口不具备 <code>Synchronized</code> 关键字隐式获取锁的便捷性，但是其提供了一系列手动操作锁的方法：</p><ol><li>阻塞式地获取锁</li></ol><p>  该方法有一定的缺陷：如果当前锁被占用，那么当前线程将被禁用，进入阻塞状态，直到获取到锁为止。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li>阻塞式地可打断地获取锁</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><p>  虽然是阻塞式地获取锁，但是如果该线程被中断后，会抛出异常，停止继续阻塞。</p><ol start="3"><li>非阻塞式地获取锁</li></ol><p>  尝试非阻塞地获取锁，调用该方法后立即返回</p><ul><li><p>若能够获取到锁，则返回 true</p></li><li><p>若锁已被占用，则返回 false</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>  该方法的典型使用场景为：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 伪代码</span><br><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ...;<br><span class="hljs-keyword">if</span> (lock.tryLock() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 操作共享资源</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 未获取到锁，执行其余操作</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>带有超时时间地获取锁</li></ol><p>  尝试在指定的一段时间内获取锁</p><ul><li><p>若在指定时间 <code>time</code> 内能够获取到锁，且未被中断，则返回 true</p></li><li><p>若指定时间 <code>time</code> 结束后仍未获取到锁，则返回 false</p></li><li><p>若在指定时间 <code>time</code> 内被打断，则抛出 <code>InterruptedException</code></p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><p>  其中 <code>time</code> 代表指定的超时时间，<code>unit</code> 代表时间单位</p><ol start="5"><li>释放锁</li></ol>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span>()</span>;<br></code></pre></td></tr></table></figure><h3 id="2-2-灵活性体现"><a href="#2-2-灵活性体现" class="headerlink" title="2.2 灵活性体现"></a>2.2 灵活性体现</h3><p>使用 <code>Synchronized</code> 关键字进行获取锁与释放锁操作时：</p><p>当嵌套式地获取锁之后，其释放锁的顺序必须与获取锁的顺序相反</p><p>如下获取锁顺序为：lock1 -&gt; lock2 -&gt; lock3</p><p>释放锁顺序为：lock3 -&gt; lock2 -&gt; lock1</p><p>从外到内获取锁，从内到外释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">lock3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>    System.out.println(<span class="hljs-string">&quot;获取到lock1锁&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>        System.out.println(<span class="hljs-string">&quot;获取到lock2锁&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (lock3) &#123;<br>            System.out.println(<span class="hljs-string">&quot;获取到lock3锁&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是我们假设存在这一业务需求：</p><p>先获取锁A，再获取锁B，再释放锁A，再获取锁C，再释放锁B，再获取锁D。</p><p>这种获取锁的顺序与释放锁的顺序是不固定的，此时无法用 <code>Synchronized</code> 解决。</p><p>而采用Lock接口实现锁则可以完美解决这一问题，因为它提供了手动的加锁解锁方法！</p><h2 id="3-Lock锁的多种功能"><a href="#3-Lock锁的多种功能" class="headerlink" title="3. Lock锁的多种功能"></a>3. Lock锁的多种功能</h2><p>Lock接口中虽然只提供了简单的获取锁与释放锁的基本方法，但是其实现类ReentrantLock中实现了多种方法，提供了不同的功能。</p><blockquote><p>这一篇文章只对Lock接口进行详细介绍，所以以下只做简单的文字介绍。</p><p>后续文章会通过源码解读 <code>ReentrantLock</code></p></blockquote><ol><li>实现公平锁与非公平锁。实例化ReentrantLock时，其有参构造方法中传入的值为boolean类型。若传入值为true，为公平锁；否则为非公平锁</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>判断锁是否已经被持有</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> sync.isLocked();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>判断锁是否为公平锁</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFair</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> sync <span class="hljs-keyword">instanceof</span> FairSync;  <br>&#125;<br></code></pre></td></tr></table></figure><p>相较于Lock接口，<code>Synchronized</code> 只实现了非公平锁。</p><h2 id="4-Condition基本使用"><a href="#4-Condition基本使用" class="headerlink" title="4. Condition基本使用"></a>4. Condition基本使用</h2><p>回顾 <code>Synchronized</code> 关键字，其实现 <code>等待/通知</code> 的模式是通过 <code>Object</code> 类内部的 <code>wait</code>、<code>notify</code> 以及 <code>notifyAll</code> 实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            lock.wait();  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);  <br>        &#125;  <br>        System.out.println(<span class="hljs-string">&quot;Thread1已被唤醒&quot;</span>);  <br>    &#125;  <br>&#125;);  <br>thread1.start();  <br>Thread.sleep(<span class="hljs-number">2000</span>);  <br><span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>    System.out.println(<span class="hljs-string">&quot;唤醒Thread1&quot;</span>);  <br>    lock.notify();  <br>    <span class="hljs-comment">// lock.notifyAll();  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>notify</code> 方法是唤醒 <code>lock</code> 锁上的其中一个线程，<code>notifyAll</code> 方法是唤醒 <code>lock</code> 锁上的全部线程。</p><p>然而，这两种方法均不能指定想要唤醒的线程。</p><p>Condition的出现很好地解决了这一问题，可以分组唤醒想要唤醒的线程。</p><p>如下为Condition的基本实现方式：需要使用 <code>ReentrantLock</code> 实现 <code>Lock</code> 接口</p><blockquote><p>后续文章会详细解读 <code>Condition</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br><span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();  <br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;Thread1进入等待&quot;</span>);  <br>            condition.await();  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);  <br>        &#125;  <br>        System.out.println(<span class="hljs-string">&quot;Thread1已被唤醒&quot;</span>);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;).start();  <br><br>Thread.sleep(<span class="hljs-number">3000</span>);  <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;唤醒Thread1&quot;</span>);  <br>        condition.signal();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;).start();<br></code></pre></td></tr></table></figure><h2 id="5-Lock与Synchronized-对比"><a href="#5-Lock与Synchronized-对比" class="headerlink" title="5. Lock与Synchronized 对比"></a>5. Lock与Synchronized 对比</h2><ol><li><p><code>Lock</code> 所处的层面是JDK，是人为通过Java代码而实现的；而 <code>Synchronized</code> 是Java的关键字，是底层C++语言实现，处于JVM层面。</p></li><li><p><code>Lock</code> 获取和释放锁的顺序不固定，因为其内置了手动操作锁的方法；而 <code>Synchronized</code> 必须按照获取锁的相反顺序去释放锁。</p></li><li><p><code>Lock</code> 可以非阻塞式地获取锁（ <code>tryLock</code> 方法）；而 <code>Synchronized</code> 只能通过阻塞式地获取锁，若当前锁已被其他线程获取，那么该线程只能阻塞等待。</p></li><li><p><code>Lock</code> 既可实现公平锁，也可实现非公平锁；而 <code>Synchronized</code>只能实现非公平锁。</p></li><li><p><code>lock</code> 等待锁过程中可以用 <code>lockInterruptibly</code> 来中断等待，而synchronized只能等待锁的释放，不能响应中断；</p></li></ol><h2 id="6-写在后面"><a href="#6-写在后面" class="headerlink" title="6. 写在后面"></a>6. 写在后面</h2><p>参考文献：</p><blockquote><ol><li><p>JDK5.0源码</p></li><li><p>《Java并发编程的艺术》</p></li><li><p><a href="https://www.bilibili.com/video/BV16J411h7Rd/?spm_id_from=333.337.search-card.all.click&vd_source=4e7654633e4719c03a8fb6c6b524ddc2">黑马Java并发编程教程</a></p></li></ol></blockquote><p>这个系列大概会有5篇左右的样子，我尽可能把自己对于JUC的理解通俗易懂地写出来</p><p>但如果有错误的地方，请大家指出来，我会及时去学习与改进~</p><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
      <tag>Java</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1877. Minimize Maximum Pair Sum in Array</title>
    <link href="/2022/10/11/LC-Solution-1877-Minimize-Maximum-Pair-Sum-in-Array/"/>
    <url>/2022/10/11/LC-Solution-1877-Minimize-Maximum-Pair-Sum-in-Array/</url>
    
    <content type="html"><![CDATA[<h1 id="1877-数组中最大数对和的最小值"><a href="#1877-数组中最大数对和的最小值" class="headerlink" title="1877. 数组中最大数对和的最小值"></a><a href="https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array/">1877. 数组中最大数对和的最小值</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个数对 <code>(a,b)</code> 的 <strong>数对和</strong> 等于 <code>a + b</code> 。<strong>最大数对和</strong> 是一个数对数组中最大的 <strong>数对和</strong> 。</p><ul><li>比方说，如果我们有数对 <code>(1,5)</code> ，<code>(2,3)</code> 和 <code>(4,4)</code>，<strong>最大数对和</strong> 为 <code>max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8</code> 。</li></ul><p>给你一个长度为 <strong>偶数</strong> <code>n</code> 的数组 <code>nums</code> ，请你将 <code>nums</code> 中的元素分成 <code>n / 2</code> 个数对，使得：</p><ul><li><code>nums</code> 中每个元素 <strong>恰好</strong> 在 <strong>一个</strong> 数对中，且</li><li><strong>最大数对和</strong> 的值 <strong>最小</strong> 。</li></ul><p>请你在最优数对划分的方案下，返回最小的 <strong>最大数对和</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[3,5,2,3]</span><br>输出：<span class="hljs-number">7</span><br>解释：数组中的元素可以分为数对 (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>) 和 (<span class="hljs-number">5</span>,<span class="hljs-number">2</span>) 。<br>最大数对和为 <span class="hljs-built_in">max</span>(<span class="hljs-number">3</span>+<span class="hljs-number">3</span>, <span class="hljs-number">5</span>+<span class="hljs-number">2</span>) = <span class="hljs-built_in">max</span>(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>) = <span class="hljs-number">7</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[3,5,4,2,4,6]</span><br>输出：<span class="hljs-number">8</span><br>解释：数组中的元素可以分为数对 (<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)，(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>) 和 (<span class="hljs-number">6</span>,<span class="hljs-number">2</span>) 。<br>最大数对和为 <span class="hljs-built_in">max</span>(<span class="hljs-number">3</span>+<span class="hljs-number">5</span>, <span class="hljs-number">4</span>+<span class="hljs-number">4</span>, <span class="hljs-number">6</span>+<span class="hljs-number">2</span>) = <span class="hljs-built_in">max</span>(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>) = <span class="hljs-number">8</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>n</code> 是 <strong>偶数</strong> 。</li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：贪心-双指针"><a href="#方法一：贪心-双指针" class="headerlink" title="方法一：贪心 + 双指针"></a>方法一：贪心 + 双指针</h3><p>分析题意可知：题目给定了一个偶数长度的 <code>nums</code> 数组，将其两两分组组成数对，使得最终构成的数对数组中的最大数对和尽可能的小。</p><p>数对和意思是：一个数对中的两个数之和</p><p>为了使得最大的数对和尽可能地小，直观判断便是采用贪心思想，使得数组中的最小值与最大值组队，第二小值与第二大值组队 … 依次类推。最终得到的数对数组便可符合这一条件。</p><p>于是根据这一贪心思想，很容易想到算法实现方案 -&gt; 排序双指针，遍历数组</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPairSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        nums.sort()<br>        i, j = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; j:<br>            ans = <span class="hljs-built_in">max</span>(ans, nums[i] + nums[j])<br>            i, j = i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>采用推导式进一步简化代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPairSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        nums.sort()<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[i] + nums[<span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span> - i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)) <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(nums) // <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPairSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>            ans = Math.max(ans, nums[l] + nums[r]);<br>            l++;<br>            r--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第22篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1846. Maximum Element After Decreasing and Rearranging</title>
    <link href="/2022/10/11/LC-Solution-1846-Maximum-Element-After-Decreasing-and-Rearranging/"/>
    <url>/2022/10/11/LC-Solution-1846-Maximum-Element-After-Decreasing-and-Rearranging/</url>
    
    <content type="html"><![CDATA[<h1 id="1846-减小和重新排列数组后的最大元素"><a href="#1846-减小和重新排列数组后的最大元素" class="headerlink" title="1846. 减小和重新排列数组后的最大元素"></a><a href="https://leetcode.cn/problems/maximum-element-after-decreasing-and-rearranging/">1846. 减小和重新排列数组后的最大元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数数组 <code>arr</code> 。请你对 <code>arr</code> 执行一些操作（也可以不进行任何操作），使得数组满足以下条件：</p><ul><li><p><code>arr</code> 中 <strong>第一个</strong> 元素必须为 <code>1</code></p></li><li><p>任意相邻两个元素的差的绝对值 <strong>小于等于</strong> <code>1</code> ，也就是说，对于任意的 <code>1 &lt;= i &lt; arr.length</code> （<strong>数组下标从 0 开始</strong>），都满足 <code>abs(arr[i] - arr[i - 1]) &lt;= 1</code> 。<code>abs(x)</code> 为 <code>x</code> 的绝对值。</p></li></ul><p>你可以执行以下 2 种操作任意次：</p><ul><li><strong>减小</strong> <code>arr</code> 中任意元素的值，使其变为一个 <strong>更小的正整数</strong> 。</li><li><strong>重新排列</strong> <code>arr</code> 中的元素，你可以以任意顺序重新排列。</li></ul><p>请你返回执行以上操作后，在满足前文所述的条件下，<code>arr</code> 中可能的 <strong>最大值</strong> 。</p><p><strong>示例1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[2,2,1,2,1]</span><br>输出：<span class="hljs-number">2</span><br>解释：<br>我们可以重新排列 arr 得到 <span class="hljs-string">[1,2,2,2,1]</span> ，该数组满足所有条件。<br>arr 中最大元素为 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">输入：arr = [100,1,1000]<br>输出：3<br>解释：<br>一个可行的方案如下：<br><span class="hljs-bullet">1.</span> 重新排列 arr 得到 [1,100,1000] 。<br><span class="hljs-bullet">2.</span> 将第二个元素减小为 2 。<br><span class="hljs-bullet">3.</span> 将第三个元素减小为 3 。<br>现在 arr = [1,2,3] ，满足所有条件。<br>arr 中最大元素为 3 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-number">5</span><br>解释：数组已经满足所有条件，最大元素为 <span class="hljs-number">5</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 105</code></li><li><code>1 &lt;= arr[i] &lt;= 109</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：贪心"><a href="#方法一：贪心" class="headerlink" title="方法一：贪心"></a>方法一：贪心</h3><p>分析题意：题目要求通过 <code>减法运算</code> 或 <code>重排序</code> 两种方法，使得数组的两两元素之差的绝对值小于等于1（<code>abs(arr[i] - arr[i - 1]) &lt;= 1</code>），且 <code>arr[0] = 1</code></p><p>于是很容易想到用贪心思想解决本题</p><ol><li><p>允许重排序且题目最终要求返回数组最大值：最终返回结果与数组顺序无关，所以我们可以直接对数组 <code>arr</code> 进行排序。</p></li><li><p><code>arr[0] = 1</code>：从此可以确定对 <code>arr</code> 进行升序排序</p></li><li><p>可以做减法运算：从此条件可以进一步简化题目。既然我们之前已经确定了采用升序排序，那么可以得知此条件始终成立 <code>arr[i] &gt;= arr[i - 1]</code>。</p></li></ol><p>  所以我们遍历 <code>arr</code> 数组时：</p><ol><li><p>无需计算元素之差的绝对值</p></li><li><p>当不满足元素之差小于等于1的条件（ <code>arr[i] &gt; arr[i] + 1</code> ）时，只需 <code>arr[i] = arr[i -1] + 1</code>，使较大的值等于较小的值加1，相当于对较大的值做减法运算</p></li></ol><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumElementAfterDecrementingAndRearranging</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        arr.sort()<br>        arr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(arr)):<br>            <span class="hljs-keyword">if</span> arr[i] - arr[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span>:<br>                arr[i] = arr[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> arr[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumElementAfterDecrementingAndRearranging</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        Arrays.sort(arr);<br>        arr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[i] - arr[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span>) &#123;<br>               arr[i] = arr[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[arr.length - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第21篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1833. Maximum Ice Cream Bars</title>
    <link href="/2022/10/11/LC-Solution-1833-Maximum-Ice-Cream-Bars/"/>
    <url>/2022/10/11/LC-Solution-1833-Maximum-Ice-Cream-Bars/</url>
    
    <content type="html"><![CDATA[<h1 id="1833-雪糕的最大数量"><a href="#1833-雪糕的最大数量" class="headerlink" title="1833. 雪糕的最大数量"></a><a href="https://leetcode.cn/problems/maximum-ice-cream-bars/">1833. 雪糕的最大数量</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。</p><p>商店中新到 <code>n</code> 支雪糕，用长度为 <code>n</code> 的数组 <code>costs</code> 表示雪糕的定价，其中 <code>costs[i]</code> 表示第 <code>i</code> 支雪糕的现金价格。Tony 一共有 <code>coins</code> 现金可以用于消费，他想要买尽可能多的雪糕。</p><p>给你价格数组 <code>costs</code> 和现金量 <code>coins</code> ，请你计算并返回 Tony 用 <code>coins</code> 现金能够买到的雪糕的 <strong>最大数量</strong> 。</p><p><strong>注意：</strong> Tony 可以按任意顺序购买雪糕。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：costs = [1,3,2,4,1], coins = 7<br>输出：4<br>解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>= 7<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：costs = <span class="hljs-string">[10,6,8,7,7,8]</span>, coins = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">0</span><br>解释：Tony 没有足够的钱买任何一支雪糕。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：costs = [1,6,3,1,2,5], coins = 20<br>输出：6<br>解释：Tony 可以买下所有的雪糕，总价为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 18 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>costs.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= costs[i] &lt;= 105</code></li><li><code>1 &lt;= coins &lt;= 108</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：贪心"><a href="#方法一：贪心" class="headerlink" title="方法一：贪心"></a>方法一：贪心</h3><p>用有限的钱，买到最多的雪糕。</p><p>从此很容易可以想到，对于价格便宜的雪糕，购买优先级高。</p><p>因此，对雪糕的价格数组 <code>costs</code> 进行排序。</p><p>每个雪糕只能买一次，因此遍历 <code>costs</code> 数组，用 <code>cnt</code> 计数买到雪糕的数量。</p><p>当将 <code>coins</code> 花完的时候，便可以得到可以购买的最大数量。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxIceCream</span>(<span class="hljs-params">self, costs: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], coins: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        costs.sort()<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> costs:<br>            <span class="hljs-keyword">if</span> coins - c &gt;= <span class="hljs-number">0</span>:<br>                coins -= c<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxIceCream</span><span class="hljs-params">(<span class="hljs-type">int</span>[] costs, <span class="hljs-type">int</span> coins)</span> &#123;<br>        Arrays.sort(costs);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c : costs) &#123;<br>            <span class="hljs-keyword">if</span>(coins - c &gt;= <span class="hljs-number">0</span>) &#123;<br>                coins -= c;<br>                cnt++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第20篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1790. Check if One String Swap Can Make Strings Equal</title>
    <link href="/2022/10/11/LC-Solution-1790-Check-if-One-String-Swap-Can-Make-Strings-Equal/"/>
    <url>/2022/10/11/LC-Solution-1790-Check-if-One-String-Swap-Can-Make-Strings-Equal/</url>
    
    <content type="html"><![CDATA[<h1 id="1790-仅执行一次字符串交换能否使两个字符串相等"><a href="#1790-仅执行一次字符串交换能否使两个字符串相等" class="headerlink" title="1790. 仅执行一次字符串交换能否使两个字符串相等"></a><a href="https://leetcode.cn/problems/check-if-one-string-swap-can-make-strings-equal/">1790. 仅执行一次字符串交换能否使两个字符串相等</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你长度相等的两个字符串 <code>s1</code> 和 <code>s2</code> 。一次 <strong>字符串交换</strong> 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。</p><p>如果对 <strong>其中一个字符串</strong> 执行 <strong>最多一次字符串交换</strong> 就可以使两个字符串相等，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;bank&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;kanb&quot;</span><br>输出：true<br>解释：例如，交换 <span class="hljs-built_in">s2</span> 中的第一个和最后一个字符可以得到 <span class="hljs-string">&quot;bank&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;attack&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;defend&quot;</span><br>输出：false<br>解释：一次字符串交换无法使两个字符串相等<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;kelb&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;kelb&quot;</span><br>输出：true<br>解释：两个字符串已经相等，所以不需要进行字符串交换<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;dcba&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li><code>1 &lt;= s1.length, s2.length &lt;= 100</code></li><li><code>s1.length == s2.length</code></li><li><code>s1</code> 和 <code>s2</code> 仅由小写英文字母组成</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：哈希表-计数"><a href="#方法一：哈希表-计数" class="headerlink" title="方法一：哈希表 + 计数"></a>方法一：哈希表 + 计数</h3><p>思路：</p><ul><li><p>先用哈希表统计字符串 <code>s1</code> 与 <code>s2</code> 的词频，只有词频相同的情况下，才可能满足题目要求的交换一次便得到相同字符串。</p></li><li><p>计数：遍历，对两个字符串逐个判断，得到不同字符数量 <code>cnt</code> 。</p><ul><li>若 <code>s1[i] != s2[i]</code>，<code>cnt += 1</code></li></ul></li><li><p>最终，当 <code>cnt == 0</code> 或 <code>cnt == 2</code>，分别对应着交换次数为0和交换次数为1的情况。（前提是两字符串词频相同）</p></li></ul><p>该方法缺点在于空间复杂度为O(n)</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">areAlmostEqual</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        dic1, dic2 = Counter(s1), Counter(s2)<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s1)):<br>            <span class="hljs-keyword">if</span> s1[i] != s2[i]:<br>                cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> (cnt == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt == <span class="hljs-number">2</span>) <span class="hljs-keyword">and</span> dic1 == dic2<br></code></pre></td></tr></table></figure><h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">areAlmostEqual</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray();<br>        Map&lt;Character, Integer&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(), map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs1.length; i++) &#123;<br>            map1.put(cs1[i], map1.getOrDefault(cs1[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            map2.put(cs2[i], map2.getOrDefault(cs2[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(cs1[i] != cs2[i]) cnt++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (cnt == <span class="hljs-number">0</span> || cnt == <span class="hljs-number">2</span>) &amp;&amp; map1.equals(map2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：纯计数"><a href="#方法二：纯计数" class="headerlink" title="方法二：纯计数"></a>方法二：纯计数</h3><p>思路：</p><p>仍然是同时遍历两字符串 <code>s1</code> 与 <code>s2</code>，用 <code>cnt</code> 统计相同下标不同字符的数量。</p><p>但不采用哈希表统计词频，而是用两个变量 <code>c1</code> 与 <code>c2</code> 记录上一次相同下标的情况下 <code>s1</code> 与 <code>s2</code> 不相同的字符。</p><p>若 <code>cnt == 2</code>时，当前 <code>s1[i] != c2</code> 或 <code>s2[i] != c1</code>，此时可能出现如下情况</p><ul><li><p><code>bank</code> 与 <code>canb</code>，隐含的意思就是两字符串词频不同，只不过这个方法咱们没有用哈希表进行统计。</p><p>因为题目中说只可交换一次，所以只需判断 <code>cnt == 2</code> 这种情况下词频是否相同。</p></li></ul><p>最终遍历完成之后，还需要判断 cnt 是否等于 1，防止出现如下情况</p><ul><li><code>bank</code> 与 <code>cank</code>，只有一个下标的字符不相同，隐含意思是词频不相同，无法交换。</li></ul><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">areAlmostEqual</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        cnt = <span class="hljs-number">0</span><br>        c1, c2 = <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s1)):<br>            <span class="hljs-keyword">if</span> s1[i] != s2[i]:<br>                cnt += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> cnt &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> (cnt == <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> (s1[i] != c2 <span class="hljs-keyword">or</span> s2[i] != c1)):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                c1, c2 = s1[i], s2[i]<br>        <span class="hljs-keyword">return</span> cnt != <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">areAlmostEqual</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, c2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs1.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(cs1[i] != cs2[i]) &#123;<br>                <span class="hljs-keyword">if</span>(++cnt &gt; <span class="hljs-number">2</span> || (cnt == <span class="hljs-number">2</span> &amp;&amp; (cs1[i] != c2 || cs2[i] != c1))) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                c1 = cs1[i];<br>                c2 = cs2[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt != <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第19篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1249. Minimum Remove to Make Valid Parentheses</title>
    <link href="/2022/10/09/LC-Solution-1249-Minimum-Remove-to-Make-Valid-Parentheses/"/>
    <url>/2022/10/09/LC-Solution-1249-Minimum-Remove-to-Make-Valid-Parentheses/</url>
    
    <content type="html"><![CDATA[<h1 id="1249-移除无效的括号"><a href="#1249-移除无效的括号" class="headerlink" title="1249. 移除无效的括号"></a><a href="https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/">1249. 移除无效的括号</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个由 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 和小写字母组成的字符串 <code>s</code>。</p><p>你需要从字符串中删除最少数目的 <code>&#39;(&#39;</code> 或者 <code>&#39;)&#39;</code> （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p><p>请返回任意一个合法字符串。</p><p>有效「括号字符串」应当符合以下 <strong>任意一条</strong> 要求：</p><ul><li>空字符串或只包含小写字母的字符串</li><li>可以被写作 <code>AB</code>（<code>A</code> 连接 <code>B</code>）的字符串，其中 <code>A</code> 和 <code>B</code> 都是有效「括号字符串」</li><li>可以被写作 <code>(A)</code> 的字符串，其中 <code>A</code> 是一个有效的「括号字符串」</li></ul><p><strong>示例1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;lee(t(c)o)de)&quot;</span><br>输出：<span class="hljs-string">&quot;lee(t(c)o)de&quot;</span><br>解释：<span class="hljs-string">&quot;lee(t(co)de)&quot;</span> , <span class="hljs-string">&quot;lee(t(c)ode)&quot;</span> 也是一个可行答案。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a)b(c)d&quot;</span><br>输出：<span class="hljs-string">&quot;ab(c)d&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;))((&quot;</span><br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：空字符串也是有效的<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 可能是 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 或英文小写字母</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：栈"><a href="#方法一：栈" class="headerlink" title="方法一：栈"></a>方法一：栈</h3><p>一看到合法括号题，第一反应首先想到用栈解决。</p><p>题目要求删掉字符串 <code>s</code> 中的无效括号，使得剩余的所有括号构成有效括号，要求删除次数尽可能的少。</p><p>简单直接地理解题目：对 <code>s</code> 做减法，删除左右括号中数量较多的一方以达成有效括号</p><p>但是应思考如何尽可能地优雅且简单地从字符串中删除对应的字符</p><p>如果直接对字符串动手脚，下标会产生变化。</p><p><strong>思路转化：</strong></p><p>选择将字符串 <code>s</code> 转为数组，将需要删除的括号置为空即代表删除。</p><p>栈用于存储 <code>&#39;(&#39;</code> 的下标，便于通过下标对字符串数组进行操作。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minRemoveToMakeValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        stack, s = [], <span class="hljs-built_in">list</span>(s)<br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                stack.append(i)<br>            <span class="hljs-keyword">elif</span> x == <span class="hljs-string">&#x27;)&#x27;</span>:<br>                <span class="hljs-keyword">if</span> stack:<br>                    stack.pop()<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 此时没有&#x27;(&#x27;与&#x27;)&#x27;配对，删除</span><br>                    s[i] = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-comment"># 栈中剩余的均为&#x27;(&#x27;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> stack:<br>            <span class="hljs-comment"># 此时没有&#x27;)&#x27;与&#x27;(&#x27;配对，删除</span><br>            s[i] = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(s)<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>Java无法直接对字符赋空值，先填一个占位字符，之后利用replace方法将其替换为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minRemoveToMakeValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(cs[i] == <span class="hljs-string">&#x27;(&#x27;</span>) stack.addLast(i);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cs[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span>(!stack.isEmpty()) stack.pollLast();<br>                <span class="hljs-keyword">else</span> cs[i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : stack) cs[i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(cs).replace(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第18篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 678. Valid Parenthesis String</title>
    <link href="/2022/10/09/LC-Solution-678-Valid-Parenthesis-String/"/>
    <url>/2022/10/09/LC-Solution-678-Valid-Parenthesis-String/</url>
    
    <content type="html"><![CDATA[<h1 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a href="https://leetcode.cn/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包含三种字符的字符串：<code>（</code> ，<code>）</code> 和 <code>*</code>，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p><ol><li>任何左括号 <code>(</code> 必须有相应的右括号 <code>)</code>。</li><li>任何右括号 <code>)</code> 必须有相应的左括号 <code>(</code> 。</li><li>左括号 <code>(</code> 必须在对应的右括号之前 <code>)</code>。</li><li><code>*</code> 可以被视为单个右括号 <code>)</code> ，或单个左括号 <code>(</code> ，或一个空字符串。</li><li>一个空字符串也被视为有效字符串。</li></ol><p><strong>示例1：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;()&quot;</span><br>输出: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;(*)&quot;</span><br>输出: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;(*))&quot;</span><br>输出: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>字符串大小将在 [1，100] 范围内。</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：双栈"><a href="#方法一：双栈" class="headerlink" title="方法一：双栈"></a>方法一：双栈</h3><p>遇到括号题，第一反应便是栈。因为栈的先进后出的特性与括号之间嵌套的特性相一致。</p><p>栈内总是存储左括号 <code>&#39;(&#39;</code>，通过右括号 <code>&#39;)&#39;</code> 与左括号 <code>&#39;(&#39;</code> 配对，使左括号出栈。</p><p>本题思路：</p><p><code>&#39;*&#39;</code> 可以表示三种字符：<code>&#39;&#39;</code> 、 <code>&#39;(&#39;</code> 、<code>&#39;)&#39;</code>，优先将 <code>&#39;*&#39;</code> 当作左括号使用。</p><p>因此使用两个栈分别存储 <code>&#39;*&#39;</code> 与 <code>&#39;(&#39;</code> 对应于 <code>s</code> 的下标。</p><ul><li><p>存储下标的意义在于：由于我们是优先将 <code>&#39;*&#39;</code> 当作左括号使用，当右括号 <code>&#39;)&#39;</code> 全部消耗完。这时候多余的 <code>&#39;*&#39;</code> 将要作为右括号 <code>&#39;)&#39;</code> 与剩余的 <code>&#39;(&#39;</code> 进行配对。右括号必须在左括号之后。因此存储下标可以帮助我们判断 <code>&#39;*&#39;</code> 与 <code>&#39;(&#39;</code> 的先后顺序是否符合合法括号的要求。</p><p><code>&#39;(&#39;</code> 使用优先级 <strong>大于</strong> <code>&#39;*&#39;</code></p></li></ul><ol><li>遍历字符串 <code>s</code> ：</li></ol><p>  . 若 <code>s[i] == &#39;(&#39;</code>， 将其添加到 <code>&#39;(&#39;</code> 栈中</p><p>  . 若 <code>s[i] == &#39;*&#39;</code>， 将其添加到 <code>&#39;*&#39;</code> 栈中</p><p>  . 若 <code>s[i] == &#39;*&#39;</code>：</p><p>  . <code>&#39;(&#39;</code> 栈 或 <code>&#39;*&#39;</code> 栈不为空时，优先使用 <code>&#39;(&#39;</code> 栈进行出栈</p><p>  . 否则，没有字符与 <code>&#39;(&#39;</code> 进行配对，返回 <code>False</code></p><ol start="2"><li>遍历 <code>&#39;(&#39;</code> 与 <code>&#39;*&#39;</code> 栈，将 <code>&#39;*&#39;</code> 当作 <code>&#39;)&#39;</code> 与 剩余 <code>&#39;(&#39;</code> 进行匹配</li></ol><p>  . 若弹出的 <code>&#39;*&#39;</code> 下标 <strong>小于</strong> 弹出的 <code>&#39;(&#39;</code>， 返回False</p><ol start="3"><li>最终判断是否仍然有剩余的 <code>&#39;(&#39;</code></li></ol><p>  . 若仍然有，返回False；否则，返回True</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkValidString</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        stack1, stack2 = [], []<br>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                stack1.append(i)<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                stack2.append(i)<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;)&#x27;</span>:<br>                <span class="hljs-keyword">if</span> stack1:<br>                    stack1.pop()<br>                <span class="hljs-keyword">elif</span> stack2:<br>                    stack2.pop()<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">while</span> stack1 <span class="hljs-keyword">and</span> stack2:<br>            idx1, idx2 = stack1.pop(), stack2.pop()<br>            <span class="hljs-keyword">if</span> idx1 &gt; idx2:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> stack1<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkValidString</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        Deque&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(cs[i] == <span class="hljs-string">&#x27;(&#x27;</span>) stack1.addLast(i);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cs[i] == <span class="hljs-string">&#x27;*&#x27;</span>) stack2.addLast(i);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(!stack1.isEmpty()) stack1.pollLast();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!stack2.isEmpty()) stack2.pollLast();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!stack1.isEmpty() &amp;&amp; !stack2.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx1</span> <span class="hljs-operator">=</span> stack1.pollLast(), idx2 = stack2.pollLast();<br>            <span class="hljs-keyword">if</span>(idx1 &gt; idx2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack1.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第17篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 856. Score of Parentheses</title>
    <link href="/2022/10/09/LC-Solution-856-Score-of-Parentheses/"/>
    <url>/2022/10/09/LC-Solution-856-Score-of-Parentheses/</url>
    
    <content type="html"><![CDATA[<h1 id="856-Score-of-Parentheses"><a href="#856-Score-of-Parentheses" class="headerlink" title="856. Score of Parentheses"></a><a href="https://leetcode.cn/problems/score-of-parentheses/">856. Score of Parentheses</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个平衡括号字符串 <code>S</code>，按下述规则计算该字符串的分数：</p><ul><li><code>()</code> 得 1 分。</li><li><code>AB</code> 得 <code>A + B</code> 分，其中 A 和 B 是平衡括号字符串。</li><li><code>(A)</code> 得 <code>2 * A</code> 分，其中 A 是平衡括号字符串。</li></ul><p><strong>示例1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入： <span class="hljs-string">&quot;()&quot;</span><br>输出： <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入： <span class="hljs-string">&quot;(())&quot;</span><br>输出： <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">输入： &quot;()()&quot;<br>输出： <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">输入： &quot;(()(()))&quot;<br>输出： <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>S</code> 是平衡括号字符串，且只含有 <code>(</code> 和 <code>)</code> 。</li><li><code>2 &lt;= S.length &lt;= 50</code></li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：根据-计数"><a href="#方法一：根据-计数" class="headerlink" title="方法一：根据()计数"></a>方法一：根据()计数</h3><p>分析题意可知，外层括号所累加的分数都与最里括号 <code>&#39;()&#39;</code> 有关。</p><ul><li><p>假设当前括号深度为 <code>d</code>，每一个 <code>&#39;()&#39;</code> 的得分为 <code>2 ** d</code> 或者 <code>1 &lt;&lt; d</code></p></li><li><p>最后的总分数与 <code>&#39;()&#39;</code> 的数量有关。</p></li></ul><p>举例说明：<code>&#39;(()(()))&#39;</code>，利用乘法分配律可表示为 <code>&#39;(()) + ((()))&#39;</code></p><p>共有两个 <code>&#39;()&#39;</code>，其分数为 <code>2 ** 1 + 2 ** 2 = 6</code></p><p>所以，我们只需要找到 <code>s</code> 中的每一个 <code>&#39;()&#39;</code> 即可</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">scoreOfParentheses</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans, d = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            d += <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> v == <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> v == <span class="hljs-string">&#x27;)&#x27;</span> <span class="hljs-keyword">and</span> s[i - <span class="hljs-number">1</span>] ==<span class="hljs-string">&#x27;(&#x27;</span>:<br>                ans += <span class="hljs-number">1</span> &lt;&lt; d<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">scoreOfParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, d = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            d += s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                ans += <span class="hljs-number">1</span> &lt;&lt; d;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：栈"><a href="#方法二：栈" class="headerlink" title="方法二：栈"></a>方法二：栈</h3><p>采用栈记录字符串 <code>s</code> 对应的分数。初始栈顶部的分数为0。</p><p>遍历字符串：</p><ol><li><p>若 <code>s[i] == &#39;(&#39;</code>，先将分数0压入栈顶占位</p></li><li><p>若 <code>s[i] == &#39;)&#39;</code>，此时有两种情况：</p></li></ol><ul><li><p><code>s[i - 1] == &#39;(&#39;</code>，这是一个 <code>&#39;()&#39;</code>， 此时栈顶值 <code>v</code> 为0，该分数为1</p></li><li><p><code>s[i - 1] != &#39;(&#39;</code>，这是一个外层括号，该分数为栈顶值 <code>v</code> × 2</p></li></ul><p>  两种情况综合为 <code>max(v * 2, 1)</code></p><p>  将栈顶值出栈计算完成之后，再将计算结果累加到当前的栈顶值。</p><p>最终返回结果为栈顶值。</p><p>这是因为一开始还未遍历字符串 <code>s</code> 时，就已经初始化了栈顶值。而且该字符串 <code>s</code> 为平衡括号字符串，说明 <code>&#39;(&#39; </code>与 <code>&#39;)&#39;</code> 数量一致，所以最后栈中一个值，即为最终分数。</p><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">scoreOfParentheses</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        stack = [<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                stack.append(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">else</span>:<br>                v = stack.pop()<br>                stack[-<span class="hljs-number">1</span>] += <span class="hljs-built_in">max</span>(v * <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> stack[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">scoreOfParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        stack.addLast(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span>) stack.addLast(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> stack.pollLast();<br>                stack.addLast(stack.pollLast() + Math.max(v * <span class="hljs-number">2</span>, <span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.pollLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第16篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式锁学习笔记</title>
    <link href="/2022/10/09/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/09/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式锁学习笔记"><a href="#分布式锁学习笔记" class="headerlink" title="分布式锁学习笔记"></a>分布式锁学习笔记</h1><p>分布式锁学习笔记持续更新中，预计10月下旬更完~ </p><p>该笔记中除了视频中核心的笔记、代码，还额外补充了视频中老师讲解过的但官方笔记中没有提到的重要内容。 </p><p>有错误或者遗漏的地方请大家提出来呀，有不懂的地方留言我尽量回答（毕竟我也很菜~</p><p>2022.10.14:更换图床解决了图片加载问题</p><p>2022.10.16:基于Redis的分布式锁笔记已更完…（p51之前）</p><p>2022.10.17:zookeeper基础已更完…（p62之前）</p><p>2022.10.21:完结撒花~，笔记全部做完啦（Curator底层原理加锁部分待完善…</p><h2 id="1-传统锁-减库存案例"><a href="#1-传统锁-减库存案例" class="headerlink" title="1. 传统锁 - 减库存案例"></a>1. 传统锁 - 减库存案例</h2><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/stock.png"></p><p>多线程同时操纵同一个服务的共享资源，必然会造成线程安全问题。</p><p>解决方案：采用JVM提供的 <code>Reentrantlock</code> 或者 <code>Synchronized</code> 锁</p><h3 id="1-1-初始化工程"><a href="#1-1-初始化工程" class="headerlink" title="1.1 初始化工程"></a>1.1 初始化工程</h3><p>这一部分跟着视频完成，以下内容省略了未连接数据库之前的部分（个人认为之前未连接数据库的部分仅演示了并发流程，与实际业务关联性不大，也较为容易，可自行实现）。</p><ol><li><p>创建SpringBoot工程，选择 <code>JDK8</code> 版本，引入 <code>Spring Web</code></p></li><li><p>在 <code>pom.xml</code>引入如下依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>创建数据库 <code>distributed_lock</code>，在数据库内创建表 <code>db_stock</code>，创建如下字段。</p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008221626.png"></p><p> 新建一条数据记录</p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008221728.png"></p></li><li><p>修改application.properties文件，规定Web启动端口号</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">10010</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/distributed_lock</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">your password</span><br></code></pre></td></tr></table></figure></li><li><p>在目录下创建 <code>pojo</code> 包，用于存放实体类 <code>Stock</code> 对象</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;db_stock&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span> &#123;<br><br><span class="hljs-keyword">private</span> Long id;<br><span class="hljs-keyword">private</span> String productCode;<br><span class="hljs-keyword">private</span> String warehouse;<br><span class="hljs-keyword">private</span> Integer count;<br>&#125;<br></code></pre></td></tr></table></figure><p> 创建 <code>mapper</code> 包，创建 <code>StockMapper</code> 类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StockMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Stock&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p> 更改 <code>SpringBoot</code> 启动类，添加如下注解</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.ltyzzz.distributedlock.mapper&quot;)</span><br></code></pre></td></tr></table></figure><p> 创建 <code>service</code> 包，创建 <code>StockService</code> 类</p><p> try-finally块之后用于加锁</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockService</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StockMapper stockMapper;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stockMapper.selectOne(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;product_code&quot;</span>, <span class="hljs-string">&quot;1001&quot;</span>));<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>            stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">this</span>.stockMapper.updateById(stock);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 创建 <code>controller</code> 包，创建 <code>StockController</code> 类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    StockService stockService;<br><br>    <span class="hljs-meta">@GetMapping(&quot;stock/deduct&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>        stockService.deduct();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello stock deduct!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-2-JVM本地锁"><a href="#1-2-JVM本地锁" class="headerlink" title="1.2 JVM本地锁"></a>1.2 JVM本地锁</h3><h4 id="1-2-1-使用JMeter进行并发测试"><a href="#1-2-1-使用JMeter进行并发测试" class="headerlink" title="1.2.1 使用JMeter进行并发测试"></a>1.2.1 使用JMeter进行并发测试</h4><p>首先启动 SpringBoot 库存项目</p><p>利用 <code>JMeter</code> 进行压力测试</p><ol><li><p>创建 <code>Thread Group</code></p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/thread-group.png"></p></li><li><p>设置 <code>Thread Properties</code></p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/thread-proper.png"></p></li><li><p>设置 <code>request</code> </p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/reque.png"></p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008224501.png"></p></li><li><p>添加 <code>Aggregate Report</code></p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008224122.png"></p></li><li><p>运行压力测试，正常执行情况最终库存应该为0</p></li></ol><p>最终数据库结果如下</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/data%20stcok.png"></p><p>此时产生了并发操作</p><p>有两种极限情况</p><ul><li><p>所有并发请求都完美的交错执行，正确地完成了数据库更新，最终库存为0</p></li><li><p>所有并发请求同一时间并发，同时执行了数据库更新操作，并发线程数为100，循环次数为50，最终库存为4950</p></li></ul><h4 id="1-2-2-加入JVM本地锁解决并发问题"><a href="#1-2-2-加入JVM本地锁解决并发问题" class="headerlink" title="1.2.2 加入JVM本地锁解决并发问题"></a>1.2.2 加入JVM本地锁解决并发问题</h4><p>修改 <code>StockService</code>。使用 <code>ReentrantLock</code> 或 <code>Synchronized</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StockMapper stockMapper;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stockMapper.selectOne(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;product_code&quot;</span>, <span class="hljs-string">&quot;1001&quot;</span>));<br>            <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>                stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">this</span>.stockMapper.updateById(stock);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动 <code>SpringBoot</code> 工程，继续进行压力测试，最终库存为0。</p><h4 id="1-2-3-JVM本地锁失效的情况"><a href="#1-2-3-JVM本地锁失效的情况" class="headerlink" title="1.2.3 JVM本地锁失效的情况"></a>1.2.3 JVM本地锁失效的情况</h4><p>共有三种情况</p><h5 id="多例模式"><a href="#多例模式" class="headerlink" title="多例模式"></a>多例模式</h5><p>修改 <code>StockService</code>，设置多例模式</p><p>添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scope(value = &quot;prototype&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br></code></pre></td></tr></table></figure><p>JDK动态代理使用 <code>INTERFACES</code>，CGLIB代理使用 <code>TARGET_CLASS</code></p><p>默认情况下使用JDK动态代理，原生Spring默认是JDK动态代理</p><p>而SpringBoot在2.0版本之后默认使用CGLIB代理</p><p>启动 <code>SpringBoot</code> 工程，继续进行压力测试，最终库存不为0，说明本地锁失效</p><h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>在 <code>service</code> 方法上添加事务注解 <code>@Transactional</code></p><p>启动 <code>SpringBoot</code> 工程，继续进行压力测试，最终库存不为0，说明本地锁失效</p><p>事务采用AOP思想实现：</p><ol><li><p>在AOP的前置方法内开启事务</p></li><li><p>进入service方法，获取锁</p></li><li><p>进行查询库存、更新库存操作</p></li><li><p>释放锁</p></li><li><p>在AOP的后置方法内提交或回滚事务</p></li></ol><p>在并发情况下，如图所示</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/tab.png" title="" alt="" width="236"><p>b用户在a用户还未提交事务之前，就获取到了a用户释放的锁，读取到了库存，但该库存为旧的库存（因为a用户还未提交事务），所以b用户是在旧库存的基础上进行修改，因此产生了并发问题。</p><p>解决方案：设置事务隔离级别</p><p>将注解改为：<code>@Transactional(isolation = Isolation.READ_UNCOMMITTED)</code></p><p>即此时b用户可以读取到a用户未提交的数据，即该数据为最新数据，可以解决此问题。</p><p>但实际业务中不能这样去使用，采用事务就是为了保证原子性，要么全部成功，要么全部失败。假设b用户在这种方式下读取到了最新数据，虽然可以解决超卖问题，但是如果a回滚了事务，那么b用户读取到的数据就是错误的，又会产生新的混乱。</p><h5 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h5><p>多个服务器部署</p><p>去掉 <code>@Transactional</code> 注解，保证在单机模式下锁生效，无并发问题。</p><p>这部分看视频做</p><ol><li><p>设置两个SpringBoot启动类，设置不同的端口号，并启动</p></li><li><p>更改 <code>nginx</code> 配置文件</p> <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> distributedLock &#123;<br>    <span class="hljs-attribute">server</span> localhost:<span class="hljs-number">10086</span>;<br>    <span class="hljs-attribute">server</span> localhost:<span class="hljs-number">10010</span>;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://distributedLock;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启动nginx</p></li></ol><p>任务管理器中出现两个nginx即代表启动成功，一个工作进程，一个主进程</p><p>以默认端口80进行访问：<code>localhost:80/stock/deduct</code></p><p>之后，使用JMeter进行压力测试，5000个请求成功发出，但最终库存不为0，锁失效。</p><h3 id="1-3-单SQL语句解决并发问题"><a href="#1-3-单SQL语句解决并发问题" class="headerlink" title="1.3 单SQL语句解决并发问题"></a>1.3 单SQL语句解决并发问题</h3><h4 id="1-3-1-实现过程"><a href="#1-3-1-实现过程" class="headerlink" title="1.3.1 实现过程"></a>1.3.1 实现过程</h4><p>原 <code>Service</code> 代码流程</p><ol><li><p>查询库存</p></li><li><p>判断库存是否充足</p></li><li><p>更新库存到数据库</p></li></ol><p>该流程可以使用一个SQL语句实现</p><p>为 <code>StockMapper</code> 添加方法 updateStock，</p><p>参数为商品编号 <code>productCode</code> 与减库存数量<code>count</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StockMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Stock&gt; &#123;<br>    <span class="hljs-meta">@Update(&quot;update db_stock set count = count - #&#123;count&#125; where product_code = #&#123;productCode&#125; and count &gt;= #&#123;count&#125;&quot;)</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateStock</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;productCode&quot;)</span> String productCode, <span class="hljs-meta">@Param(&quot;count&quot;)</span> Integer count)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>SQL语句如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">update</span> db_stock <span class="hljs-keyword">set</span> <span class="hljs-built_in">count</span> = <span class="hljs-built_in">count</span> - #&#123;<span class="hljs-built_in">count</span>&#125; <span class="hljs-keyword">where</span> product_code = #&#123;productCode&#125; <span class="hljs-keyword">and</span> <span class="hljs-built_in">count</span> &gt;= #&#123;<span class="hljs-built_in">count</span>&#125;<br></code></pre></td></tr></table></figure><p>在MySQL中，更新、新增、删除写操作，会加悲观锁，具有原子性，可以解决并发问题。</p><p>在 <code>StockService</code> 中调用该Mapper方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockMapper.updateStock(<span class="hljs-string">&quot;1001&quot;</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在集群部署情况下，使用JMeter进行压力测试，5000个请求成功发出，最终库存为0。</p><h4 id="1-3-2-优缺点"><a href="#1-3-2-优缺点" class="headerlink" title="1.3.2 优缺点"></a>1.3.2 优缺点</h4><p>优点：</p><ol><li>可以解决多例模式、事务、集群部署下的并发问题</li></ol><p>缺点：</p><ol><li><p>锁范围问题</p></li><li><p>同一个商品有多条库存记录（多仓库）</p><ul><li><p>如果仍然使用该方法，则会对所有仓库库存数进行自减</p></li><li><p>正常情况应灵活从各个仓库进行减库存发货</p></li></ul></li><li><p>无法记录库存变化前后的状态</p><ul><li>原因：单条SQL语句</li></ul></li></ol><h5 id="锁范围问题"><a href="#锁范围问题" class="headerlink" title="锁范围问题"></a>锁范围问题</h5><p>表级锁 VS 行级锁</p><ul><li><p>未添加索引之前为 <code>表级锁</code></p><ul><li><p>在用户a中，先开启事务，再去更新 <code>productCode = 1001</code> 记录，但不提交事务</p></li><li><p>这导致：在用户b中，更新 <code>productCode = 1002</code> 记录，但进入了阻塞</p></li><li><p>用户a提交了事务之后，用户b才能提交成功，证明为表级锁</p></li></ul></li><li><p>添加索引之后为 <code>行级锁</code></p><ol><li><p>锁的查询或更新条件必须为索引字段</p><p> e.g.：根据 <code>productCode</code> 进行查询或更新，为其添加索引</p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/iShot2022-10-08%2023.44.31.png"></p></li><li><p>再次进行之前的操作，用户b不会进入阻塞，即变为了行级锁</p></li><li><p>使用行级锁的条件：</p><p> . 查询或者更新条件必须为索引字段</p><p> . 查询或者更新条件必须为具体值</p><p>   . SQL语句中where条件有索引时，不能为 <code>&#39;like&#39;</code> 或者 <code>&#39;!=&#39;</code>，否则为表级锁</p></li></ol></li></ul><h3 id="1-4-悲观锁"><a href="#1-4-悲观锁" class="headerlink" title="1.4 悲观锁"></a>1.4 悲观锁</h3><p>select … for update</p><h4 id="1-4-1-情景引入"><a href="#1-4-1-情景引入" class="headerlink" title="1.4.1 情景引入"></a>1.4.1 情景引入</h4><p>用户a与b并发执行</p><ol><li><p>用户a开启事务，并使用如下SQL语句查询库存</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> db_stock <span class="hljs-keyword">where</span> product_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1001&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>用户b使用如下SQL语句</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> db_stock <span class="hljs-keyword">set</span> count <span class="hljs-operator">=</span> count <span class="hljs-operator">-</span> <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li></ol><p>这时库存已经发生变化，而用户a不知情，仍会已它查出来的库存数作为标准进行下一步操作</p><p>解决方案：用户a采用如下SQL语句，进行加锁操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> db_stock <span class="hljs-keyword">where</span> product_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1001&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>加锁范围：此时满足行级锁条件，因此该悲观锁为行级锁，只锁对应的记录</p><h4 id="1-4-2-代码实现"><a href="#1-4-2-代码实现" class="headerlink" title="1.4.2 代码实现"></a>1.4.2 代码实现</h4><ol><li><p>在StockMapper中添加查询库存方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from db_stock where product_code=#&#123;productCode&#125; for update&quot;)</span><br>List&lt;Stock&gt; <span class="hljs-title function_">queryStock</span><span class="hljs-params">(String productCode)</span>;<br></code></pre></td></tr></table></figure></li><li><p>更新StockService方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询库存信息并锁定</span><br>    List&lt;Stock&gt; stocks = <span class="hljs-built_in">this</span>.stockMapper.queryStock(<span class="hljs-string">&quot;1001&quot;</span>);<br>    <span class="hljs-comment">// 取第一个库存</span><br>    <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> stocks.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 扣减库存</span><br>        stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">this</span>.stockMapper.updateById(stock);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用压力测试工具进行测试，库存数量减为0，解决了并发问题</p></li></ol><h4 id="1-4-3-优缺点"><a href="#1-4-3-优缺点" class="headerlink" title="1.4.3 优缺点"></a>1.4.3 优缺点</h4><p>优点：更加灵活</p><ol><li><p>解决同一个商品有多条库存记录的问题</p><p> 可以先根据商品编号查询库存记录，查询到之后再根据现有技术分析。</p></li><li><p>解决无法记录库存变化前后状态的问题</p></li></ol><p>缺点：</p><ol><li><p>性能问题：效率比JVM本地锁稍高一些，但比单SQL语句低</p></li><li><p>死锁问题：对多条数据加锁时，加锁顺序必须一致</p><p> e.g.：用户a与b执行如下顺序操作</p><ol><li><p>用户a对 <code>id=1</code> 商品加锁 </p></li><li><p>用户b对 <code>id=2</code> 商品加锁</p></li><li><p>用户a想对 <code>id=2</code> 商品加锁，但陷入阻塞</p></li><li><p>用户b想对 <code>id=1</code> 商品加锁，报错 Deadlock</p></li></ol></li><li><p>库存操作需要统一</p></li></ol><h3 id="1-5-乐观锁"><a href="#1-5-乐观锁" class="headerlink" title="1.5 乐观锁"></a>1.5 乐观锁</h3><p>借助时间戳、version版本号实现，利用 <code>CAS</code> 机制</p><p>CAS：Compare and Swap 比较并交换</p><p>关于CAS，可以看看这篇博客：<a href="https://www.cnblogs.com/myopensource/p/8177074.html">漫画：什么是CAS机制</a></p><ul><li><p>如果变量 <code>X</code> 等于旧值 <code>A</code>，则更新将 <code>X</code> 更新为 <code>B</code> </p></li><li><p>若不等于，则放弃更新</p></li></ul><h4 id="1-5-1-实现思路"><a href="#1-5-1-实现思路" class="headerlink" title="1.5.1 实现思路"></a>1.5.1 实现思路</h4><ol><li><p>在 <code>db_stock</code> 表中添加 <code>version</code> 字段</p><p> 类型为int，长度11，Not Null</p></li><li><p>查询对应的商品库存以及 <code>version</code> 号</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> db_stock <span class="hljs-keyword">where</span> product_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1001&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>执行更新库存操作时，where条件中需要确认当前 <code>version</code> 是否等于之前查出来的</p><p> . 若等于，则更新库存操作成功</p><p> . 否则，则说明存在并发操作，该条库存数据已被修改。继续查询重试</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> db_stock <span class="hljs-keyword">SET</span> count<span class="hljs-operator">=</span><span class="hljs-number">4999</span>, version<span class="hljs-operator">=</span>version<span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> version<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li></ol><h4 id="1-5-2-代码实现"><a href="#1-5-2-代码实现" class="headerlink" title="1.5.2 代码实现"></a>1.5.2 代码实现</h4><p>在 Stock 实体类中添加 <code>version</code> 属性，类型为Integer</p><p>修改 StcokService 中的deduct()方法</p><h5 id="第一版代码"><a href="#第一版代码" class="headerlink" title="第一版代码"></a>第一版代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询库存信息并锁定</span><br>    List&lt;Stock&gt; stocks = <span class="hljs-built_in">this</span>.stockMapper.selectList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;product_code&quot;</span>, <span class="hljs-string">&quot;1001&quot;</span>));<br>    <span class="hljs-comment">// 取第一个库存</span><br>    <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> stocks.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 扣减库存</span><br>        stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> stock.getVersion();<br>        stock.setVersion(version + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stockMapper.update(stock, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;id&quot;</span>, stock.getId()).eq(<span class="hljs-string">&quot;version&quot;</span>, version));<br>        <span class="hljs-keyword">if</span> (update == <span class="hljs-number">0</span>) &#123;<br>            deduct();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>采用JMeter压力测试工具测试时，报错</p><p>错误分析：</p><ol><li><p>stack over flow：栈溢出</p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/stackoverflow.png"></p><p> 这是由于高并发的情况下，更新失败率很高，就会不断地递归调用deduct方法，导致栈溢出。</p><p> 解决方案：调用线程类中的sleep方法，暂时睡眠，避开并发高峰</p></li><li><p>连接超时错误</p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/timeout.png"></p><p> 这是由于开启了事务注解，为手动事务。</p><p> 当执行到更新操作时，会对数据进行加锁。而当前请求无法更新，就会一直调用deduct方法，并一直持有锁。其他请求进入代码，会进入阻塞状态，直至连接超时。</p><p> 而关闭了事务注解，为自动事务。若更新操作执行失败，会放弃锁。</p></li></ol><h5 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询库存信息并锁定</span><br>    List&lt;Stock&gt; stocks = <span class="hljs-built_in">this</span>.stockMapper.selectList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;product_code&quot;</span>, <span class="hljs-string">&quot;1001&quot;</span>));<br>    <span class="hljs-comment">// 取第一个库存</span><br>    <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> stocks.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 扣减库存</span><br>        stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> stock.getVersion();<br>        stock.setVersion(version + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stockMapper.update(stock, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;id&quot;</span>, stock.getId()).eq(<span class="hljs-string">&quot;version&quot;</span>, version));<br>        <span class="hljs-keyword">if</span> (update == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">20</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            deduct();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过JMeter测试，最终库存减为0</p><h4 id="1-5-3-优缺点"><a href="#1-5-3-优缺点" class="headerlink" title="1.5.3 优缺点"></a>1.5.3 优缺点</h4><p>推荐阅读：<a href="https://www.cnblogs.com/qjjazry/p/6581568.html">Java并发问题–乐观锁与悲观锁以及乐观锁的一种实现方式-CAS</a></p><p>优点：</p><ol><li>乐观锁在竞争不激烈时，较悲观锁更具有优势，因为悲观锁会锁住代码块，并且加锁、释放锁、线程上下文均占用额外资源。</li></ol><p>缺点：</p><ol><li><p>在高并发情况下，乐观锁的性能不如悲观锁，因为重试次数过多。</p></li><li><p>乐观锁存在ABA问题</p><p> . 在查询与更新的中间，<code>X</code> 值被多次更改，但最终又回到了查询时的值</p></li><li><p>读写分离情况下，乐观锁不可靠</p><p> 从数据库与主数据库进行网络传输，具有较大时延，可能主数据库内是新数据，而从数据库内是旧数据，乐观锁下会造成从数据库不断地重试，</p></li></ol><h3 id="1-6-MySQL锁总结"><a href="#1-6-MySQL锁总结" class="headerlink" title="1.6 MySQL锁总结"></a>1.6 MySQL锁总结</h3><p>性能：单SQL语句 &gt; 悲观锁 &gt; JVM锁 &gt; 乐观锁</p><ul><li><p>追求极致性能、业务场景简单、无需记录数据更新前后变化的情况下 -&gt; 单SQL语句</p></li><li><p>并发量低、读多于写、竞争不激烈的情况下 -&gt; 乐观锁</p></li><li><p>并发量高、冲突激烈 -&gt; 悲观锁</p></li><li><p>不推荐JVM锁</p></li></ul><h3 id="1-7-Redis锁"><a href="#1-7-Redis锁" class="headerlink" title="1.7 Redis锁"></a>1.7 Redis锁</h3><h4 id="1-7-1-并发问题引入"><a href="#1-7-1-并发问题引入" class="headerlink" title="1.7.1 并发问题引入"></a>1.7.1 并发问题引入</h4><ol><li><p>在Maven工程pom.xml文件中加入依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在application.properties文件中配置redis</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.redis.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure></li><li><p>更改 StockService类中的deduct方法</p><p> 采用StringRedisTemplate更加方便</p><p> 而RedisTemplate需要手动设置序列化器</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询库存信息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>);<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>        <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 扣减库存</span><br>            <span class="hljs-built_in">this</span>.redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在redis-cli命令窗口中，设置库存：<code>set stock 5000</code></p></li></ol><p>启动SpringBoot与压力测试工具JMeter，最终库存不为0，出现并发问题。</p><h4 id="1-7-2-解决方案"><a href="#1-7-2-解决方案" class="headerlink" title="1.7.2 解决方案"></a>1.7.2 解决方案</h4><ol><li><p>JVM本地锁机制（较简单不做演示）</p></li><li><p>Redis乐观锁：<code>watch</code> <code>multi</code> <code>exec</code></p><ol><li><p>watch：监控一个或多个key的值，如果exec执行之前，如果key的值发生变化，则取消事务执行。</p></li><li><p>multi：开启事务</p></li><li><p>exec：执行事务</p></li></ol></li></ol><h4 id="1-7-3-代码实现"><a href="#1-7-3-代码实现" class="headerlink" title="1.7.3 代码实现"></a>1.7.3 代码实现</h4><p>修改StockService中的deduct方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionCallback</span>&lt;Object&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">execute</span><span class="hljs-params">(RedisOperations operations)</span> <span class="hljs-keyword">throws</span> DataAccessException &#123;<br>            operations.watch(<span class="hljs-string">&quot;stock&quot;</span>);<br>            <span class="hljs-comment">// 查询库存信息</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> operations.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>            <span class="hljs-comment">// 判断库存是否充足</span><br>            <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>                <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// multi</span><br>                    operations.multi();<br>                    <span class="hljs-comment">// 扣减库存</span><br>                    operations.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>                    <span class="hljs-comment">// exec 执行事务</span><br>                    <span class="hljs-type">List</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> operations.exec();<br>                    <span class="hljs-comment">// 如果事务执行结果为空，代表操作失败，重试</span><br>                    <span class="hljs-keyword">if</span> (exec == <span class="hljs-literal">null</span> || exec.size() == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            Thread.sleep(<span class="hljs-number">40</span>);<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                        &#125;<br>                        deduct();<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> exec;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>采用JMeter进行并发测试后，库存减为0，解决了并发问题</p><p>但是吞吐量性能较低，甚至可能由于电脑性能问题，出现连接不够用的情况。</p><h2 id="2-Redis分布式锁"><a href="#2-Redis分布式锁" class="headerlink" title="2. Redis分布式锁"></a>2. Redis分布式锁</h2><h3 id="2-1-实现思路"><a href="#2-1-实现思路" class="headerlink" title="2.1 实现思路"></a>2.1 实现思路</h3><p>借助于redis中的命令 <code>setnx(key, value)</code></p><p>设置 <code>key</code> 为lock</p><ul><li>若 <code>lock</code> 存在，则说明有其他请求已经获取到锁，则当前请求重复重试</li><li>若 <code>lock</code> 不存在，则说明当前锁未被获取，当前请求获取锁成功，继续执行业务操作</li><li>设置 <code>lock</code> 之后，只有一个请求可以获取到锁并执行成功，其他请求只能等待</li></ul><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/1606626611922.png"></p><h3 id="2-2-基本代码实现"><a href="#2-2-基本代码实现" class="headerlink" title="2.2 基本代码实现"></a>2.2 基本代码实现</h3><h4 id="2-2-1-递归版本"><a href="#2-2-1-递归版本" class="headerlink" title="2.2.1 递归版本"></a>2.2.1 递归版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 加锁setnx</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);<br>    <span class="hljs-comment">// 递归调用</span><br>    <span class="hljs-keyword">if</span> (!lock) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        deduct();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 查询库存信息</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>            <span class="hljs-comment">// 判断库存是否充足</span><br>            <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>                <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 扣减库存</span><br>                    redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 解锁</span><br>            <span class="hljs-built_in">this</span>.redisTemplate.delete(<span class="hljs-string">&quot;lock&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-循环版本"><a href="#2-2-2-循环版本" class="headerlink" title="2.2.2 循环版本"></a>2.2.2 循环版本</h4><p>注意：即使不采用递归版本，在重试获取锁的过程中，也可以使用线程睡眠，这样可以减小锁的竞争压力，提升性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 加锁setnx</span><br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>)) &#123;<br>        <span class="hljs-comment">// 循环重试</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 查询库存信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-comment">// 判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 解锁</span><br>        <span class="hljs-built_in">this</span>.redisTemplate.delete(<span class="hljs-string">&quot;lock&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-问题解决"><a href="#2-3-问题解决" class="headerlink" title="2.3 问题解决"></a>2.3 问题解决</h3><h4 id="2-3-1-死锁与原子性"><a href="#2-3-1-死锁与原子性" class="headerlink" title="2.3.1 死锁与原子性"></a>2.3.1 死锁与原子性</h4><p>在某一请求获取到lock锁之后，当前服务器突然宕机，造成该锁无法得到释放，此时其他请求仍然处于不断地递归或循环重试获取锁，造成死循环。</p><p>解决方案：获取到lock之后，为lock设置过期时间，<code>expire</code> 指令</p><p>但是：可能在 获取lock 与 为lock设置过期时间 之间，服务器发生宕机。</p><p>因此，需要确保两个操作的原子性：采用如下指令，将多个操作复合到一个指令中</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set</span> lock <span class="hljs-number">123</span> ex <span class="hljs-number">20</span> nx<br></code></pre></td></tr></table></figure><p>修改加锁部分的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;<br>    <span class="hljs-comment">// 循环重试</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">50</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-防误删"><a href="#2-3-2-防误删" class="headerlink" title="2.3.2 防误删"></a>2.3.2 防误删</h4><p>假设处理请求的时长大于锁的有效时间，当某一请求还未执行完当前操作时，Redis锁便会自动释放掉（删除lock），等到该请求执行完当前操作后，还会手动地将Redis锁释放掉。此时，可能别的请求已经获取到了锁，那么该锁很有可能被该请求误删掉。</p><p><strong>解决方案：</strong></p><p>为了防止出现这一情况，需要为当前锁设置唯一标识UUID，作为锁的值。</p><p>在删除锁之前，先判断当前锁是否属于自己，然后再进行删除。</p><p>修改 StockService 的 deduct方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>    <span class="hljs-comment">// 加锁setnx</span><br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, uuid, <span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;<br>        <span class="hljs-comment">// 循环重试</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 查询库存信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-comment">// 判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 先判断，再解锁</span><br>        <span class="hljs-keyword">if</span> (StringUtils.equals(<span class="hljs-built_in">this</span>.redisTemplate.opsForValue().get(<span class="hljs-string">&quot;lock&quot;</span>), uuid)) &#123;<br>            <span class="hljs-built_in">this</span>.redisTemplate.delete(<span class="hljs-string">&quot;lock&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断与删除操作需要保证原子性，否则还会出现并发问题</p><ul><li>刚判断完该锁是自己的，还没进行删除，锁就到期自动释放且被其他请求获取，此时会造成误删操作</li></ul><p>借助 <code>lua</code> 脚本实现原子性操作：<a href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程 | 菜鸟教程</a></p><p>redis-cli支持lua脚本，可以一次性给redis发送多个指令。</p><ul><li>redis为单线程，执行指令遵守 <code>one-by-one</code> 规则</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">EVAL script numkeys <span class="hljs-comment">[key <span class="hljs-comment">[key ...]</span>]</span> <span class="hljs-comment">[arg <span class="hljs-comment">[arg ...]</span>]</span><br></code></pre></td></tr></table></figure><p>删除LUA脚本：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>更改代码中finally部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先判断，再解锁</span><br><span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] &quot;</span> +<br>        <span class="hljs-string">&quot;then return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +<br>        <span class="hljs-string">&quot;else return 0 &quot;</span> +<br>        <span class="hljs-string">&quot;end&quot;</span>;<br><span class="hljs-built_in">this</span>.redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(<span class="hljs-string">&quot;lock&quot;</span>), uuid);<br></code></pre></td></tr></table></figure><h4 id="2-3-3-可重入性"><a href="#2-3-3-可重入性" class="headerlink" title="2.3.3 可重入性"></a>2.3.3 可重入性</h4><p>之前的加锁指令采用的是Redis中的 <code>setnx</code> 指令，即锁的名字固定为lock（键值固定），一旦加锁成功（键设置成功），该线程便无法继续加锁。如下即为具体情景代码：</p><p>某线程执行a方法，获取到锁之后，其又需要继续执行b方法，需要继续获取锁。但此时锁已经被自己占有，相当于自己和自己产生了死锁，这是不可重入锁带来的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>    b();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解决方案：可重入锁</strong></p><p>可重入锁可：当某一线程获得锁之后，需要再次执行加锁方法时（锁对象为同一个），将加锁次数加1即可。执行完毕之后，释放锁时对加锁次数减1。当加锁次数等于0时，说明该锁已经被完全释放。</p><p>当可重入锁需要在分布式环境实现时，需要统计加锁次数。</p><p><strong>实现方案：Redis Hash + lua脚本</strong></p><p>加锁 -&gt; 判断锁是否存在：<code>exists</code></p><ul><li><p>若不存在，则直接创建锁并获取：<code>hset key field value</code></p></li><li><p>若存在，则判断当前锁是否属于自己：<code>hexists</code></p><ul><li><p>若属于，则重入：<code>hincrby key field increment</code></p></li><li><p>若不属于，递归或循环自旋重试</p></li></ul></li></ul><p><strong>加锁脚本</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span> <br><span class="hljs-keyword">then</span><br>    redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>)<br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>解锁 -&gt; 判断锁是否属于自己：<code>hexists</code></p><ul><li><p>若不属于，说明正在恶意释放锁，返回 <code>nil</code></p></li><li><p>若属于，对加锁次数减1，并判断当前加锁次数是否为0</p><ul><li><p>若为0，则返回1，代表完全解锁成功</p></li><li><p>若不为0，则返回0</p></li></ul></li></ul><p><strong>解锁脚本</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span><br><span class="hljs-keyword">then</span> <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">elseif</span> redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>], <span class="hljs-number">-1</span>) == <span class="hljs-number">0</span><br><span class="hljs-keyword">then</span> <br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><strong>代码实现</strong></p><ol><li><p>创建分布式锁的工厂类方法。通过一个工厂类方法，可以获得不同的分布式锁（基于Redis、基于Zookeeper、基于MySQL）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributedLockClient</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br>    <span class="hljs-keyword">private</span> String uuid;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistributedLockClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.uuid = UUID.randomUUID().toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> DistributedRedisLock <span class="hljs-title function_">getRedisLock</span><span class="hljs-params">(String lockName)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistributedRedisLock</span>(redisTemplate, lockName, uuid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建分布式Redis锁的实现类，其实现了Lock接口。通过之前编写好的加锁、解锁脚本，实现了可重入锁。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributedRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br>    <span class="hljs-keyword">public</span> String lockName;<br><br>    <span class="hljs-keyword">private</span> String uuid;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">expire</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistributedRedisLock</span><span class="hljs-params">(StringRedisTemplate redisTemplate, String lockName, String uuid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>        <span class="hljs-built_in">this</span>.lockName = lockName;<br>        <span class="hljs-built_in">this</span>.uuid = uuid;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.tryLock();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.tryLock(-<span class="hljs-number">1L</span>, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-built_in">this</span>.expire = time != -<span class="hljs-number">1</span> ? unit.toSeconds(time) : expire;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;exists&#x27;, KEYS[1]) == 0 or redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 \n&quot;</span> +<br>                        <span class="hljs-string">&quot;then\n&quot;</span> +<br>                        <span class="hljs-string">&quot;    redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1)\n&quot;</span> +<br>                        <span class="hljs-string">&quot;    redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2])\n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return 1\n&quot;</span> +<br>                        <span class="hljs-string">&quot;else\n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return 0\n&quot;</span> +<br>                        <span class="hljs-string">&quot;end&quot;</span>;<br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), getId(), String.valueOf(expire))) &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0\n&quot;</span> +<br>                        <span class="hljs-string">&quot;then \n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return nil\n&quot;</span> +<br>                        <span class="hljs-string">&quot;elseif redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1) == 0\n&quot;</span> +<br>                        <span class="hljs-string">&quot;then \n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return redis.call(&#x27;del&#x27;, KEYS[1])\n&quot;</span> +<br>                        <span class="hljs-string">&quot;else \n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return 0\n&quot;</span> +<br>                        <span class="hljs-string">&quot;end&quot;</span>;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script, Long.class), Arrays.asList(lockName), getId());<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(<span class="hljs-string">&quot;this lock does not belong to you&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> uuid + <span class="hljs-string">&quot;:&quot;</span> + Thread.currentThread().getId();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改StockService中的deduct方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">DistributedRedisLock</span> <span class="hljs-variable">redisLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.distributedLockClient.getRedisLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>    redisLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 查询库存信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-comment">// 判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.test();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        redisLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>需要注意的一点是：如何去标识每一个服务中的每一个线程的锁的uuid？</p><p>这里的解决方案是：通过服务生成的uuid与每个线程的线程id拼接得到唯一标识uuid</p><ol><li><p>每一个服务是通过DistributedLockClient这一工厂类获得锁，由于该类交给Spring容器管理，是单例对象。即每一个服务只有一个唯一的DistributedLockClient对象。</p><p> 因此可以在该类构造方法上生成一个uuid，作为当前服务的唯一标识</p></li><li><p>每一个线程也会有一个唯一的id</p></li><li><p>将两者拼接起来（getId方法），即可唯一标识每一个服务的每一个线程。若需要进行重入操作，同一线程重复获取锁，可通过此唯一标识进行判断。</p></li></ol><p>反之，如果每次通过DistributedLockClient获取Redis分布式锁，均重新创建一个新的uuid，那么便永远无法实现可重入锁。</p><ul><li>因为在同一线程进行可重入操作获取锁时，会出现内层锁与外层锁uuid不匹配的错误情况，与理论事实相矛盾。</li></ul><h4 id="2-3-4-自动续期"><a href="#2-3-4-自动续期" class="headerlink" title="2.3.4 自动续期"></a>2.3.4 自动续期</h4><p>假设处理请求的时长大于锁的有效时间，会出现请求还未处理完，锁就被释放了，此时可能引起并发问题。</p><p><strong>解决方案：</strong></p><ul><li><p>采用Timer定时任务，每隔一段时间为锁续期</p></li><li><p>配合lua脚本执行最后的续期操作</p><p>  先判断锁是否存在。若存在则重置过期时间</p>  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span>) <br><span class="hljs-keyword">then</span> <br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renewExpire</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if(redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) \n&quot;</span> +<br>                    <span class="hljs-string">&quot;then \n&quot;</span> +<br>                    <span class="hljs-string">&quot;    redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2])\n&quot;</span> +<br>                    <span class="hljs-string">&quot;    return 1\n&quot;</span> +<br>                    <span class="hljs-string">&quot;else \n&quot;</span> +<br>                    <span class="hljs-string">&quot;    return 0\n&quot;</span> +<br>                    <span class="hljs-string">&quot;end&quot;</span>;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>().schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), uuid, String.valueOf(expire))) &#123;<br>                renewExpire();<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-built_in">this</span>.expire * <span class="hljs-number">1000</span> / <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中需要注意的点是：</p><ul><li><p>之前是通过 <code>getId()</code> 方法，将当前服务的uuid与当前线程的id拼接到一起，组成唯一标识。</p><p>  而现在的问题为：Timer定时任务是子线程，它的本意是监测主线程的锁的过期时间并为其续期，但是在其内部调用getId方法，得到的锁唯一标识是拼接的Timer定时任务子线程的id。</p></li><li><p>因此，需要对代码进行进一步修改与优化，删去getId方法，修改DistributedRedisLock的构造方法，在创建该类时便生成唯一的uuid。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">DistributedRedisLock</span><span class="hljs-params">(StringRedisTemplate redisTemplate, String lockName, String uuid)</span> &#123;<br>    <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>    <span class="hljs-built_in">this</span>.lockName = lockName;<br>    <span class="hljs-built_in">this</span>.uuid = uuid + <span class="hljs-string">&quot;:&quot;</span> + Thread.currentThread().getId();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-4-RedLock红锁算法"><a href="#2-4-RedLock红锁算法" class="headerlink" title="2.4 RedLock红锁算法"></a>2.4 RedLock红锁算法</h3><p>我结合老师的讲解，单独写了一篇<a href="">图文详解RedLock（结合官方文档）</a></p><p>其中一些内容参照了官方文档以及其他大佬的博客</p><p>这一部分均为理论内容，没有实际代码</p><h3 id="2-5-Redisson"><a href="#2-5-Redisson" class="headerlink" title="2.5 Redisson"></a>2.5 Redisson</h3><h4 id="2-5-1-环境搭建"><a href="#2-5-1-环境搭建" class="headerlink" title="2.5.1 环境搭建"></a>2.5.1 环境搭建</h4><p>参考 <a href="https://github.com/redisson/redisson/wiki">Redisson文档</a></p><ol><li><p>引入依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.17.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>由于Redisson不能使用yml进行配置，因此需要编写额外的配置类</p><p> 新建 <code>config</code> 包，创建 <code>RedissonConfig</code> 类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://127.0.0.1:6379&quot;</span>).setPassword(<span class="hljs-string">&quot;123456&quot;</span>).setDatabase(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改 <code>StockService</code> 中的 <code>deduct</code> 方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>  <br><span class="hljs-keyword">private</span> RedissonClient redissonClient;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);  <br>    lock.lock();  <br>    <span class="hljs-comment">// 查询库存信息  </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();  <br>    <span class="hljs-comment">// 判断库存是否充足  </span><br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);  <br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;  <br>                <span class="hljs-comment">// 扣减库存  </span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p> 也可以设置lock的过期时间，到时间时自动释放锁</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">lock.lock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure></li></ol><p>常用的Redisson配置</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/iShot2022-10-12%2017.07.13.png"></p><h4 id="2-5-2-可重入锁"><a href="#2-5-2-可重入锁" class="headerlink" title="2.5.2 可重入锁"></a>2.5.2 可重入锁</h4><h5 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h5><p>RLock接口的lock方法是通过继承JUC包下的Lock接口获得，最终RedissonLock间接实现了RLock接口以及其中的中法。</p><p>继承关系如图所示：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/rlock.png"></p><p>RedissonLock中具体lock方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        lock(-<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);  <br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>根据顺序，一步步进入方法查看：</p><p>lock -&gt; tryAcquire -&gt; tryAcquireAsync -&gt; tryLockInnerAsync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T&gt; RFuture&lt;T&gt; <span class="hljs-title function_">tryLockInnerAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;  <br>    <span class="hljs-keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,  <br>            <span class="hljs-string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +  <br>                    <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +  <br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +  <br>                    <span class="hljs-string">&quot;return nil; &quot;</span> +  <br>                    <span class="hljs-string">&quot;end; &quot;</span> +  <br>                    <span class="hljs-string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +  <br>                    <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +  <br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +  <br>                    <span class="hljs-string">&quot;return nil; &quot;</span> +  <br>                    <span class="hljs-string">&quot;end; &quot;</span> +  <br>                    <span class="hljs-string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,  <br>            Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId));  <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到Redisson中的加锁方法也是采用lua脚本</p><p>Redisson锁的自动定时续期是通过：<code>scheduleExpirationRenewal</code> 方法实现</p><p>其方法内部通过 <code>renewExpiration</code> 重置过期时间，采用TimerTask完成定时任务</p><p>解锁方法unlock也是采用lua脚本</p><p><strong>Redisson自动续期、可重入与防死锁</strong></p><p>实现方案与之前手动实现的Redis分布式锁类似</p><ol><li><p>如果当前代码运行时间过长，超出了锁的过期时间，但是程序仍在执行过程中，所以需要为锁续期</p><p>-&gt; Redisson内部提供了一个监控锁的看门狗（定时任务），它的作用是在Redisson实例被关闭前，不断地延长锁的有效期。默认情况下，看门狗每隔30秒检查一次。</p></li><li><p>如果负责储存分布式锁的Redisson节点宕机后，而这个锁恰好处于锁住状态，这时候会出现死锁。</p><p>-&gt; Redisson通过为锁设置超时时间（有效期），若有效期内没有定时任务为其续期，则其超过该时间就会自动解开。</p></li></ol><h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><p>测试自动续期代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>    lock.lock();<br>    <span class="hljs-comment">// 查询库存信息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试可重入代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>    lock.lock();<br>    <span class="hljs-comment">// 查询库存信息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>    <span class="hljs-built_in">this</span>.test();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>    lock.lock();<br>    System.out.println(<span class="hljs-string">&quot;测试可重入锁...&quot;</span>);<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-5-3-公平锁"><a href="#2-5-3-公平锁" class="headerlink" title="2.5.3 公平锁"></a>2.5.3 公平锁</h4><p>公平的体现：公平锁保证当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程。</p><p>所有的请求线程会在一个队列中排队。如果某线程宕机后，Redisson等待5秒后继续下一个线程。</p><p>举个🌰：若前面有5个线程宕机，那么延迟将会是25秒。</p><p>顺便提一点：个人认为此处Redisson官方的<a href="https://github.com/redisson/redisson/wiki/8.-distributed-locks-and-synchronizers">中文文档</a>描述略有不妥，不是<del>前面5个线程处于等待状态</del>，而是处于宕机状态</p><blockquote><p>  所有请求线程会在一个队列中排队，当某个线程出现宕机时，Redisson会等待5秒后继续下一个线程，也就是说如果前面有5个线程都处于等待状态，那么后面的线程会等待至少25秒。</p></blockquote><p>对照英文版本：</p><blockquote><p>  All waiting threads are queued and if some thread has died then Redisson waits its return for 5 seconds. For example, if 5 threads are died for some reason then delay will be 25 seconds.</p></blockquote><h5 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h5><ol><li><p>在StockController添加新的测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/fair/lock/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testFairLock</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testFairLock(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test fair lock&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService添加新的测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFairLock</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">fairLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getFairLock(<span class="hljs-string">&quot;fairLock&quot;</span>);<br>    fairLock.lock();<br>    System.out.println(<span class="hljs-string">&quot;测试公平锁==================&quot;</span> + id);<br>    <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        fairLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>启动SpringBoot，依次在浏览器请求 <code>test/fair/lock/&#123;id&#125;</code> 5次</p><p>可以看到最终的输出顺序和请求顺序一致，说明实现了公平锁</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221014004141382.png" alt="image-20221014004141382"></p><p>如果开启了两个SpringBoot并采用nginx进行负载均衡，会出现一个请求被发送多次的情况。</p><p>这是因为nginx有纠错机制，当发送一个请求长时间未得到响应时，nginx会再次发送。</p><p>解决方案：配置nginx.conf文件，将超时时间延长。重新配置之后记得重新启动nginx。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br>    <span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">12000</span><br>    proxy_send_timeout <span class="hljs-number">12000</span><br>    proxy_read_timeout <span class="hljs-number">12000</span><br>    location / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://distributedLock;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-5-4-联锁"><a href="#2-5-4-联锁" class="headerlink" title="2.5.4 联锁"></a>2.5.4 联锁</h4><p>Redisson可以将多个RLock对象关联为一个联锁。即要么同时上锁，要么同时解锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RLock</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> redissonInstance1.getLock(<span class="hljs-string">&quot;lock1&quot;</span>);<br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> redissonInstance2.getLock(<span class="hljs-string">&quot;lock2&quot;</span>);<br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock3</span> <span class="hljs-operator">=</span> redissonInstance3.getLock(<span class="hljs-string">&quot;lock3&quot;</span>);<br><br><span class="hljs-type">RedissonMultiLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedissonMultiLock</span>(lock1, lock2, lock3);<br><span class="hljs-comment">// 同时加锁：lock1 lock2 lock3</span><br><span class="hljs-comment">// 所有的锁都上锁成功才算成功。</span><br>lock.lock();<br>...<br>lock.unlock();<br></code></pre></td></tr></table></figure><p>但是缺点很明显：任何一个Redis宕机之后，其他所有的Redis都不可用，一般不用。</p><h4 id="2-5-5-红锁"><a href="#2-5-5-红锁" class="headerlink" title="2.5.5 红锁"></a>2.5.5 红锁</h4><p>红锁与联锁的不同之处在于：红锁只要大部分（过半数）节点上加锁成功就算成功。红锁也不重要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RLock</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> redissonInstance1.getLock(<span class="hljs-string">&quot;lock1&quot;</span>);<br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> redissonInstance2.getLock(<span class="hljs-string">&quot;lock2&quot;</span>);<br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock3</span> <span class="hljs-operator">=</span> redissonInstance3.getLock(<span class="hljs-string">&quot;lock3&quot;</span>);<br><br><span class="hljs-type">RedissonRedLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedissonRedLock</span>(lock1, lock2, lock3);<br><span class="hljs-comment">// 同时加锁：lock1 lock2 lock3</span><br><span class="hljs-comment">// 红锁在大部分节点上加锁成功就算成功。</span><br>lock.lock();<br>...<br>lock.unlock();<br></code></pre></td></tr></table></figure><h4 id="2-5-6-读写锁"><a href="#2-5-6-读写锁" class="headerlink" title="2.5.6 读写锁"></a>2.5.6 读写锁</h4><p>读写锁特性为：读操作可以并发，但是写操作之间不可以并发，读操作与写操作不可以并发</p><p>举例论证读写锁存在的必要：</p><ul><li>假设读操作之间可以并发，写操作之间不可以并发。这种加锁方式保证了写操作的安全性</li><li>但这种方式确保不了读与写操作的安全性，因为没有限制读和写的并发，因此需要引入读写锁</li></ul><h5 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h5><ol><li><p>在StockController中新增以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/read/lock&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testReadLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testReadLock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test read lock&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@GetMapping(&quot;test/write/lock&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testWriteLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testWriteLock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test write lock&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService中新增以下代码：选择超时自动解锁的方式加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testReadLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RReadWriteLock</span> <span class="hljs-variable">rwLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getReadWriteLock(<span class="hljs-string">&quot;rwLock&quot;</span>);<br>    rwLock.readLock().lock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    System.out.println(<span class="hljs-string">&quot;执行写操作...&quot;</span>);<br>    <span class="hljs-comment">//rwLock.readLock().unlock();</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWriteLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RReadWriteLock</span> <span class="hljs-variable">rwLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getReadWriteLock(<span class="hljs-string">&quot;rwLock&quot;</span>);<br>    rwLock.writeLock().lock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    System.out.println(<span class="hljs-string">&quot;执行写操作...&quot;</span>);<br>    <span class="hljs-comment">//rwLock.writeLock().unlock();</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>测试对应的方法，然后查看redis中读写锁是如何存储的。</p><ol><li><p>对于读，可以存在多个读操作，mode为read</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015231801864.png" alt="image-20221015231801864"></p></li><li><p>对于写，同一时间只能有一个写操作，其余均阻塞，mode为write</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015231952586.png" alt="image-20221015231952586"></p></li><li><p>在读的过程中，写操作会被阻塞；在写的过程中，读操作也会被阻塞</p></li></ol><h4 id="2-5-7-信号量"><a href="#2-5-7-信号量" class="headerlink" title="2.5.7 信号量"></a>2.5.7 信号量</h4><p>与JUC中信号量的共同之处：都可以对请求进行限流，均适用于需求量大资源有限的情景</p><h5 id="JUC信号量"><a href="#JUC信号量" class="headerlink" title="JUC信号量"></a>JUC信号量</h5><p>回顾JUC中的信号量：模拟6个线程争抢有限的3个资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            semaphore.acquire();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;抢到了停车位&quot;</span>);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">10</span>));<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;停了一会儿开走了&quot;</span>);<br>            semaphore.release();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;, i + <span class="hljs-string">&quot;号车&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015233103573.png" alt="image-20221015233103573"></p><p>但是JUC信号量只能对单机情况下进行限流，无法做到对分布式环境进行限流</p><h5 id="分布式信号量"><a href="#分布式信号量" class="headerlink" title="分布式信号量"></a>分布式信号量</h5><ol><li><p>在StockController中添加如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/semaphore&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">testSemaphore</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.stockService.testSemaphore();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test semaphore&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService中添加如下代码：通过redis记录争抢资源的顺序日志，更直观地证明分布式下的正确性</p><p>如果要更改semaphore可允许线程数的值，记得将redis中旧的值删去（或者起一个新的名字）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSemaphore</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RSemaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getSemaphore(<span class="hljs-string">&quot;semaphore&quot;</span>);<br>    semaphore.trySetPermits(<span class="hljs-number">3</span>); <span class="hljs-comment">// 设置限流的线程数</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        semaphore.acquire(); <span class="hljs-comment">// 获取资源成功之后才可继续处理业务操作，否则阻塞</span><br>        <span class="hljs-built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-string">&quot;10010获取资源，开始处理...&quot;</span> + Thread.currentThread().getName());<br>        TimeUnit.SECONDS.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">10</span>));<br>        <span class="hljs-built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-string">&quot;10010处理完成，释放资源...&quot;</span> + Thread.currentThread().getName());<br>        semaphore.release(); <span class="hljs-comment">// 手动释放资源</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>启动两个服务，redis中的输出日志如下：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221016001007227.png" alt="image-20221016001007227"></p><h4 id="2-5-8-倒计数器（闭锁）"><a href="#2-5-8-倒计数器（闭锁）" class="headerlink" title="2.5.8 倒计数器（闭锁）"></a>2.5.8 倒计数器（闭锁）</h4><p>一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行</p><h5 id="JUC倒计数器"><a href="#JUC倒计数器" class="headerlink" title="JUC倒计数器"></a>JUC倒计数器</h5><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;：开始执行...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">5</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;：结束执行...&quot;</span>);<br>            countDownLatch.countDown();<br>        &#125;, i + <span class="hljs-string">&quot;号线程&quot;</span>).start();<br>    &#125;<br>    countDownLatch.await();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;：其他线程均已结束，执行最后任务...&quot;</span>);<br></code></pre></td></tr></table></figure><p>输出如下：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221016002330475.png" alt="image-20221016002330475"></p><h5 id="分布式倒计数器"><a href="#分布式倒计数器" class="headerlink" title="分布式倒计数器"></a>分布式倒计数器</h5><ol><li><p>在StockController中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/await&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testLAwait</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testAwait();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;wait for other threads...&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@GetMapping(&quot;test/countdown&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testCountDown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testCountDown();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;execute...&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAwait</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RCountDownLatch</span> <span class="hljs-variable">cdl</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getCountDownLatch(<span class="hljs-string">&quot;cdl&quot;</span>);<br>    cdl.trySetCount(<span class="hljs-number">6</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        cdl.await(); <span class="hljs-comment">// 阻塞，直到其余所有线程执行完毕</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCountDown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RCountDownLatch</span> <span class="hljs-variable">cdl</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getCountDownLatch(<span class="hljs-string">&quot;cdl&quot;</span>);<br>    cdl.countDown();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-Zookeeper分布式锁"><a href="#3-Zookeeper分布式锁" class="headerlink" title="3. Zookeeper分布式锁"></a>3. Zookeeper分布式锁</h2><h3 id="3-1-Zookeeper基本指令"><a href="#3-1-Zookeeper基本指令" class="headerlink" title="3.1 Zookeeper基本指令"></a>3.1 Zookeeper基本指令</h3><ol><li><p>查看某个目录下的子节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> /<br><span class="hljs-built_in">ls</span> /node<br></code></pre></td></tr></table></figure></li><li><p>创建节点 create命令</p><p>在根目录创建 <code>node</code> 节点，其内容为 “abc”</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">create /<span class="hljs-keyword">node</span> <span class="hljs-title">&quot;abc</span><span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>更新节点内容 set命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> /node <span class="hljs-string">&quot;aaa&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>获取节点数据 get命令</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">get /<span class="hljs-keyword">node</span><br><span class="hljs-title">get</span> -s /<span class="hljs-keyword">node</span> <span class="hljs-title">获取详细内容</span><br></code></pre></td></tr></table></figure></li><li><p>删除节点 delete命令</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">delete /<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-2-ZNode节点类型"><a href="#3-2-ZNode节点类型" class="headerlink" title="3.2 ZNode节点类型"></a>3.2 ZNode节点类型</h3><p>永久节点：一旦节点被创建就一直存在，及时Zookeeper宕机也不会被删除，只能手动将其删除</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">create /<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><p>临时节点：临时节点的生命周期与客户端会话相绑定，会话消失则节点也会随之消失。并且临时节点只能做叶子节点，不能创建子节点</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">create -e /<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><p>永久序列化节点：具有永久节点的特性，而且在创建该类节点时，Zookeeper会在节点名称后加入顺序编号</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">create -s /<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><p>临时序列化节点：具有临时节点的特性，而且在创建该类节点时，Zookeeper会在节点名称后加入顺序编号</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">create -e -s /<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><h3 id="3-3-事件监听"><a href="#3-3-事件监听" class="headerlink" title="3.3 事件监听"></a>3.3 事件监听</h3><p>Watcher事件监听器：监听是一次性的，一个监听指令只能监听到一次变化</p><p>同时开启两个zk客户端，一个客户端用于监听，另一个客户端用于操作节点</p><ol><li><p>节点创建：NodeCreated</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span> -w /xx<br></code></pre></td></tr></table></figure></li><li><p>节点删除：NodeDeleted</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span> -w /xx<br></code></pre></td></tr></table></figure></li><li><p>节点数据变化：NodeDataChanged</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">get</span> -w /xx<br></code></pre></td></tr></table></figure></li><li><p>子节点变化：NodeChildrenChanged</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 监听xx下的子节点变化</span><br><span class="hljs-built_in">ls</span> -w /xx <br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-Java客户端"><a href="#3-4-Java客户端" class="headerlink" title="3.4 Java客户端"></a>3.4 Java客户端</h3><h4 id="3-4-1-案例搭建"><a href="#3-4-1-案例搭建" class="headerlink" title="3.4.1 案例搭建"></a>3.4.1 案例搭建</h4><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>创建ZkTest类，在main方法编写如下代码</p><ul><li>Zookeeper构造方法中需要填的参数<ul><li>ip地址与端口号port</li><li>超时时间</li><li>Watcher事件监听器匿名类</li></ul></li><li>用CountDownLatch，使Zookeeper在获取到链接之后才进行之后的操作</li><li>Watcher事件监听中：监听获取链接与关闭链接两个事件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zooKeeper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">try</span> &#123;<br>    zooKeeper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>, <span class="hljs-number">30000</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> &#123;<br>            Event.<span class="hljs-type">KeeperState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> watchedEvent.getState();<br>            <span class="hljs-keyword">if</span> (Event.KeeperState.SyncConnected.equals(state)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;获取链接：&quot;</span> + watchedEvent);<br>                countDownLatch.countDown();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Event.KeeperState.Closed.equals(state)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;关闭链接：&quot;</span> + watchedEvent);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    countDownLatch.await();<br>    System.out.println(<span class="hljs-string">&quot;执行操作...&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (zooKeeper != <span class="hljs-literal">null</span>) &#123;<br>        zooKeeper.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">获取链接：WatchedEvent <span class="hljs-keyword">state</span>:SyncConnected type:None path:null<br>执行操作...<br>关闭链接：WatchedEvent <span class="hljs-keyword">state</span>:Closed type:None path:null<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-4-2-操作节点"><a href="#3-4-2-操作节点" class="headerlink" title="3.4.2 操作节点"></a>3.4.2 操作节点</h4><ol><li><p>创建节点：第一个参数为节点名路径，第二参数为节点内容，第三个参数为节点权限，第四个参数为节点类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 永久节点</span><br>zooKeeper.create(<span class="hljs-string">&quot;ltyzzz/test1&quot;</span>, <span class="hljs-string">&quot;hello zookeeper&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br><span class="hljs-comment">// 临时节点</span><br>zooKeeper.create(<span class="hljs-string">&quot;ltyzzz/test2&quot;</span>, <span class="hljs-string">&quot;hello zookeeper&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);<br><span class="hljs-comment">// 永久序列化节点</span><br>zooKeeper.create(<span class="hljs-string">&quot;ltyzzz/test3&quot;</span>, <span class="hljs-string">&quot;hello zookeeper&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);<br><span class="hljs-comment">// 临时序列化节点 </span><br>zooKeeper.create(<span class="hljs-string">&quot;ltyzzz/test3&quot;</span>, <span class="hljs-string">&quot;hello zookeeper&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);<br></code></pre></td></tr></table></figure></li><li><p>查询节点</p><ol><li><p>判断节点是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Stat</span> <span class="hljs-variable">exists</span> <span class="hljs-operator">=</span> zooKeeper.exists(<span class="hljs-string">&quot;/ltyzzz&quot;</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (exists != <span class="hljs-literal">null</span>) &#123;<br>    System.out.println(<span class="hljs-string">&quot;当前节点存在&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;当前节点不存在&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>获取当前节点中的数据内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] data = zooKeeper.getData(<span class="hljs-string">&quot;/ltyzzz&quot;</span>, <span class="hljs-literal">false</span>, exists);<br>System.out.println(<span class="hljs-string">&quot;当前节点内容：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data));<br></code></pre></td></tr></table></figure></li><li><p>获取当前节点的子节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; children = zooKeeper.getChildren(<span class="hljs-string">&quot;/ltyzzz&quot;</span>, <span class="hljs-literal">false</span>);<br>System.out.println(<span class="hljs-string">&quot;当前节点的子节点：&quot;</span> + children);<br></code></pre></td></tr></table></figure></li></ol></li><li><p>更新节点</p><ul><li>其中第三个参数为版本号。该版本号必须和当前节点版本号一致，否则更新失败（乐观锁）</li><li>可以将其指定为-1，表示不关心版本号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">zooKeeper.setData(<span class="hljs-string">&quot;/ltyzzz&quot;</span>, <span class="hljs-string">&quot;zzz...&quot;</span>.getBytes(), exists.getVersion());<br>zooKeeper.setData(<span class="hljs-string">&quot;/ltyzzz&quot;</span>, <span class="hljs-string">&quot;zzz...&quot;</span>.getBytes(), -<span class="hljs-number">1</span>); <span class="hljs-comment">// 不关心版本号</span><br></code></pre></td></tr></table></figure></li><li><p>删除操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zooKeeper.delete(<span class="hljs-string">&quot;/ltyzzz/test1&quot;</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// 不关心版本号</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="3-4-3-节点监听事件"><a href="#3-4-3-节点监听事件" class="headerlink" title="3.4.3 节点监听事件"></a>3.4.3 节点监听事件</h4><p>每一个操作节点的方法中均有一个watch参数，为boolean类型。</p><p>watch为true时，代表启动节点监听事件</p><h3 id="3-5-实现Zookeeper分布式锁"><a href="#3-5-实现Zookeeper分布式锁" class="headerlink" title="3.5 实现Zookeeper分布式锁"></a>3.5 实现Zookeeper分布式锁</h3><p>独占排他：ZNode节点不可重复</p><h4 id="3-5-1-自旋锁版本"><a href="#3-5-1-自旋锁版本" class="headerlink" title="3.5.1 自旋锁版本"></a>3.5.1 自旋锁版本</h4><ol><li><p>创建ZkClient，用于初始化时获取Zk链接与结束时释放Zk链接</p><ul><li>添加@Component注解，交给Spring容器管理，SpringBoot启动时会执行初始化操作</li><li>@PostConstruct：执行完ZkClient构造方法之后，获取Zookeeper链接</li><li>@PreDestroy：在ZkClient销毁之前，释放Zookeeper链接</li><li>getLock：用于创建锁对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkClient</span> &#123;<br><br>    <span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zooKeeper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 获取Zk链接</span><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            zooKeeper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>, <span class="hljs-number">30000</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> &#123;<br>                    Event.<span class="hljs-type">KeeperState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> watchedEvent.getState();<br>                    <span class="hljs-keyword">if</span> (Event.KeeperState.SyncConnected.equals(state)) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;获取链接：&quot;</span> + watchedEvent);<br>                        countDownLatch.countDown();<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Event.KeeperState.Closed.equals(state)) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;关闭链接：&quot;</span> + watchedEvent);<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 释放Zk链接</span><br>        <span class="hljs-keyword">if</span> (zooKeeper != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                zooKeeper.close();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ZkDistributedLock <span class="hljs-title function_">getLock</span><span class="hljs-params">(String lockName)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZkDistributedLock</span>(zooKeeper, lockName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建ZkDistributedLock类，用于实现锁</p><ul><li>所有的锁都将创建在 <code>/locks</code> 目录下，所以在构造方法中，需要先判断有没有该目录，没有的话则需要提前创建</li><li>注意：<code>/locks</code> 为永久节点，而创建出来的锁为临时节点，这是为了防止服务器宕机造成的死锁问题，而设置为临时节点的话，服务器宕机之后，临时节点也会随之被删除。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkDistributedLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String lockName;<br>    <span class="hljs-keyword">private</span> ZooKeeper zooKeeper;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROOT_PATH</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/locks&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ZkDistributedLock</span><span class="hljs-params">(ZooKeeper zooKeeper, String lockName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.zooKeeper = zooKeeper;<br>        <span class="hljs-built_in">this</span>.lockName = lockName;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (zooKeeper.exists(ROOT_PATH, <span class="hljs-literal">false</span>) == <span class="hljs-literal">null</span>) &#123;<br>                zooKeeper.create(ROOT_PATH, <span class="hljs-literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建ZNode节点</span><br>        tryLock();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            zooKeeper.create(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + lockName, <span class="hljs-literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">80</span>);<br>                tryLock();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>                ex.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 删除ZNode节点</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.zooKeeper.delete(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + lockName, -<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService中注入ZkClient对象，并修改deduct方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ZkClient zkClient;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ZkDistributedLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> zkClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-5-2-阻塞公平锁版本"><a href="#3-5-2-阻塞公平锁版本" class="headerlink" title="3.5.2 阻塞公平锁版本"></a>3.5.2 阻塞公平锁版本</h4><p>利用临时序列化节点与监听机制实现</p><ol><li><p>临时序列化节点在创建节点时，节点的名称后会追加序列号。</p><p>给每一个获取锁的请求都创建一个临时序列化节点，越先尝试获取锁的节点，其序列号越小，优先级越高，满足公平锁的定义</p><ol><li>获取当前节点的前驱节点<ul><li>若前驱节点为空，则获取锁成功，否则监听前驱节点</li></ul></li><li>获取锁成功后执行业务操作，最后释放当前节点的锁</li></ol></li><li><p>后创建的节点监听它之前的一个节点，如果监听到它的前驱节点被删除，则相当于获取到锁；否则阻塞</p><p>（类似于AQS中同步队列的定义）</p></li></ol><p>改造之前的代码：更改tryLock与unlock代码</p><p>注意：</p><ol><li>Zookeeper调用create方法后，会返回其全路径，这里将其作为了成员变量，方便解锁时删除</li><li>路径中加上了“-”，方便之后获取每个节点的序列号</li><li>通过编写getPreNode方法，获取当前节点的前驱节点</li><li>通过CountDownLatch实现阻塞功能</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        currentNodePath = zooKeeper.create(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + lockName + <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);<br>        <span class="hljs-comment">// 获取前驱节点：若前驱节点为空，则获取锁成功，否则监听该节点</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">preNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getPreNode();<br>        <span class="hljs-keyword">if</span> (preNode != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 利用闭锁实现阻塞</span><br>            <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 因为获取前驱节点操作不具备原子性，需要再次判断zk中的前驱节点是否存在</span><br>            <span class="hljs-keyword">if</span> (zooKeeper.exists(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + preNode, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> &#123;<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;) == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            countDownLatch.await();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">getPreNode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取根节点下的所有节点</span><br>        List&lt;String&gt; children = <span class="hljs-built_in">this</span>.zooKeeper.getChildren(ROOT_PATH, <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(children)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(<span class="hljs-string">&quot;非法操作&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 获取根节点中对应于当前锁的所有节点</span><br>        List&lt;String&gt; nodes = children.stream().filter(node -&gt; StringUtils.startsWith(node, lockName + <span class="hljs-string">&quot;-&quot;</span>)).collect(Collectors.toList());<br>        <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(nodes)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(<span class="hljs-string">&quot;非法操作&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 按照序列号排序</span><br>        Collections.sort(nodes);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">currentNode</span> <span class="hljs-operator">=</span> StringUtils.substringAfterLast(currentNodePath, <span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-comment">// 获取当前节点对应的下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Collections.binarySearch(nodes, currentNode);<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(<span class="hljs-string">&quot;非法操作&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 返回当前节点的前驱节点</span><br>            <span class="hljs-keyword">return</span> nodes.get(index - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(<span class="hljs-string">&quot;非法操作&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 删除ZNode节点</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">this</span>.zooKeeper.delete(currentNodePath, -<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-5-3-实现可重入功能"><a href="#3-5-3-实现可重入功能" class="headerlink" title="3.5.3 实现可重入功能"></a>3.5.3 实现可重入功能</h4><p>通过ThreadLocal这一线程局部变量，记录重入次数</p><p>改造代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 判断thread local中是否已经有锁，有锁则直接重入+1</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> THREAD_LOCAL.get();<br>        <span class="hljs-keyword">if</span> (flag != <span class="hljs-literal">null</span> &amp;&amp; flag &gt; <span class="hljs-number">0</span>) &#123;<br>            THREAD_LOCAL.set(flag + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        currentNodePath = zooKeeper.create(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + lockName + <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);<br>        <span class="hljs-comment">// 获取前驱节点：若前驱节点为空，则获取锁成功，否则监听该节点</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">preNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getPreNode();<br>        <span class="hljs-keyword">if</span> (preNode != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 利用闭锁实现阻塞</span><br>            <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 因为获取前驱节点操作不具备原子性，需要再次判断zk中的前驱节点是否存在</span><br>            <span class="hljs-keyword">if</span> (zooKeeper.exists(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + preNode, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> &#123;<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;) == <span class="hljs-literal">null</span>) &#123;<br>                THREAD_LOCAL.set(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            countDownLatch.await();<br>        &#125;<br>        THREAD_LOCAL.set(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 删除ZNode节点</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        THREAD_LOCAL.set(THREAD_LOCAL.get() - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 减为0则删除</span><br>        <span class="hljs-keyword">if</span> (THREAD_LOCAL.get() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">this</span>.zooKeeper.delete(currentNodePath, -<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6-Curator"><a href="#3-6-Curator" class="headerlink" title="3.6 Curator"></a>3.6 Curator</h3><p>Curator由一系列的模块构成，对于一般开发者而言，常用的是curator-framework和curator-recipes：</p><ul><li>curator-framework：提供了常见的zk相关的底层操作</li><li>curator-recipes：提供了一些zk的典型使用场景的参考</li></ul><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置Curator：新建CuratorConfig配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CuratorConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CuratorFramework <span class="hljs-title function_">curatorFramework</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 初始化重试策略，使用的指数补偿策略</span><br>        <span class="hljs-type">RetryPolicy</span> <span class="hljs-variable">retry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">10000</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 设置初始间隔时间与重试次数</span><br>        <span class="hljs-comment">// 初始化curatork客户端</span><br>        <span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory.newClient(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>, retry);<br>        client.start(); <span class="hljs-comment">// 手动启动，否则很多方法功能不能够工作</span><br>        <span class="hljs-keyword">return</span> client;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-6-1-InterProcessMutex"><a href="#3-6-1-InterProcessMutex" class="headerlink" title="3.6.1 InterProcessMutex"></a>3.6.1 InterProcessMutex</h4><p>与ReentrantLock类似，拥有可重入的特性。</p><h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><p>注入CuratorFramework，修改StockService中的deduct方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> CuratorFramework curatorFramework;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">InterProcessMutex</span> <span class="hljs-variable">mutex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessMutex</span>(curatorFramework, <span class="hljs-string">&quot;/curator/locks&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        mutex.acquire();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.testSub(mutex); <span class="hljs-comment">// 测试可重入</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mutex.release();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSub</span><span class="hljs-params">(InterProcessMutex mutex)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        mutex.acquire();<br>        System.out.println(<span class="hljs-string">&quot;测试可重入锁。。。。&quot;</span>);<br>        mutex.release();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h5><p>InterProcessMutex初始化原理</p><ol><li><p>首先调用如下构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将传入的参数再传入到下一个构造方法中</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">InterProcessMutex</span><span class="hljs-params">(CuratorFramework client, String path)</span><br>&#123;<br>    <span class="hljs-built_in">this</span>(client, path, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardLockInternalsDriver</span>());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>进一步调用构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// this中的第一个参数为传进来的client，第二个参数为传进来的path</span><br><span class="hljs-comment">// 第三个参数为常量LOCK_NAME:&quot;lock-&quot;</span><br><span class="hljs-comment">// 第四个参数为驱动Driver：new StandardLockInternalsDriver()</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">InterProcessMutex</span><span class="hljs-params">(CuratorFramework client, String path, LockInternalsDriver driver)</span><br>&#123;<br>    <span class="hljs-comment">// 1为租约：maxLeases</span><br>    <span class="hljs-built_in">this</span>(client, path, LOCK_NAME, <span class="hljs-number">1</span>, driver);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>再进一步调用构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">InterProcessMutex(CuratorFramework client, String path, String lockName, <span class="hljs-type">int</span> maxLeases, LockInternalsDriver driver)<br>&#123;<br>    <span class="hljs-comment">// 这是对传进来的path参数做校验</span><br>    basePath = PathUtils.validatePath(path);<br>    <span class="hljs-comment">// LockInternals实例化很关键，之后的加锁与解锁方法都需要用到这个类</span><br>    internals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockInternals</span>(client, driver, path, lockName, maxLeases);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建LockInternals对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">LockInternals(CuratorFramework client, LockInternalsDriver driver, String path, String lockName, <span class="hljs-type">int</span> maxLeases)<br>&#123;<br>    <span class="hljs-built_in">this</span>.driver = driver;<br>    <span class="hljs-built_in">this</span>.lockName = lockName;<br>    <span class="hljs-built_in">this</span>.maxLeases = maxLeases;<br><br>    <span class="hljs-built_in">this</span>.client = client.newWatcherRemoveCuratorFramework();<br>    <span class="hljs-comment">// 再次校验path参数</span><br>    <span class="hljs-built_in">this</span>.basePath = PathUtils.validatePath(path);<br>    <span class="hljs-comment">// 将路径与锁名称进行拼接</span><br>    <span class="hljs-built_in">this</span>.path = ZKPaths.makePath(path, lockName);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>加锁原理</p><ol><li><p>执行 <code>mutex.acquire()</code> 方法时，内部调用acquire方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br>    <span class="hljs-keyword">if</span> ( !internalLock(-<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>) )<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Lost connection while trying to acquire lock: &quot;</span> + basePath);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>内部又调用了internalLock方法：直接看注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">internalLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">currentThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">// 通过当前线程获取localData对象</span><br>    <span class="hljs-type">LockData</span> <span class="hljs-variable">lockData</span> <span class="hljs-operator">=</span> threadData.get(currentThread);<br>    <span class="hljs-comment">// 如果lockData不为null，说明发生了重入</span><br>    <span class="hljs-keyword">if</span> ( lockData != <span class="hljs-literal">null</span> )<br>    &#123;<br>        <span class="hljs-comment">// 将重入次数加1，然后直接返回即可</span><br>        lockData.lockCount.incrementAndGet();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-comment">// lockData为null，说明是获取新的锁</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockPath</span> <span class="hljs-operator">=</span> internals.attemptLock(time, unit, getLockNodeBytes());<br>    <span class="hljs-keyword">if</span> ( lockPath != <span class="hljs-literal">null</span> )<br>    &#123;<br>        <span class="hljs-comment">// 创建一个新的lockData，并将当前线程的lockData记录到哈希表中</span><br>        <span class="hljs-type">LockData</span> <span class="hljs-variable">newLockData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockData</span>(currentThread, lockPath);<br>        threadData.put(currentThread, newLockData);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中threadData是一个ConcurrentMap，key为Thread，值为LockData。记录了重入信息。</p><p>LockData是一个内部类</p><p>threadData与LockData属性如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;Thread, LockData&gt; threadData = Maps.newConcurrentMap();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockData</span><br>&#123;<br>    <span class="hljs-keyword">final</span> Thread owningThread; <span class="hljs-comment">// 所属线程</span><br>    <span class="hljs-keyword">final</span> String lockPath; <span class="hljs-comment">// 锁路径</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">lockCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 重入次数</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LockData</span><span class="hljs-params">(Thread owningThread, String lockPath)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.owningThread = owningThread;<br>        <span class="hljs-built_in">this</span>.lockPath = lockPath;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>获取新的锁时，会调用 <code>internals.attemptLock()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">attemptLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit, <span class="hljs-type">byte</span>[] lockNodeBytes)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>      <span class="hljs-variable">startMillis</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Long</span>      <span class="hljs-variable">millisToWait</span> <span class="hljs-operator">=</span> (unit != <span class="hljs-literal">null</span>) ? unit.toMillis(time) : <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[]    localLockNodeBytes = (revocable.get() != <span class="hljs-literal">null</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>] : lockNodeBytes;<br>    <span class="hljs-type">int</span>             <span class="hljs-variable">retryCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">String</span>          <span class="hljs-variable">ourPath</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span>         <span class="hljs-variable">hasTheLock</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span>         <span class="hljs-variable">isDone</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 死循环重复尝试获取锁</span><br>    <span class="hljs-keyword">while</span> ( !isDone )<br>    &#123;<br>        isDone = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-comment">// 创建一个当前锁的节点（临时序列化节点），并获取当前锁的全路径</span><br>            ourPath = driver.createsTheLock(client, path, localLockNodeBytes);<br>            hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> ( KeeperException.NoNodeException e )<br>        &#123;<br>            <span class="hljs-keyword">if</span> ( client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper()) )<br>            &#123;<br>                isDone = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( hasTheLock )<br>    &#123;<br>        <span class="hljs-keyword">return</span> ourPath;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-6-2-其它锁"><a href="#3-6-2-其它锁" class="headerlink" title="3.6.2 其它锁"></a>3.6.2 其它锁</h4><ol><li><p>InterceProcessSemaphoreMutex：不可重入锁，其它与InterProcessMutex一致</p></li><li><p>InterProcessReadWriteMutex：读写锁 -&gt; 读读可并发，读写不可并发，写写不可并发</p><p>有一个不同于Redisson分布式读写锁的特点：写锁在释放之前仍会阻塞请求线程，而读锁不会</p><ol><li><p>在StockController中加入如下两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/zk/read/lock&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testZkReadLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testZkReadLock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test Zk read lock&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@GetMapping(&quot;test/zk/write/lock&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testZkWriteLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testZkWriteLock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test Zk write lock&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService中加入如下两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testZkReadLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">InterProcessReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessReadWriteLock</span>(curatorFramework, <span class="hljs-string">&quot;/curator/rwLock&quot;</span>);<br>        lock.readLock().acquire(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        <span class="hljs-comment">//lock.readLock().release();</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testZkWriteLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">InterProcessReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessReadWriteLock</span>(curatorFramework, <span class="hljs-string">&quot;/curator/rwLock&quot;</span>);<br>        lock.writeLock().acquire(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        <span class="hljs-comment">//lock.readLock().release();</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>InterProcessMultiLock：联锁。所有的锁都加锁成功才算成功，否则加锁失败</p></li><li><p>InterProcessSemaphoreV2：信号量。限流作用</p><p>修改StockService中的testSemaphore方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSemaphore</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">InterProcessSemaphoreV2</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessSemaphoreV2</span>(curatorFramework, <span class="hljs-string">&quot;/curator/locks&quot;</span>, <span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Lease</span> <span class="hljs-variable">lease</span> <span class="hljs-operator">=</span> semaphore.acquire();<br>        <span class="hljs-built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-string">&quot;10086获取资源，开始处理...&quot;</span> + Thread.currentThread().getName());<br>        TimeUnit.SECONDS.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">10</span>));<br>        <span class="hljs-built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-string">&quot;10086处理完成，释放资源...&quot;</span> + Thread.currentThread().getName());<br>        semaphore.returnLease(lease);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>共享计数器：类似于CountDownLatch</p><p>Curator提供了两个实现类：SharedCount与DistributedAtomicNumber </p><p>SharedCount实现如下：</p><ol><li><p>StockController中新增如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/sharedCount&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testSharedCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testSharedCount();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test SharedCount&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>StockService中新增如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSharedCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">SharedCount</span> <span class="hljs-variable">sharedCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedCount</span>(curatorFramework, <span class="hljs-string">&quot;/curator/sharedcount&quot;</span>, <span class="hljs-number">100</span>);<br>        sharedCount.start();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> sharedCount.getCount();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1000</span>);<br>        sharedCount.setCount(random);<br>        System.out.println(<span class="hljs-string">&quot;共享计数器初始值为：&quot;</span> + count + <span class="hljs-string">&quot;, 现在值为：&quot;</span> + random);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="4-MySQL分布式锁"><a href="#4-MySQL分布式锁" class="headerlink" title="4. MySQL分布式锁"></a>4. MySQL分布式锁</h2><h3 id="4-1-实现方案"><a href="#4-1-实现方案" class="headerlink" title="4.1 实现方案"></a>4.1 实现方案</h3><p>数据库准备工作</p><ol><li><p>新建一张表tb_lock，两个字段分别为：id、lock_name</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221020232747128.png" alt="image-20221020232747128"></p></li><li><p>为lock_name设置索引，索引类型为unique唯一键索引</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221020232946531.png" alt="image-20221020232946531"></p></li></ol><p>思路为：</p><ol><li><p>加锁时执行如下SQL语句，若执行成功则代表加锁成功</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb_lock(lock_name) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;lock&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>释放锁时，通过delete删除对应的锁记录</p></li></ol><p>代码实现：</p><ol><li><p>在pojo包下新建Lock类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;tb_lock&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String lockName;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在mapper包下创建LockMapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LockMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Lock&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改StockService中的deduct方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Lock</span>();<br>        lock.setLockName(<span class="hljs-string">&quot;lock&quot;</span>);<br>        <span class="hljs-built_in">this</span>.lockMapper.insert(lock);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.lockMapper.deleteById(lock.getId());<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>            <span class="hljs-built_in">this</span>.deduct();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(ex);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>经过JMeter测试之后发现，基于MySQL实现的分布式锁虽然实现了并发下将库存减为0的功能，但是性能极差。</p><h3 id="4-2-小结"><a href="#4-2-小结" class="headerlink" title="4.2 小结"></a>4.2 小结</h3><ol><li><p>独占排他互斥使用：采用唯一键索引实现</p></li><li><p>防死锁：客户端程序获取到锁之后，客户端服务器宕机造成死锁。</p><ul><li><p>解决方案：为tb_lock表添加获取锁时间字段lock_time，根据系统当前时间进行判断是否超时。</p><p>需要采用额外的定时器去检查获取锁的系统时间与当前系统时间的差值是否超过某一阈值</p></li></ul></li><li><p>可重入：</p><ul><li>解决方案：为tb_lock表添加server_id字段，代表对应的服务器；添加thread_id字段，代表对应服务器的线程；添加count字段，代表重入次数。</li></ul></li><li><p>防误删：借助于id的唯一性防误删</p></li><li><p>原子性：单个写操作，还可借助MySQL悲观锁</p></li><li><p>自动续期：使用服务内的定时器重置获取锁的系统时间</p></li><li><p>单机故障：搭建MySQL主备服务器</p></li><li><p>集群下锁机制失效：难解决</p></li><li><p>阻塞锁：难实现</p></li></ol><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ol><li>简易程度：MySQL最简单，其次Redis，Zookeeper最难</li><li>性能：Redis &gt; Zookeeper &gt; MySQL</li><li>可靠性：Zookeeper &gt; Redis &#x3D; MySQL</li></ol><ul><li>如果要求不高、只实现独占排他、不要求可靠性与性能，选择MySQL</li><li>如果追求性能，选择Redis</li><li>如果追求可靠性，选择Zookeeper</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>锁</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>MySQL</tag>
      
      <tag>Redis</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 870. Advantage Shuffle</title>
    <link href="/2022/10/08/LC-Solution-870-Advantage-Shuffle/"/>
    <url>/2022/10/08/LC-Solution-870-Advantage-Shuffle/</url>
    
    <content type="html"><![CDATA[<h1 id="870-Advantage-Shuffle"><a href="#870-Advantage-Shuffle" class="headerlink" title="870. Advantage Shuffle"></a><a href="https://leetcode.cn/problems/advantage-shuffle/">870. Advantage Shuffle</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个大小相等的数组 <code>nums1</code> 和 <code>nums2</code>，<code>nums1</code> 相对于 <code>nums</code> 的优势可以用满足 <code>nums1[i]</code> &gt; <code>nums2[i]</code> 的索引 <code>i</code> 的数目来描述。</p><p>返回 <code>nums1</code> 的任意排列，使其相对于 <code>nums2</code> 的优势最大化。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums1 = <span class="hljs-string">[2,7,11,15]</span>, nums2 = <span class="hljs-string">[1,10,4,11]</span><br>输出：<span class="hljs-string">[2,11,7,15]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums1 = <span class="hljs-string">[12,24,8,32]</span>, nums2 = <span class="hljs-string">[13,25,32,11]</span><br>输出：<span class="hljs-string">[24,32,8,12]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>1 &lt;&#x3D; nums1.length &lt;&#x3D; 105</p></li><li><p>nums2.length &#x3D;&#x3D; nums1.length</p></li><li><p>0 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 109</p></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：田忌赛马-gt-贪心-双指针"><a href="#方法一：田忌赛马-gt-贪心-双指针" class="headerlink" title="方法一：田忌赛马 -&gt; 贪心 + 双指针"></a>方法一：田忌赛马 -&gt; 贪心 + 双指针</h3><p>该方案采用的是 <a href="%5B%E5%8A%9B%E6%89%A3%5D(https://leetcode.cn/problems/advantage-shuffle/solution/tian-ji-sai-ma-by-endlesscheng-yxm6/)">灵神</a> 的题解，下面我说一下我的理解</p><p>题目要求使 <code>nums1</code> 数组 <strong>“战胜”</strong> <code>nums2</code> 数组的次数最大化</p><p>通过此很容易想到贪心思路，对 <code>nums1</code> 与 <code>nums2</code> 分别进行排序，</p><p>然后对比 <code>nums1</code> 当前最小值 与 <code>nums2</code> 当前最小值</p><ul><li><p>若 <code>nums1</code> 的当前最小值大于 <code>nums2</code> 的当前最小值，则 <code>nums1</code> 获胜</p></li><li><p>否则，说明 <code>nums1</code> 的当前最小值无法战胜 <code>nums2</code> 的所有值，所以让 <code>nums1</code> 的当前最小值与 <code>nums2</code> 的当前最大值作战（即当“炮灰”），这样可以抵消掉 <code>nums2</code> 的最大值。</p></li></ul><p>这就是典型的 <code>田忌赛马</code> 思路，用下等马去战胜上等马！</p><ul><li><code>nums1</code> 的下等马无法战胜 <code>nums2</code> 的下等马时，就让其当炮灰去对战 <code>nums2</code> 的上等马</li></ul><p>每一个 “作战回合” 结束之后，需要将本回合用过的元素摒弃掉。</p><p>而 <code>nums2</code> 的最小值（即数组尾元素）或最大值（即数组首元素）均可能被使用，所以本题采用 <code>首尾双指针</code> 思路，逐渐缩小问题规模，最终得到全部对应关系。</p><p>但在代码具体实现过程中，如果对两个数组均进行排序，则丢失了原本的 ”作战“ 顺序，所以只对 <code>nums1</code> 进行排序。用额外的下标数组 <code>ids</code>，根据 <code>nums2</code> 的元素大小，对其下标进行排序。<code>ids[0]</code> 对应 <code>nums2</code> 第一小值下标，<code>ids[1]</code> 对应 <code>nums2</code> 第二小值下标…</p><p>通过 <code>ids</code> 数组，就可以知道当前 <code>nums2</code> 下标所要对应的 <code>nums1</code> 元素。</p><p>感觉这道题直接看代码更容易理解。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">advantageCount</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums1)<br>        ans = [<span class="hljs-number">0</span>] * n<br>        nums1.sort()<br>        ids = <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">range</span>(n), key=<span class="hljs-keyword">lambda</span> i: nums2[i])<br>        left, right = <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums1:<br>            <span class="hljs-keyword">if</span> x &gt; nums2[ids[left]]:<br>                ans[ids[left]] = x  <br>                left += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                ans[ids[right]] = x  <br>                right -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>注意：Java采用比较器排序时，只能使用包装类Integer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] advantageCount(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums2.length;<br>        Integer[] ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) ids[i] = i;<br>        Arrays.sort(nums1);<br>        Arrays.sort(ids, (a, b) -&gt; nums2[a] - nums2[b]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, q = len - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : nums1) &#123;<br>            <span class="hljs-keyword">if</span>(x &gt; nums2[ids[p]]) ans[ids[p++]] = x;<br>            <span class="hljs-keyword">else</span> ans[ids[q--]] = x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第15篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1800. Maximum Ascending Subarray Sum</title>
    <link href="/2022/10/07/LC-Solution-1800-Maximum-Ascending-Subarray-Sum/"/>
    <url>/2022/10/07/LC-Solution-1800-Maximum-Ascending-Subarray-Sum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/maximum-ascending-subarray-sum/">1800. 最大升序子数组和</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数组成的数组 <code>nums</code> ，返回 <code>nums</code> 中一个 <strong>升序</strong> 子数组的最大可能元素和。</p><p>子数组是数组中的一个连续数字序列。</p><p>已知子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，若对所有 <code>i</code>（<code>l &lt;= i &lt; r</code>），<code>numsi</code> &lt; <code>numsi+1</code> 都成立，则称这一子数组为 <strong>升序</strong> 子数组。注意，大小为 1 的子数组也视作 <strong>升序</strong> 子数组。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[10,20,30,5,10,50]</span><br>输出：65<br>解释：<span class="hljs-comment">[5,10,50]</span> 是元素和最大的升序子数组，最大元素和为 65 。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[10,20,30,40,50]</span><br>输出：<span class="hljs-number">150</span><br>解释：<span class="hljs-string">[10,20,30,40,50]</span> 是元素和最大的升序子数组，最大元素和为 <span class="hljs-number">150</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[12,17,15,13,10,11,12]</span><br>输出：33<br>解释：<span class="hljs-comment">[10,11,12]</span> 是元素和最大的升序子数组，最大元素和为 33 。 <br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">100,10,1</span>]<br>输出：<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：简单模拟"><a href="#方法一：简单模拟" class="headerlink" title="方法一：简单模拟"></a>方法一：简单模拟</h3><p>遍历数组，比较相邻元素之间是否满足升序条件。</p><p>用 <code>s</code> 记录当前升序子数组的和，用 <code>ans</code> 记录最终最大的和。</p><ul><li><p>若当前元素大于前一个元素（ <code>nums[i] &gt; nums[i - 1</code>] ），将当前元素 <code>nums[i]</code> 累加到 <code>s</code> 中，并更新 <code>ans = max(ans, s)</code></p></li><li><p>否则，将 <code>s</code> 重置为当前元素，即 <code>s = nums[i]</code></p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxAscendingSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = s = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[i - <span class="hljs-number">1</span>]:<br>                s += nums[i]<br>                ans = <span class="hljs-built_in">max</span>(ans, s)<br>            <span class="hljs-keyword">else</span>:<br>                s = nums[i]<br>        <span class="hljs-keyword">return</span> ans      <br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAscendingSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>], sum = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                sum += nums[i];<br>                ans = Math.max(ans, sum);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sum = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第14篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo从0到1搭建博客系列03：文章与评论模块</title>
    <link href="/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9703%EF%BC%9A%E6%96%87%E7%AB%A0%E4%B8%8E%E8%AF%84%E8%AE%BA%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9703%EF%BC%9A%E6%96%87%E7%AB%A0%E4%B8%8E%E8%AF%84%E8%AE%BA%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo从0到1搭建博客系列03：文章与评论模块"><a href="#Hexo从0到1搭建博客系列03：文章与评论模块" class="headerlink" title="Hexo从0到1搭建博客系列03：文章与评论模块"></a>Hexo从0到1搭建博客系列03：文章与评论模块</h1><h2 id="1-文章的编辑与发布"><a href="#1-文章的编辑与发布" class="headerlink" title="1. 文章的编辑与发布"></a>1. 文章的编辑与发布</h2><p>在这一部分，我们主要学习如何编辑文章，并将其发布在Hexo博客上。</p><p>这一部分我们仍然在Hexo博客根目录上操作。</p><ol><li>执行以下命令，创建一篇新的文章。引号内为博客的标题</li></ol>  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;&quot;</span><br>e.g.: hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;我的第一篇博客&quot;</span><br></code></pre></td></tr></table></figure><p>  如图所示，该博客已经被创建到 <code>source/_posts</code> 目录下啦</p><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/first-blog.png"></p><ol start="2"><li>编辑该页面，可以看到如下信息（可以采用 <a href="https://github.com/marktext/marktext">MarkText</a> 进行编辑，这个是免费的）</li></ol>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">我的第一篇博客</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-10-05 16:00:30</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>  其中包含了博客的 <code>title</code>、<code>date</code>、<code>tags</code>信息</p><ol start="3"><li>接下来，我们编辑博客的 <code>tags</code> 与 <code>categories</code>，仍然需要注意 <code>yaml</code> 格式</li></ol>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">我的第一篇博客</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-10-05 16:00:30</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">学习感悟</span>, <span class="hljs-string">知识分享</span>, <span class="hljs-string">Java</span>]<br><span class="hljs-attr">categories:</span> [<span class="hljs-string">Java基础</span>]<br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><ol start="4"><li>在下面接着编辑博客内容（可以采用 <a href="https://github.com/marktext/marktext">MarkText</a> 进行编辑，这个是免费的）</li></ol><p>  示例如下：</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">我的第一篇博客</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-10-05 16:00:30</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">学习感悟</span>, <span class="hljs-string">知识分享</span>, <span class="hljs-string">Java</span>]<br><span class="hljs-attr">categories:</span> [<span class="hljs-string">Java基础</span>]<br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-comment"># 我的第一篇博客</span><br><br><span class="hljs-comment">## 1. Java基础</span><br><br><span class="hljs-string">Java是一门后端语言，我爱Java。</span><br><br><span class="hljs-comment">## 2. Java实战</span><br><br><span class="hljs-string">第一行代码</span><br><br><span class="hljs-string">```java</span><br><span class="hljs-string">System.out.println(&quot;Hello</span> <span class="hljs-string">World!&quot;);</span><br></code></pre></td></tr></table></figure><ol start="5"><li><code>Ctrl + S</code> 保存，然后将博客运行到本地服务器。</li></ol>  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>这样一来就可以完成博客的编辑与发布啦，看看成品吧~</p><p>下面那一篇是 <code>Hexo</code> 初始化的文章</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/blog-content1.png" alt="https//cdnjsdelivrnet/gh/ltyzzzxxx/ltyzzzImageBed/blogimg/blogcontentpng"></p><p>进入 <code>分类</code>、<code>标签</code> 页可以看到相应的内容</p><h2 id="2-引入评论模块"><a href="#2-引入评论模块" class="headerlink" title="2. 引入评论模块"></a>2. 引入评论模块</h2><p>引入评论听起来非常高大上。如果自己手动搭建一个评论系统，将是需要一定技术的工作，而在<code>Hexo-Fluid</code> 中，这仅仅只是一个简单的配置</p><ol><li>打开之前粘贴好的 <code>_config.fluid.yml</code> 文件，找到以下内容。</li></ol>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">comments:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">disqus</span><br></code></pre></td></tr></table></figure><p>  这里我推荐使用另外一个评论插件 <code>Valine</code>，所以将type进行相应的更改。</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">comments:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">valine</span><br></code></pre></td></tr></table></figure><p>  其他评论插件官方文档有详细的写，如果想尝试其他的，请点击[这里](<a href="https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA">配置指南 | Hexo Fluid 用户手册</a>)查找~</p><ol start="2"><li><p>进入 <a href="https://valine.js.org/quickstart.html">Valine</a> 主页，注册一个 <code>LeanCloud</code> 账号，然后完成相应的实名认证。这一部分就比较简单啦，不再赘述。</p></li><li><p>进入 <code>LeanCloud</code> 个人主页控制台，左上角创建应用。</p></li></ol><p>  我已经创建过啦，就不再创建了。</p><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/leadcloud-page.png"></p><ol start="4"><li>点击进入创建好的应用，点击左侧菜单 设置 - 应用凭证，就可以看到相应的配置信息啦</li></ol><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/leancloud-key.png"></p><ol start="5"><li>将 <code>AppID</code> 与 <code>AppKey</code> 复制并粘贴到 <code>_config.fluid.yml</code> 文件中如下相应的位置</li></ol>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">valine:</span><br>  <span class="hljs-attr">appId:</span> <span class="hljs-string">xxxxx</span><br>  <span class="hljs-attr">appKey:</span> <span class="hljs-string">xxxxx</span><br></code></pre></td></tr></table></figure><ol start="6"><li>保存配置文件，再次运行博客到本地服务器</li></ol>  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>打开之前发布的博客页，拉到最底部，即可看到评论界面啦~</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/comment.png"></p><p>由于 <code>Valine</code> 是一个无后端评论系统，想要管理评论的话，得去 <code>LeanCloud</code> 后台数据存储进行管理相关评论数据。</p><h2 id="3-后记"><a href="#3-后记" class="headerlink" title="3. 后记"></a>3. 后记</h2><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>Hexo搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo从0到1搭建博客系列02：引入Fluid</title>
    <link href="/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9702%EF%BC%9A%E5%BC%95%E5%85%A5Fluid/"/>
    <url>/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9702%EF%BC%9A%E5%BC%95%E5%85%A5Fluid/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo从0到1搭建博客系列02：引入Fluid"><a href="#Hexo从0到1搭建博客系列02：引入Fluid" class="headerlink" title="Hexo从0到1搭建博客系列02：引入Fluid"></a>Hexo从0到1搭建博客系列02：引入Fluid</h1><h2 id="1-Fluid简介"><a href="#1-Fluid简介" class="headerlink" title="1. Fluid简介"></a>1. Fluid简介</h2><blockquote><p>Fluid [官网](<a href="https://hexo.fluid-dev.com/docs/start/">开始使用 | Hexo Fluid 用户手册</a>)</p><p>Fluid 是基于 Hexo 的一款 Material Design 风格的主题，由 Fluid-dev 负责开发与维护。</p><p>主题 GitHub: <a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>预览网站：<a href="https://hexo.fluid-dev.com/">Fluid’s blog</a> <a href="https://zkqiang.cn/">zkqiang’s blog</a></p></blockquote><p>Fluid其实就是基于Hexo现有功能，进行了更进一步的配置、美化，引入了很多新的功能，使我们的博客变得更加美观、简洁与高效。</p><p>在进行Fluid实战之前，必须得先搭建好Hexo基础博客。</p><h2 id="2-Fluid简单实战"><a href="#2-Fluid简单实战" class="headerlink" title="2. Fluid简单实战"></a>2. Fluid简单实战</h2><ol><li>进入之前搭建好的 <code>Hexo</code> 博客目录，执行以下命令，安装 <code>fluid</code> 主题</li></ol>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid</span><br></code></pre></td></tr></table></figure><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/fluid-install.png"></p><ol start="2"><li>在博客目录下创建 <code>_config.fluid.yml</code>，将 <code>fluid</code> 主题自己的 <code>_config.yml</code> 粘贴进去。</li></ol><p>  这一步很重要，一定要进入<a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml%E8%BF%99%E4%B8%80%E7%BD%91%E9%A1%B5%EF%BC%8C">https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml这一网页，</a> 将对应的文件粘贴到之前创建好的空的<code>_config.fluid.yml</code>文件中。这个文件很长，所以没办法贴在这里，见谅~</p><ol start="3"><li>打开创建好的 <code>Hexo</code> 博客目录下的 <code>_config.yml</code> ，将对应配置项修改为以下内容</li></ol><p>  一定要注意这是 <code>yaml</code> 格式文件，冒号后一定要有空格。</p><p>  灵活使用 <code>Ctrl + F</code> 搜索关键字</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><p>仍然是使用 <code>hexo server</code> 命令运行到本地</p><p>展示一下成品吧~</p><p><img src="file:///Users/lty/Downloads/hexo-fluid-page.png?msec=1664956366776"></p><p>是不是瞬间比之前Hexo基础博客提升了一个档次？</p><p>之后我们的大部分功能将在 <code>_config.fluid.yml</code> 文件里完成配置~</p><h2 id="3-后记"><a href="#3-后记" class="headerlink" title="3. 后记"></a>3. 后记</h2><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>Hexo搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo从0到1搭建博客系列01：浅尝Hexo.md</title>
    <link href="/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9701%EF%BC%9A%E6%B5%85%E5%B0%9DHexo-md/"/>
    <url>/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9701%EF%BC%9A%E6%B5%85%E5%B0%9DHexo-md/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo从0到1搭建博客系列01：浅尝Hexo"><a href="#Hexo从0到1搭建博客系列01：浅尝Hexo" class="headerlink" title="Hexo从0到1搭建博客系列01：浅尝Hexo"></a>Hexo从0到1搭建博客系列01：浅尝Hexo</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>作为一个程序员，我们总是想记录一些自己日常学习的东西、自己对于技术的思考以及自己平时折腾的一些小项目。但是自己手动搭建一个博客是很费时费力的一件事情，我们需要考虑一下几点难题：</p><ol><li><p>制作一个博客网站需要这些技术：后端采用 <code>SpringBoot</code> 全家桶，前端采用 <code>Vue/React</code> 。如果追求快速搭建一个博客，可以使用全栈 <code>nodejs</code>（ <code>egg.js</code>、<code>express</code>、<code>koa</code> 等）。如果想让博客功能更强大，需要引入更多的技术。但这些技术的学习都很耗时费力，极可能劝退。</p></li><li><p>如果想让博客页面更好看，需要自己设计 <code>UI</code>。</p></li><li><p>博客最终展示给别人，需要部署到服务器上才能让大家看到。需要买服务器、买域名、域名备案、学习部署知识等等。</p></li><li><p>服务器后期需要维护，一年维护费用可能几百至上千不等。</p></li><li><p>服务器被人恶意攻击（ <code>DDOS</code>、 <code>SQL注入</code> 等），需要自己手动解决或花钱升级服务器。</p></li></ol><p>如果你想要通过博客项目，以此学习前后端的知识、提升自己的编程水平甚至是将其作为一个简历上可以拿得出手的项目，我强烈建议你将以上步骤逐一完成，甚至可以将个人博客延伸为社交博客论坛（类似 <code>CSDN</code>、<code>掘金</code> 等），引入微服务与分布式技术。将这些做完，绝对会有明显的技术提升。</p><p>但是，如果你只想有一个自己的网站去记录一些日常的学习等内容，继续往下看，我将会使用 <code>Hexo</code> 简化以上流程，从0到1实现一个美观精致高效的博客。</p><h2 id="2-Hexo简介"><a href="#2-Hexo简介" class="headerlink" title="2. Hexo简介"></a>2. Hexo简介</h2><p>首先简单介绍一下 <code>Hexo</code></p><blockquote><p>引自[官方](<a href="https://hexo.io/zh-cn/docs/index.html">文档 | Hexo</a>)</p><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p>其实 <code>Hexo</code> 就是帮我们完成了大部分与书写博客无关的事情，我们只需要根据 <code>Hexo</code> 现有的框架，做一些简单的配置，即可做出一个博客网站。之后，我们就可以专注地写自己的博客啦</p><p>在接下来的部分中，你只需要有以下几点前置知识，即可快速完成之后系列的全部内容：</p><ol><li><code>Node.js</code>：主要用于安装<code>Hexo</code>、发布文章、部署等操作</li></ol><p>  安装 <code>Node.js</code> ：</p><ol><li><p><a href="https://nodejs.org/en/download/">官网</a>安装</p></li><li><p>Mac可采用 <code>Homebrew</code> 安装</p></li><li><p><code>Git</code> 及 <code>Github</code>：最后的博客网站将发布到 <code>Github</code> 中</p></li><li><p><code>Markdown</code>：这个很简单，在 <code>CSDN</code> 或者用Typora写过博客的人都知道怎么用</p></li></ol><p>之后全部的实战部分，均采用 <code>VSCode</code> 编辑器完成。如果你熟练使用命令行操作，也可以直接在命令行上完成全部操作。</p><h2 id="3-Hexo简单实战"><a href="#3-Hexo简单实战" class="headerlink" title="3. Hexo简单实战"></a>3. Hexo简单实战</h2><ol><li>首先打开命令行窗口，执行以下命令，安装Hexo。</li></ol>  <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/hexo-install.png"></p><ol start="2"><li>选择一个合适的位置（之后博客全部文件所在的地方），执行以下命令。</li></ol><p>  这里我博客命名为ltyzzz-blog</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init ltyzzz<span class="hljs-literal">-blog</span><br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> ltyzzz<span class="hljs-literal">-blog</span><br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><ol start="3"><li>通过 <code>VSCode</code> 打开创建好的博客目录</li></ol><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/hexo-file.png" alt="https//cdnjsdelivrnet/gh/ltyzzzxxx/ltyzzzImageBed/blogimg/hexofilepng"></p><p>  介绍其中几个重要的文件：</p><ul><li><p>_config.yml：博客相关的配置均在这个文件中（之后引入Fluid主题后有所变化）</p></li><li><p>source：用来存放用户资源的位置（我们写的文章就存储在这里）</p></li></ul><ol start="4"><li>执行以下命令，生成静态网页文件 <code>public</code></li></ol>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><ol start="5"><li>执行以下命令，在本地服务器（默认为：<code>http://localhost:4000/</code>）启动博客</li></ol>  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>最终Hexo基础博客页面如图所示：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/hexo-page.png"></p><p>看到这里，是不是感觉Hexo页面十分的简陋甚至有点丑？</p><p>没关系，之前的部分只是带大家简单尝试一下Hexo，了解一下基本的框架与命令使用。</p><p>我们的重头戏将放在Fluid主题，通过该主题熟悉Hexo核心功能以及Fluid新增的功能。</p><p>接下来的内容包括有：</p><ol><li>博客文章的编辑与发布</li><li>评论区功能模块引入</li><li>图床的最佳实践</li><li>新增留言板界面</li><li>将博客部署到Github</li></ol><h2 id="4-后记"><a href="#4-后记" class="headerlink" title="4. 后记"></a>4. 后记</h2><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>Hexo搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 811. Subdomain Visit Count</title>
    <link href="/2022/10/05/LC-Solution-811-Subdomain-Visit-Count/"/>
    <url>/2022/10/05/LC-Solution-811-Subdomain-Visit-Count/</url>
    
    <content type="html"><![CDATA[<h1 id="811-子域名访问计数"><a href="#811-子域名访问计数" class="headerlink" title="811. 子域名访问计数"></a><a href="https://leetcode.cn/problems/subdomain-visit-count/">811. 子域名访问计数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>网站域名 <code>&quot;discuss.leetcode.com&quot;</code> 由多个子域名组成。顶级域名为 <code>&quot;com&quot;</code> ，二级域名为 <code>&quot;leetcode.com&quot;</code> ，最低一级为 <code>&quot;discuss.leetcode.com&quot;</code> 。当访问域名 <code>&quot;discuss.leetcode.com&quot;</code> 时，同时也会隐式访问其父域名 <code>&quot;leetcode.com&quot;</code> 以及 <code>&quot;com&quot;</code> 。</p><p><strong>计数配对域名</strong> 是遵循 <code>&quot;rep d1.d2.d3&quot;</code> 或 <code>&quot;rep d1.d2&quot;</code> 格式的一个域名表示，其中 <code>rep</code> 表示访问域名的次数，<code>d1.d2.d3</code> 为域名本身。</p><p>例如，<code>&quot;9001 discuss.leetcode.com&quot;</code> 就是一个 <strong>计数配对域名</strong> ，表示 <code>discuss.leetcode.com</code> 被访问了 <code>9001</code> 次。<br>给你一个 <strong>计数配对域名</strong> 组成的数组 <code>cpdomains</code> ，解析得到输入中每个子域名对应的 <strong>计数配对域名</strong> ，并以数组形式返回。可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：cpdomains = [<span class="hljs-string">&quot;9001 discuss.leetcode.com&quot;</span>]<br>输出：[<span class="hljs-string">&quot;9001 leetcode.com&quot;</span>,<span class="hljs-string">&quot;9001 discuss.leetcode.com&quot;</span>,<span class="hljs-string">&quot;9001 com&quot;</span>]<br>解释：例子中仅包含一个网站域名：<span class="hljs-string">&quot;discuss.leetcode.com&quot;</span>。<br>按照前文描述，子域名 <span class="hljs-string">&quot;leetcode.com&quot;</span> 和 <span class="hljs-string">&quot;com&quot;</span> 都会被访问，所以它们都被访问了 <span class="hljs-number">9001</span> 次。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：cpdomains = [<span class="hljs-string">&quot;900 google.mail.com&quot;</span>, <span class="hljs-string">&quot;50 yahoo.com&quot;</span>, <span class="hljs-string">&quot;1 intel.mail.com&quot;</span>, <span class="hljs-string">&quot;5 wiki.org&quot;</span>]<br>输出：[<span class="hljs-string">&quot;901 mail.com&quot;</span>,<span class="hljs-string">&quot;50 yahoo.com&quot;</span>,<span class="hljs-string">&quot;900 google.mail.com&quot;</span>,<span class="hljs-string">&quot;5 wiki.org&quot;</span>,<span class="hljs-string">&quot;5 org&quot;</span>,<span class="hljs-string">&quot;1 intel.mail.com&quot;</span>,<span class="hljs-string">&quot;951 com&quot;</span>]<br>解释：按照前文描述，会访问 <span class="hljs-string">&quot;google.mail.com&quot;</span> <span class="hljs-number">900</span> 次，<span class="hljs-string">&quot;yahoo.com&quot;</span> <span class="hljs-number">50</span> 次，<span class="hljs-string">&quot;intel.mail.com&quot;</span> <span class="hljs-number">1</span> 次，<span class="hljs-string">&quot;wiki.org&quot;</span> <span class="hljs-number">5</span> 次。<br>而对于父域名，会访问 <span class="hljs-string">&quot;mail.com&quot;</span> <span class="hljs-number">900</span> + <span class="hljs-number">1</span> = <span class="hljs-number">901</span> 次，<span class="hljs-string">&quot;com&quot;</span> <span class="hljs-number">900</span> + <span class="hljs-number">50</span> + <span class="hljs-number">1</span> = <span class="hljs-number">951</span> 次，和 <span class="hljs-string">&quot;org&quot;</span> <span class="hljs-number">5</span> 次。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><p><code>1 &lt;= cpdomain.length &lt;= 100</code></p></li><li><p><code>1 &lt;= cpdomain[i].length &lt;= 100</code></p></li><li><p><code>cpdomain[i]</code> 会遵循 <code>&quot;repi d1i.d2i.d3i&quot;</code> 或 <code>&quot;repi d1i.d2i&quot;</code> 格式</p></li><li><p><code>repi</code> 是范围 <code>[1, 104]</code> 内的一个整数</p></li><li><p><code>d1i</code>、<code>d2i</code> 和 <code>d3i</code> 由小写英文字母组成</p></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h3><p>通过哈希表统计 <code>cpdomains</code> 中所有的子域名的频率。</p><p>以 <code>google.mail.com</code> 为例，<code>google.mail.com</code> 为三级域名，<code>mail.com</code> 为二级域名，<code>com</code>为顶级域名。</p><p>思路如下：</p><ol><li><p>遍历 <code>cpdomains</code> 列表，获取每一个 <code>cpdomain</code> 的访问次数 <code>cnt</code> 与其域名 <code>domain</code></p></li><li><p>将 <code>domain</code> 的访问次数累加至原哈希表</p></li><li><p>继续遍历 <code>domain</code>的子域名字符串</p></li><li><p>若 <code>domain[i] == &#39;.&#39;</code>，说明其之后为一个完整的子域名，将其访问次数累加到哈希表中。</p></li><li><p>遍历结束之后，将哈希表的 <code>K</code> 与 <code>V</code> 以列表的形式返回</p></li></ol><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subdomainVisits</span>(<span class="hljs-params">self, cpdomains: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        dic = defaultdict(<span class="hljs-built_in">int</span>)<br>        <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> cpdomains:<br>            ds = d.split()<br>            cnt, domain = <span class="hljs-built_in">int</span>(ds[<span class="hljs-number">0</span>]), ds[<span class="hljs-number">1</span>]<br>            dic[domain] += cnt<br>            <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(domain):<br>                <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;.&#x27;</span>:<br>                    dic[domain[i+<span class="hljs-number">1</span>:]] += cnt<br>        <span class="hljs-keyword">return</span> [<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;v&#125;</span> <span class="hljs-subst">&#123;k&#125;</span>&quot;</span> <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> dic.items()]<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第13篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 921. Minumum Add to Make Parentheses Valid</title>
    <link href="/2022/10/04/LC-Solution-921-Minumum-Add-to-Make-Parentheses-Valid/"/>
    <url>/2022/10/04/LC-Solution-921-Minumum-Add-to-Make-Parentheses-Valid/</url>
    
    <content type="html"><![CDATA[<h1 id="921-使括号有效的最少添加"><a href="#921-使括号有效的最少添加" class="headerlink" title="921. 使括号有效的最少添加"></a><a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/">921. 使括号有效的最少添加</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>只有满足下面几点之一，括号字符串才是有效的：</p><ul><li><p>它是一个空字符串，或者</p></li><li><p>它可以被写成 <code>AB</code> （<code>A</code> 与 <code>B</code> 连接）, 其中 <code>A</code> 和 <code>B</code> 都是有效字符串，或者</p></li><li><p>它可以被写作 <code>(A)</code>，其中 <code>A</code> 是有效字符串。</p></li></ul><p>给定一个括号字符串 <code>s</code> ，移动N次，你就可以在字符串的任何位置插入一个括号。</p><p>例如，如果 <code>s = &quot;()))&quot;</code> ，你可以插入一个开始括号为 <code>&quot;(()))&quot;</code> 或结束括号为 <code>&quot;())))&quot;</code> 。<br>返回 为使结果字符串 <code>s</code> 有效而必须添加的最少括号数。</p><p><strong>示例1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;())&quot;</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(((&quot;</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 字符。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：栈"><a href="#方法一：栈" class="headerlink" title="方法一：栈"></a>方法一：栈</h3><p>对于成对出现的括号题，合法的每一对括号是具有顺序的，可以直观地想到用栈解决。</p><p>将成对的括号移除出栈，最后栈中保留的一定是无法成对的括号数量，最终栈的大小即为需要添加的括号次数。</p><p>遍历字符串 <code>s</code>：</p><ul><li><p>若 <code>s[i] == &#39;(&#39;</code>，直接入栈。</p></li><li><p>若 <code>s[i] == &#39;)&#39;</code>，且当前栈不为空 and 栈顶元素为 <code>&#39;(&#39;</code>，说明此时构成了一对合法括号，可以将栈顶的 <code>&#39;(&#39;</code>出栈。若不满足此条件，则将 <code>s[i]</code> 入栈</p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minAddToMakeValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        q = deque() <br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                q.append(x)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> q[-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                    q.pop()<br>                <span class="hljs-keyword">else</span>:<br>                    q.append(x)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(q)<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minAddToMakeValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Character&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> x : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span>(x == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                d.addLast(x);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(!d.isEmpty() &amp;&amp; d.peekLast() == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    d.pollLast();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    d.addLast(x);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> d.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：模拟计数"><a href="#方法二：模拟计数" class="headerlink" title="方法二：模拟计数"></a>方法二：模拟计数</h3><p>根据题意进行模拟，用 <code>cnt</code> 表示 <code>&#39;(&#39;</code>的个数。</p><p>遍历字符串 <code>s</code></p><ul><li><p>若 <code>s[i] == &#39;(&#39;</code>，cnt++</p></li><li><p>若 <code>s[i] == &#39;)&#39;</code>，cnt–，相当于消除一个 <code>&#39;(&#39;</code></p><ul><li>若此时进行 <code>cnt--</code> 操作之后，cnt变为-1，说明 <code>&#39;(&#39;</code>数量不足，需要添加一个 <code>&#39;(&#39;</code>进行额外配对，并将 <code>cnt</code> 重新置为0</li></ul></li></ul><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minAddToMakeValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        cnt, ans = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                cnt -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cnt == -<span class="hljs-number">1</span>:<br>                cnt = <span class="hljs-number">0</span><br>                ans += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans + cnt<br></code></pre></td></tr></table></figure><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minAddToMakeValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> x : s.toCharArray()) &#123;<br>            cnt += x == <span class="hljs-string">&#x27;(&#x27;</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(cnt == -<span class="hljs-number">1</span>) &#123;<br>                cnt = <span class="hljs-number">0</span>;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans + cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第12篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 926. Flip String to Monotone Increasing</title>
    <link href="/2022/10/03/LC-Solution-926-Flip-String-to-Monotone-Increasing/"/>
    <url>/2022/10/03/LC-Solution-926-Flip-String-to-Monotone-Increasing/</url>
    
    <content type="html"><![CDATA[<h1 id="926-Flip-String-to-Monotone-Increasing"><a href="#926-Flip-String-to-Monotone-Increasing" class="headerlink" title="926. Flip String to Monotone Increasing"></a><a href="https://leetcode.cn/problems/flip-string-to-monotone-increasing/">926. Flip String to Monotone Increasing</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如果一个二进制字符串，是以一些 <code>0</code>（可能没有 <code>0</code>）后面跟着一些 <code>1</code>（也可能没有 <code>1</code>）的形式组成的，那么该字符串是 <strong>单调递增</strong> 的。</p><p>给你一个二进制字符串 <code>s</code>，你可以将任何 <code>0</code> 翻转为 <code>1</code> 或者将 <code>1</code> 翻转为 <code>0</code> 。</p><p>返回使 <code>s</code> 单调递增的最小翻转次数。</p><p><strong>示例1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;00110&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：翻转最后一位得到 <span class="hljs-number">00111</span>.<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;010110&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：翻转得到 <span class="hljs-number">011111</span>，或者是 <span class="hljs-number">000111</span>。<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;00011000&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：翻转得到 <span class="hljs-number">00000000</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：前缀和"><a href="#方法一：前缀和" class="headerlink" title="方法一：前缀和"></a>方法一：前缀和</h3><p>题目要求通过翻转 <code>0</code> 与 <code>1</code> 使得最后得到的二进制字符串为单调递增，</p><p>通过此可以想到：统计字符 <code>s[i]</code> 左边 <code>1</code> 数目，右边 <code>0</code> 的数目。将这些 <code>1</code> 与 <code>0</code> 翻转，最终的字符串 <code>s</code> 即可满足单调递增，翻转次数 &#x3D; 左边 <code>1</code> 的数目 + 右边 <code>0</code> 的数目</p><p>因此，该问题可以采用前缀和的思路解决。</p><ul><li><p>设置 <code>sum</code> 数组统计前缀和（长度为 <code>len(s) + 1</code> ）</p></li><li><p><code>sum[i]</code> 代表字符 <code>s[i]</code> 左边 <code>1</code> 的数目（不包含 <code>i</code> ）</p></li><li><p>通过 <code>sum[i]</code> 可计算得到 <code>s[i]</code> 右边 <code>0</code> 的数目（包含 <code>i</code>）</p><ul><li>右边 <code>0</code> 的数目为：<code>(len(s) - i) - (sum[len(s)] - sum[i])</code></li></ul></li></ul><p>遍历两次字符串 <code>s</code> ，求得最终答案</p><ul><li><p>第一次遍历：求得前缀和数组 <code>sum</code></p></li><li><p>第二次遍历：计算当前翻转次数（左边 <code>1</code> 的数目 + 右边 <code>0</code> 的数目）并与 <code>ans</code> 比较，取最小值。</p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minFlipsMonoIncr</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n, ans = <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-built_in">sum</span> = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-built_in">sum</span>[i] = <span class="hljs-built_in">sum</span>[i - <span class="hljs-number">1</span>] + (s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>):<br>            l_ones, r_zeros = <span class="hljs-built_in">sum</span>[i], n - i - (<span class="hljs-built_in">sum</span>[n] - <span class="hljs-built_in">sum</span>[i])<br>            ans = <span class="hljs-built_in">min</span>(ans, l_ones + r_zeros)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFlipsMonoIncr</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            sum[i] = sum[i - <span class="hljs-number">1</span>] + (cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftOnes</span> <span class="hljs-operator">=</span> sum[i], rightZeros = n - i - (sum[n] - sum[i]);<br>            ans = Math.min(ans, leftOnes + rightZeros);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：优化前缀和"><a href="#方法二：优化前缀和" class="headerlink" title="方法二：优化前缀和"></a>方法二：优化前缀和</h3><p>方法一种提到：</p><ul><li><p><code>s[i]</code> 左边 <code>1</code> 的数目为 <code>sum[i]</code></p></li><li><p><code>s[i]</code> 右边 <code>0</code> 的数目为 <code>(len(s) - i) - (sum[len(s)] - sum[i])</code></p></li><li><p>遍历一轮 <code>s</code>，二者求和的最小值即为答案</p></li></ul><p>即 <code>left_ones + right_zeros = 2 * sum[i] - i + len(s) - sum[len(s)]</code></p><p>因此，只需保证 <code>2 * sum[i] - i</code> 为最小值，然后求得所有 <code>1</code> 的数目，即可得到最终的翻转次数，采用常数级空间复杂度即可实现。</p><p>注意：根据之前的定义，这里 <code>i</code> 的最大值仍然为 <code>len(s)</code></p><h4 id="Python3-1"><a href="#Python3-1" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minFlipsMonoIncr</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n, ans, l_ones = <span class="hljs-built_in">len</span>(s), inf, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>):<br>            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-number">2</span> * l_ones - i)<br>            <span class="hljs-comment"># 防止越界</span><br>            <span class="hljs-keyword">if</span> i &lt; n:<br>                l_ones += s[i] == <span class="hljs-string">&#x27;1&#x27;</span><br>        <span class="hljs-keyword">return</span> ans + n - l_ones;<br></code></pre></td></tr></table></figure><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFlipsMonoIncr</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length(), ans = Integer.MAX_VALUE, leftOnes = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            ans = Math.min(ans, <span class="hljs-number">2</span> * leftOnes - i);<br>            <span class="hljs-keyword">if</span>(i &lt; n) &#123;<br>                leftOnes += s.charAt(i) == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans + n - leftOnes;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第11篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 881. Boats to Save People</title>
    <link href="/2022/10/03/LC-Solution-881-Boats-to-Save-People/"/>
    <url>/2022/10/03/LC-Solution-881-Boats-to-Save-People/</url>
    
    <content type="html"><![CDATA[<h1 id="881-救生艇"><a href="#881-救生艇" class="headerlink" title="881. 救生艇"></a><a href="https://leetcode.cn/problems/boats-to-save-people/">881. 救生艇</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定数组 <code>people</code> 。<code>people[i]</code>表示第 <code>i</code> 个人的体重 ，<strong>船的数量不限</strong>，每艘船可以承载的最大重量为 <code>limit</code>。</p><p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 <code>limit</code>。</p><p>返回 <em>承载所有人所需的最小船数</em> 。</p><p><strong>示例1：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：people = [1,2], <span class="hljs-built_in">limit</span> = 3<br>输出：1<br>解释：1 艘船载 (1, 2)<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：people = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], limit = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-number">3</span> 艘船分别载 <span class="hljs-comment">(1, 2)</span>, <span class="hljs-comment">(2)</span> 和 <span class="hljs-comment">(3)</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：people = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], limit = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">4</span><br>解释：<span class="hljs-number">4</span> 艘船分别载 <span class="hljs-comment">(3)</span>, <span class="hljs-comment">(3)</span>, <span class="hljs-comment">(4)</span>, <span class="hljs-comment">(5)</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= people.length &lt;= 5 * 104</code></li><li><code>1 &lt;= people[i] &lt;= limit &lt;= 3 * 104</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：贪心-双指针"><a href="#方法一：贪心-双指针" class="headerlink" title="方法一：贪心 + 双指针"></a>方法一：贪心 + 双指针</h3><p>通过分析题意可以得出以下几点关键的信息：</p><ol><li><p>可用船数不限制</p></li><li><p>每艘船限乘2人，每搜船限制总重为<code>limit</code></p></li><li><p>返回结果与<code>people</code>数组的顺序无关</p></li></ol><p>为使得使用的船数最少，每搜船上的两个人的总重量最好 <strong>等于或尽可能接近</strong> <code>limit</code></p><p>因此，不难得出本题的思路：对<code>people</code>数组进行升序排序，双指针遍历<code>people</code>数组。</p><p>需要注意的一点：双指针<code>i</code>与<code>j</code>重合时，此时只剩余一个人，所以他单独乘一艘船。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numRescueBoats</span>(<span class="hljs-params">self, people: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], limit: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        people.sort()<br>        i, j, ans = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(people) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt;= j:<br>            <span class="hljs-keyword">if</span> i == j:<br>                ans += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> people[i] + people[j] &lt;= limit:<br>                ans, i, j = ans + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                ans, j = ans + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numRescueBoats</span><span class="hljs-params">(<span class="hljs-type">int</span>[] people, <span class="hljs-type">int</span> limit)</span> &#123;<br>        Arrays.sort(people);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = people.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-keyword">if</span>(i == j) &#123;<br>                ans++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(people[i] + people[j] &lt;= limit) &#123;<br>                ans++; i++; j--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans++; j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第10篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1784 Check if Binary String Has at Most One Segment of Ones</title>
    <link href="/2022/10/03/LC-Solution-1784-Check-if-Binary-String-Has-at-Most-One-Segment-of-Ones/"/>
    <url>/2022/10/03/LC-Solution-1784-Check-if-Binary-String-Has-at-Most-One-Segment-of-Ones/</url>
    
    <content type="html"><![CDATA[<h1 id="1784-检查二进制字符串字段"><a href="#1784-检查二进制字符串字段" class="headerlink" title="1784. 检查二进制字符串字段"></a><a href="https://leetcode.cn/problems/check-if-binary-string-has-at-most-one-segment-of-ones/">1784. 检查二进制字符串字段</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二进制字符串 <code>s</code> ，该字符串 <strong>不含前导零</strong> 。</p><p>如果 <code>s</code> 包含 <strong>零个或一个由连续的 ‘1’ 组成的字段</strong> ，返回 <code>true</code>​​​ 。否则，返回 <code>false</code></p><p>如果 <code>s</code> 中 <strong>由连续若干个 ‘1’ 组成的字段 数量不超过 1</strong>，返回 <code>true</code>​​​ 。否则，返回 <code>false</code></p><p><strong>示例1：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;1001&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：由连续若干个 <span class="hljs-string">&#x27;1&#x27;</span> 组成的字段数量为 <span class="hljs-number">2</span>，返回 <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;110&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s[i]</code>​​​​ 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li><li><code>s[0]</code> 为 <code>&#39;1&#39;</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：简单模拟"><a href="#方法一：简单模拟" class="headerlink" title="方法一：简单模拟"></a>方法一：简单模拟</h3><p>题目已经明确给定<code>s[0] = &#39;1&#39;</code>，所以我们只需要找出<code>s</code>中的第一个字符<code>&#39;0&#39;</code>的下标。</p><ul><li><p>若字符串<code>s</code>中不存在<code>&#39;0&#39;</code>，那么一定全为<code>&#39;1&#39;</code>，返回<code>True</code></p></li><li><p>若字符串<code>s</code>中存在<code>&#39;0&#39;</code>，但是在它的后面不存在<code>&#39;1&#39;</code>，说明<code>s</code>中只有一个由连续的<code>&#39;1&#39;</code>组成的字段（因为<code>s[0] = &#39;1&#39;</code>），返回<code>True</code></p></li></ul><p>若不满足以上两点条件，直接返回<code>False</code></p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkOnesSegment</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        idx = s.find(<span class="hljs-string">&#x27;0&#x27;</span>)<br>        <span class="hljs-keyword">if</span> idx == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s[idx:]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>采用三元表达式写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkOnesSegment</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> s.find(<span class="hljs-string">&#x27;0&#x27;</span>) == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s[s.find(<span class="hljs-string">&#x27;0&#x27;</span>):] <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkOnesSegment</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> s.indexOf(<span class="hljs-string">&quot;0&quot;</span>);<br>        <span class="hljs-keyword">if</span>(idx == -<span class="hljs-number">1</span> || s.substring(idx).indexOf(<span class="hljs-string">&quot;1&quot;</span>) == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure><p>采用三元表达式写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkOnesSegment</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> s.indexOf(<span class="hljs-string">&quot;0&quot;</span>) == -<span class="hljs-number">1</span> || s.substring(s.indexOf(<span class="hljs-string">&quot;0&quot;</span>)).indexOf(<span class="hljs-string">&quot;1&quot;</span>) == -<span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第9篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 807. Max Increase to Keep City Skyline</title>
    <link href="/2022/10/03/LC-Solution-807-Max-Increase-to-Keep-City-Skyline/"/>
    <url>/2022/10/03/LC-Solution-807-Max-Increase-to-Keep-City-Skyline/</url>
    
    <content type="html"><![CDATA[<h1 id="807-保持城市天际线"><a href="#807-保持城市天际线" class="headerlink" title="807. 保持城市天际线"></a><a href="https://leetcode.cn/problems/max-increase-to-keep-city-skyline/">807. 保持城市天际线</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一座由 <code>n x n</code> 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 <strong>0</strong> 开始的 <code>n x n</code> 整数矩阵 <code>grid</code> ，其中 <code>grid[r][c]</code> 表示坐落于 <code>r</code> 行 <code>c</code> 列的建筑物的 <strong>高度</strong> 。</p><p>城市的 <strong>天际线</strong> 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 <strong>天际线</strong> 可能不同。</p><p>我们被允许为 <strong>任意数量的建筑物</strong> 的高度增加 <strong>任意增量（不同建筑物的增量可能不同）</strong> 。 高度为 0 的建筑物的高度也可以增加。然而，增加的建筑物高度 <strong>不能影响</strong> 从任何主要方向观察城市得到的 <strong>天际线</strong> 。</p><p>在 <strong>不改变</strong> 从任何主要方向观测到的城市 <strong>天际线</strong> 的前提下，返回建筑物可以增加的 <strong>最大高度增量总和</strong></p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：grid = <span class="hljs-comment">[<span class="hljs-comment">[3,0,8,4]</span>,<span class="hljs-comment">[2,4,5,7]</span>,<span class="hljs-comment">[9,2,6,3]</span>,<span class="hljs-comment">[0,3,1,0]</span>]</span><br>输出：35<br>解释：建筑物的高度如上图中心所示。<br>用红色绘制从不同方向观看得到的天际线。<br>在不影响天际线的情况下，增加建筑物的高度：<br>gridNew = <span class="hljs-comment">[ <span class="hljs-comment">[8, 4, 8, 7]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[7, 4, 7, 7]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[9, 4, 8, 7]</span>,</span><br><span class="hljs-comment">            <span class="hljs-comment">[3, 3, 3, 3]</span> ]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[0,0,0],[0,0,0],[0,0,0]]</span><br>输出：<span class="hljs-number">0</span><br>解释：增加任何建筑物的高度都会导致天际线的变化。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == grid.length</code></li><li><code>n == grid[r].length</code></li><li><code>2 &lt;= n &lt;= 50</code></li><li><code>0 &lt;= grid[r][c] &lt;= 100</code></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：贪心算法"><a href="#方法一：贪心算法" class="headerlink" title="方法一：贪心算法"></a>方法一：贪心算法</h3><p>分析题意不难得出，东南西北的视图即<code>天际线</code>是由每行每列的最大值决定的。</p><p>因此，每个建筑最终达到的高度不能超过其所在行与列的最大高度，更加具体地说，不能超过<code>min(该行最大高度, 该列最大高度)</code>。</p><ul><li><p>第一遍遍历：提前预处理出每一行与每一列对应的最大高度值</p></li><li><p>第二遍遍历：往<code>ans</code>结果中累加当前遍历的建筑可以增加的最大高度</p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxIncreaseKeepingSkyline</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans, n = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(grid)<br>        rowMax, colMax = [<span class="hljs-number">0</span>] * n, [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                rowMax[i] = <span class="hljs-built_in">max</span>(rowMax[i], grid[i][j])<br>                colMax[j] = <span class="hljs-built_in">max</span>(colMax[j], grid[i][j])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                ans += <span class="hljs-built_in">min</span>(rowMax[i], colMax[j]) - grid[i][j]<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxIncreaseKeepingSkyline</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span>[] rowMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], colMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                rowMax[i] = Math.max(rowMax[i], grid[i][j]);<br>                colMax[j] = Math.max(colMax[j], grid[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                ans += Math.min(rowMax[i], colMax[j]) - grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第8篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 781. Rabbits in Forest</title>
    <link href="/2022/10/03/LC-Solution-781-Rabbits-in-Forest/"/>
    <url>/2022/10/03/LC-Solution-781-Rabbits-in-Forest/</url>
    
    <content type="html"><![CDATA[<h1 id="781-森林中的兔子"><a href="#781-森林中的兔子" class="headerlink" title="781. 森林中的兔子"></a><a href="https://leetcode.cn/problems/rabbits-in-forest/">781. 森林中的兔子</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>森林中有未知数量的兔子。提问其中若干只兔子 “<strong>还有多少只兔子与你（指被提问的兔子）颜色相同?</strong>“ ，将答案收集到一个整数数组 <code>answers</code> 中，其中 <code>answers[i]</code> 是第 <code>i</code> 只兔子的回答。</p><p>给你数组 <code>answers</code> ，返回森林中兔子的最少数量。</p><p><strong>示例1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：answers = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">5</span><br>解释：<br>两只回答了 <span class="hljs-string">&quot;1&quot;</span> 的兔子可能有相同的颜色，设为红色。 <br>之后回答了 <span class="hljs-string">&quot;2&quot;</span> 的兔子不会是红色，否则他们的回答会相互矛盾。<br>设回答了 <span class="hljs-string">&quot;2&quot;</span> 的兔子为蓝色。 <br>此外，森林中还应有另外 <span class="hljs-number">2</span> 只蓝色兔子的回答没有包含在数组中。 <br>因此森林中兔子的最少数量是 <span class="hljs-number">5</span> 只：<span class="hljs-number">3</span> 只回答的和 <span class="hljs-number">2</span> 只没有回答的。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：answers </span>=<span class="hljs-string"> [10,10,10]</span><br><span class="hljs-string">输出：11</span><br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：找规律"><a href="#方法一：找规律" class="headerlink" title="方法一：找规律"></a>方法一：找规律</h3><p>举例分析：</p><ol><li><p>当数组为<code>[2, 2 ,2]</code>时，1种颜色 - 3只兔子</p></li><li><p>当数组为<code>[2, 2, 2, 2]</code>时，2种颜色 - 6只兔子（前三只兔子为一种颜色，最后一只兔子以及未被问到的另外两只不知名兔子为另一种颜色）</p></li><li><p>当数组为<code>[2, 2, 2, 2, 2, 2]</code>时，2种颜色 - 6只兔子（前三只兔子为一种颜色，后三只兔子为另一种颜色）</p></li><li><p>当数组为<code>[2, 2, 2, 2, 2, 2, 2]</code>时，3种颜色 - 9只兔子（1,2,3号兔子为色号1，4,5,6号兔子为色号2，7号兔子以及另外两只不知名兔子为色号3）</p></li><li><p>以此类推…</p></li></ol><p>经过分析，抽象为数学找规律的题目。</p><p>用哈希表统计同一个数字出现的频率。设<code>num</code>为哈希表的key，<code>freq</code>为哈希表的值。</p><p>将<code>freq</code>分为<code>freq // (num + 1)</code>个组，余数再单独分到另一个组。</p><p>举例：<code>[1, 1, 2, 2, 2, 2, 2]</code>数组统计存入哈希表后。一个键值对为<code>&#123;1: 2&#125;</code>，可以被分为<code>2 // (1 + 1) = 1</code>个组，正好整除。另一个键值对为<code>&#123;2: 4&#125;</code>，可以被分为<code>4 // (2 + 1) = 1</code>个组，剩余的2组成一个组。答案为每个键值对对应的组数乘以<code>num + 1</code>求和</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numRabbits</span>(<span class="hljs-params">self, answers: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        dic = Counter(answers)<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> num, freq <span class="hljs-keyword">in</span> dic.items():<br>            ans += freq // (num + <span class="hljs-number">1</span>) * (num + <span class="hljs-number">1</span>) <br>            <span class="hljs-keyword">if</span> freq % (num + <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>:<br>                ans += num + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第7篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 777. Swap Adjacent in LR String</title>
    <link href="/2022/10/03/LC-Solution-777-Swap-Adjacent-in-LR-String/"/>
    <url>/2022/10/03/LC-Solution-777-Swap-Adjacent-in-LR-String/</url>
    
    <content type="html"><![CDATA[<h1 id="777-在LR字符串中交换相邻字符"><a href="#777-在LR字符串中交换相邻字符" class="headerlink" title="777. 在LR字符串中交换相邻字符"></a><a href="https://leetcode.cn/problems/swap-adjacent-in-lr-string/">777. 在LR字符串中交换相邻字符</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个由 <code>&#39;L&#39;</code> , <code>&#39;R&#39;</code> 和 <code>&#39;X&#39;</code> 三个字符组成的字符串（例如<code>&quot;RXXLRXRXL&quot;</code>）中进行移动操作。一次移动操作指用一个<code>&quot;LX&quot;</code>替换一个<code>&quot;XL&quot;</code>，或者用一个<code>&quot;XR&quot;</code>替换一个<code>&quot;RX&quot;</code>。现给定起始字符串<code>start</code>和结束字符串<code>end</code>，请编写代码，当且仅当存在一系列移动操作使得<code>start</code>可以转换成<code>end</code>时， 返回<code>True</code>。</p><p><strong>示例：</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coq">输入: start = <span class="hljs-string">&quot;RXXLRXRXL&quot;</span>, <span class="hljs-keyword">end</span> = <span class="hljs-string">&quot;XRLXXRRLX&quot;</span><br>输出: True<br>解释:<br>我们可以通过以下几步将start转换成<span class="hljs-keyword">end</span>:<br>RXXLRXRXL -&gt;<br>XRXLRXRXL -&gt;<br>XRLXRXRXL -&gt;<br>XRLXXRRXL -&gt;<br>XRLXXRRLX<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= len(start) = len(end) &lt;= 10000</code>。</li><li><code>start</code>和<code>end</code>中的字符串仅限于<code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>和<code>&#39;X&#39;</code>。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h3><p>根据题意进行分析模拟，题目将每一个<code>XL</code>都替换成了<code>LX</code>，将每一个<code>RX</code>都替换成了<code>XR</code></p><p>通过找规律可发现，替换的过程可以理解为<code>L</code>与<code>R</code>移动的过程。</p><ul><li><p>当<code>L</code>的左边为<code>X</code>时，<code>L</code>可向左移动</p></li><li><p>当<code>R</code>的右边为<code>X</code>时，<code>R</code>可向右移动</p></li><li><p><code>L</code>与<code>R</code>无法互相穿过（因为<code>L</code>左和<code>R</code>右必须为<code>X</code>）</p><ul><li>可得知当<code>start</code>与<code>end</code>去掉<code>X</code>后，剩余字符必须相同，否则返回False</li></ul></li></ul><p>根据此规律，使用双指针<code>i</code>与<code>j</code>从头到尾遍历<code>start</code>与<code>end</code></p><p>找到<code>start</code>与<code>end</code>中<code>非X</code>的字符时则停止移动，进行判断</p><p>判断条件为：</p><ul><li><p>若<code>start[i] == L and i &lt; j</code>，又因<code>L</code>无法向右移动，直接返回False</p></li><li><p>若<code>start[i] == R and i &gt; j</code>，又因<code>R</code>无法向左移动，直接返回False</p></li></ul><p>当双指针遍历字符串结束后，说明中途未返回False，则最终返回True</p><p>注意：</p><p><code>if i != j and (start[i] == &#39;L&#39;) != (i &gt; j)</code>该行代码摘自<a href="https://leetcode.cn/u/endlesscheng/">灵山茶艾府</a>大佬的题解，相当于将两个<code>if</code>判断条件揉为一个，其本质为：</p><ul><li><p><code>if i &lt; j and start[i] == &#39;L&#39;: return False</code></p></li><li><p><code>if i &gt; j and start[i] == &#39;R&#39;: return False</code></p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canTransform</span>(<span class="hljs-params">self, start: <span class="hljs-built_in">str</span>, end: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> start.replace(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>) != end.replace(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        n = <span class="hljs-built_in">len</span>(start)<br>        i = j = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; n <span class="hljs-keyword">and</span> j &lt; n:<br>            <span class="hljs-keyword">while</span> i &lt; n <span class="hljs-keyword">and</span> start[i] == <span class="hljs-string">&#x27;X&#x27;</span>: i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> j &lt; n <span class="hljs-keyword">and</span> end[j] == <span class="hljs-string">&#x27;X&#x27;</span>: j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> i != j <span class="hljs-keyword">and</span> (start[i] == <span class="hljs-string">&#x27;L&#x27;</span>) != (i &gt; j): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            i, j = i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canTransform</span><span class="hljs-params">(String start, String end)</span> &#123;<br>        <span class="hljs-keyword">if</span>(!start.replace(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).equals(end.replace(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> start.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; j &lt; n) &#123;<br>            <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; start.charAt(i) == <span class="hljs-string">&#x27;X&#x27;</span>) i += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(j &lt; n &amp;&amp; end.charAt(j) == <span class="hljs-string">&#x27;X&#x27;</span>) j += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> ((i != j) &amp;&amp; ((start.charAt(i) == <span class="hljs-string">&#x27;L&#x27;</span>) != (i &gt; j))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            i++; j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第5篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1694. Reformat Phone Number</title>
    <link href="/2022/10/03/LC-Solution-1694-Reformat-Phone-Number/"/>
    <url>/2022/10/03/LC-Solution-1694-Reformat-Phone-Number/</url>
    
    <content type="html"><![CDATA[<h1 id="1694-重新格式化电话号码"><a href="#1694-重新格式化电话号码" class="headerlink" title="1694. 重新格式化电话号码"></a><a href="https://leetcode.cn/problems/reformat-phone-number/">1694. 重新格式化电话号码</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串形式的电话号码 <code>number</code> 。<code>number</code> 由数字、空格 <code>&#39; &#39;</code>、和破折号<code>&#39;-&#39;</code>组成。</p><p>请你按下述方式重新格式化电话号码。</p><ul><li><p>首先，删除 所有的空格和破折号。</p></li><li><p>其次，将数组从左到右 每 3 个一组 分块，直到 剩下 4 个或更少数字。剩下的数字将按下述规定再分块：</p><ul><li><p>2 个数字：单个含 2 个数字的块。</p></li><li><p>3 个数字：单个含 3 个数字的块。</p></li><li><p>4 个数字：两个分别含 2 个数字的块。</p></li></ul></li><li><p>最后用破折号将这些块连接起来。注意，重新格式化过程中 不应该 生成仅含 1 个数字的块，并且 最多 生成两个含 2 个数字的块。</p></li></ul><p>返回格式化后的电话号码。</p><p><strong>示例1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：number <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1-23-45 6&quot;</span><br>输出：<span class="hljs-string">&quot;123-456&quot;</span><br>解释：数字是 <span class="hljs-string">&quot;123456&quot;</span><br>步骤 <span class="hljs-number">1</span>：共有超过 <span class="hljs-number">4</span> 个数字，所以先取 <span class="hljs-number">3</span> 个数字分为一组。第 <span class="hljs-number">1</span> 个块是 <span class="hljs-string">&quot;123&quot;</span> 。<br>步骤 <span class="hljs-number">2</span>：剩下 <span class="hljs-number">3</span> 个数字，将它们放入单个含 <span class="hljs-number">3</span> 个数字的块。第 <span class="hljs-number">2</span> 个块是 <span class="hljs-string">&quot;456&quot;</span> 。<br>连接这些块后得到 <span class="hljs-string">&quot;123-456&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：number <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123 4-567&quot;</span><br>输出：<span class="hljs-string">&quot;123-45-67&quot;</span><br>解释：数字是 <span class="hljs-string">&quot;1234567&quot;</span>.<br>步骤 <span class="hljs-number">1</span>：共有超过 <span class="hljs-number">4</span> 个数字，所以先取 <span class="hljs-number">3</span> 个数字分为一组。第 <span class="hljs-number">1</span> 个块是 <span class="hljs-string">&quot;123&quot;</span> 。<br>步骤 <span class="hljs-number">2</span>：剩下 <span class="hljs-number">4</span> 个数字，所以将它们分成两个含 <span class="hljs-number">2</span> 个数字的块。这 <span class="hljs-number">2</span> 块分别是 <span class="hljs-string">&quot;45&quot;</span> 和 <span class="hljs-string">&quot;67&quot;</span> 。<br>连接这些块后得到 <span class="hljs-string">&quot;123-45-67&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：number <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123 4-5678&quot;</span><br>输出：<span class="hljs-string">&quot;123-456-78&quot;</span><br>解释：数字是 <span class="hljs-string">&quot;12345678&quot;</span> 。<br>步骤 <span class="hljs-number">1</span>：第 <span class="hljs-number">1</span> 个块 <span class="hljs-string">&quot;123&quot;</span> 。<br>步骤 <span class="hljs-number">2</span>：第 <span class="hljs-number">2</span> 个块 <span class="hljs-string">&quot;456&quot;</span> 。<br>步骤 <span class="hljs-number">3</span>：剩下 <span class="hljs-number">2</span> 个数字，将它们放入单个含 <span class="hljs-number">2</span> 个数字的块。第 <span class="hljs-number">3</span> 个块是 <span class="hljs-string">&quot;78&quot;</span> 。<br>连接这些块后得到 <span class="hljs-string">&quot;123-456-78&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：number <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12&quot;</span><br>输出：<span class="hljs-string">&quot;12&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例5：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：number = &quot;-<span class="hljs-string">-17</span><span class="hljs-string">-5</span> 229 35<span class="hljs-string">-39475</span> &quot;<br>输出：&quot;175<span class="hljs-string">-229</span><span class="hljs-string">-353</span><span class="hljs-string">-94</span><span class="hljs-string">-75</span>&quot;<br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：简单模拟"><a href="#方法一：简单模拟" class="headerlink" title="方法一：简单模拟"></a>方法一：简单模拟</h3><p>先预处理<code>number</code>字符串，去除字符串中除数字之外的字符。</p><p>定义<code>res</code>为字符串列表，其中的每一个字符串最终需要以<code>&#39;-&#39;</code>分割。</p><p>根据题意分析循环过程中的if条件（<code>i</code>表示当前遍历位置，<code>s</code>表示预处理后的字符串）：</p><ul><li><p>若当前位置<code>i + 4 == len(s)</code>，将<code>s[i:i+2]</code>与<code>s[i+2:i+4]</code>切片追加到<code>res</code>列表</p></li><li><p>否则，直接将<code>s[i:i+3]</code>切片追加到<code>res</code>列表</p><ul><li><p>这里隐藏了一点：<code>i + 2 == len(s)</code>的特殊情况已经考虑在else情况中：</p><ul><li>巧妙利用了Python的切片性质：右边界超出字符串长度时，直接将字符串长度作为右边界。</li></ul></li></ul></li></ul><p>理清模拟逻辑后，开始编写代码，注意循环的<code>step</code>为3，最后用<code>&#39;-&#39;</code>将res拼接。</p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reformatNumber</span>(<span class="hljs-params">self, number: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        s = number.replace(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>        res = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-number">3</span>):<br>            <span class="hljs-keyword">if</span> i + <span class="hljs-number">4</span> == <span class="hljs-built_in">len</span>(s):<br>                res.append(s[i:i + <span class="hljs-number">2</span>])<br>                res.append(s[i + <span class="hljs-number">2</span>:i + <span class="hljs-number">4</span>])   <br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                res.append(s[i: i + <span class="hljs-number">3</span>])<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;-&#x27;</span>.join(res)<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第4篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution Interview Questions 01.08</title>
    <link href="/2022/10/03/LC-Solution-Interview-Questions-01-08/"/>
    <url>/2022/10/03/LC-Solution-Interview-Questions-01-08/</url>
    
    <content type="html"><![CDATA[<h1 id="01-08-Zero-Matrix-LCCI"><a href="#01-08-Zero-Matrix-LCCI" class="headerlink" title="01.08. Zero Matrix LCCI"></a><a href="https://leetcode.cn/problems/zero-matrix-lcci/">01.08. Zero Matrix LCCI</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,1,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,0,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,1,1]</span></span><br><span class="hljs-comment">]</span><br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,0,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[0,0,0]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,0,1]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[0,1,2,0]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4,5,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3,1,5]</span></span><br><span class="hljs-comment">]</span><br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[0,0,0,0]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[0,4,5,0]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[0,3,1,0]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h3><p>题目要求当二维数组中的某个元素值为0时，将其所在的行和列的全部元素置为0。</p><p>通过分析题意，可以想到采用标记数组存储符合题意的行与列。</p><ul><li><p>第一次遍历：标记行与列</p></li><li><p>第二次遍历：对标记的行与列中的元素进行修改</p></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setZeroes</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        row = [<span class="hljs-literal">False</span>] * <span class="hljs-built_in">len</span>(matrix)<br>        col = [<span class="hljs-literal">False</span>] * <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span>:<br>                    row[i] = col[j] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>                matrix[i][j] = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> row[i] == <span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> col[j] == <span class="hljs-literal">True</span> <span class="hljs-keyword">else</span> matrix[i][j]<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[] row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m], col = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    row[i] = col[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span>(row[i] == <span class="hljs-literal">true</span> || col[j] == <span class="hljs-literal">true</span>) &#123;<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第3篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 3. Longest Substring Without Repeating Characters</title>
    <link href="/2022/10/03/LC-Solution-3-Longest-Substring-Without-Repeating-Characters/"/>
    <url>/2022/10/03/LC-Solution-3-Longest-Substring-Without-Repeating-Characters/</url>
    
    <content type="html"><![CDATA[<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><h3 id="方法一：滑动窗口"><a href="#方法一：滑动窗口" class="headerlink" title="方法一：滑动窗口"></a>方法一：滑动窗口</h3><p>题目要求从给定字符串<code>s</code>中找出不包含重复字符的最长子串的长度</p><p>由于子串是连续的，可以想到采用滑动窗口解决该问题。</p><p>思路如下：</p><ul><li><p>采用双指针<code>i</code>与<code>j</code>作为滑动窗口的左端点与右端点，初始值为0</p></li><li><p>采用哈希表记录已经遍历过的字符。其<code>key</code>为字符本身，<code>value</code>为当前字符对应的下标</p></li><li><p>设<code>maxLen</code>为不包含重复字符的最长子串的长度</p></li><li><p>从头到尾遍历字符串<code>s</code></p><ol><li>判断哈希表是否存储当前字符<code>c</code></li></ol><ul><li><p>若哈希表已存储当前字符<code>c</code></p><ul><li><p>需要收缩滑动窗口，即更新滑动窗口左端点<code>i</code>的位置</p><ul><li><p>此时，左端点<code>i</code>有两种选择，第一种为保持<code>i</code>不变，第二种为将其更新为哈希表中当前字符<code>c</code>对应的下标再加1</p><ol><li><p>如果当前滑动窗口不包含当前字符<code>c</code>但哈希表中却存储着<code>c</code>，则需要选择第一种更新方案。例如<code>abba</code>字符串。</p></li><li><p>如果当前滑动窗口包含当前字符<code>c</code>，则需要选择第二种更新方案。例如<code>abca</code>字符串。</p></li></ol></li></ul><p>. 为综合以上两种更新方案，左端点<code>i</code>更新时区二者最大值即可。</p></li></ul></li></ul><ol start="2"><li><p>更新哈希表</p></li><li><p>比较当前滑动窗口长度与<code>maxLen</code>的大小，并为<code>maxLen</code>赋值</p></li><li><p>滑动窗口向右滑动，<code>j</code>自增</p></li></ol></li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dic = defaultdict(<span class="hljs-built_in">int</span>)<br>        maxlen, left = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">in</span> dic:<br>                left = <span class="hljs-built_in">max</span>(dic[s[i]] + <span class="hljs-number">1</span>, left)<br>            dic[s[i]] = i<br>            maxlen = <span class="hljs-built_in">max</span>(maxlen, i - left + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> maxlen<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, curLen = <span class="hljs-number">0</span>;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            curLen++;<br>            <span class="hljs-keyword">while</span>(set.contains(s.charAt(i))) &#123;<br>                set.remove(s.charAt(left));<br>                left++;<br>                curLen--;<br>            &#125;<br>            maxLen = Math.max(curLen, maxLen);<br>            set.add(s.charAt(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第6篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 2. Add Two Nums</title>
    <link href="/2022/10/03/LC-Solution-2-Add-Two-Nums/"/>
    <url>/2022/10/03/LC-Solution-2-Add-Two-Nums/</url>
    
    <content type="html"><![CDATA[<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[2,4,3]</span>, l2 = <span class="hljs-comment">[5,6,4]</span><br>输出：<span class="hljs-comment">[7,0,8]</span><br>解释：342 + 465 = 807.<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[0]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：l1 = [<span class="hljs-number">9,9,9,9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>], l2 = [<span class="hljs-number">9,9,9,9</span>]<br>输出：[<span class="hljs-number">8,9,9,9</span>,<span class="hljs-number">0,0,0,1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：链表-数学-模拟"><a href="#方法一：链表-数学-模拟" class="headerlink" title="方法一：链表 + 数学 + 模拟"></a>方法一：链表 + 数学 + 模拟</h3><p>此题可直接理解为数学中的竖式相加</p><p>链表从左至右可以理解为从低位到高位，因此依次遍历链表，同一位置直接相加即可</p><p>设当前两个链表相同位置上的数分别为<code>x1</code>与<code>x2</code>，其进位值为<code>carry</code></p><p>进行相加之后，<code>sum</code>为<code>x1 + x2 + carry</code>，则</p><ul><li><p>结果链表的当前值<code>head.val = sum % 10</code>，添加至结果链表，链表前移</p></li><li><p>新的进位值<code>carry = sum // 10</code></p></li></ul><p>依次类推，继续前移链表节点，直至两链表遍历结束。</p><p>注意：遍历结束之后，需要判断最后的<code>carry</code>是否为1</p><ul><li>若最后的<code>carry == 1</code>，则说明需要再向上进一位</li></ul><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        res = head = <span class="hljs-literal">None</span><br>        carry = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2:<br>            v1 = l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            v2 = l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-built_in">sum</span> = v1 + v2 + carry<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res:<br>                res = head = ListNode(<span class="hljs-built_in">sum</span> % <span class="hljs-number">10</span>)<br>            <span class="hljs-keyword">else</span>:<br>                head.<span class="hljs-built_in">next</span> = ListNode(<span class="hljs-built_in">sum</span> % <span class="hljs-number">10</span>)<br>                head = head.<span class="hljs-built_in">next</span><br>            carry = <span class="hljs-built_in">sum</span> // <span class="hljs-number">10</span><br>            <span class="hljs-keyword">if</span> l1:<br>                l1 = l1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> l2:<br>                l2 = l2.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">if</span> carry &gt; <span class="hljs-number">0</span>:<br>            head.<span class="hljs-built_in">next</span> = ListNode(carry)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, head = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> v1 + v2 + carry;<br>            <span class="hljs-keyword">if</span>(res == <span class="hljs-literal">null</span>) &#123;<br>                res = head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                head.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>                head = head.next;<br>            &#125;<br>            carry = sum / <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">null</span>) l1 = l1.next;<br>            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">null</span>) l2 = l2.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry &gt; <span class="hljs-number">0</span>) &#123;<br>            head.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第2篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-Solution 1. Two Sum</title>
    <link href="/2022/10/03/LC-Solution-1-Two-Sum/"/>
    <url>/2022/10/03/LC-Solution-1-Two-Sum/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1.两数之和</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重lt复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p>进阶：你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h3><p>对数组进行遍历，用哈希表存放数组值及其对应的下标值。</p><ul><li><code>key</code> &#x3D;&gt; 元素值， <code>value</code> &#x3D;&gt; 元素值对应的下标值</li></ul><p>当发现<code>target - nums[i]</code> 即 <code>目标值与当前值之差</code> 是否在哈希表中出现过</p><ul><li><p>若出现过，则说明找到了目标值，直接返回即可</p></li><li><p>若未出现，继续遍历</p></li></ul><p>核心思路为<code>空间换时间</code>，若不采用哈希表，则双重for循环朴素解法时间复杂度为<code>O(n^2)</code></p><p>在循环遍历的过程中确定<code>nums[i]</code>为当前数，然后在哈希表中查找该数之前是否存在一个数为<code>target - nums[i]</code>。</p><h4 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], t: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        dic = defaultdict(<span class="hljs-built_in">int</span>)<br>        <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            x = t - v<br>            <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> dic:<br>                <span class="hljs-keyword">return</span> [dic[x], i]<br>            dic[v] = i<br></code></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> t) &#123;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(t - nums[i])) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;map.get(t - nums[i]), i&#125;;<br>            map.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Encouragement"><a href="#Encouragement" class="headerlink" title="Encouragement"></a>Encouragement</h2><p>目前就读于新加坡国立大学，转码菜鸡一枚。</p><p>决心通过日更一篇题解激励自己坚持刷题，坚持学习算法。</p><p>这是我搭建<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Leetcode-Everyday</a>仓库后发布の第1篇题解，欢迎各位star并提出Issue~</p><p>点击<a href="https://leetcode.cn/u/ltyzzz/">这里</a>，进入我的个人Leetcode主页~</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
